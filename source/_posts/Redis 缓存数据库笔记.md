---
title: Redis 缓存数据库笔记
date: 2018-12-8 17:45:41
tags: [Redis,NoSQL,笔记整理,面经]
categories: [Redis 学习]
---



### Redis 数据结构

- string(字符串)
- list(双向链表)
- dict(hash表)
- set(集合)
- zset(排序set)

 <!--more-->

### 事务实现原理

#### 事务阶段

1. 事务开始
2. 命令入队
3. 事务执行



#### 原理

​	将客户端的请求命令放入到事务队列中，然后向客户端响应一个 QUEUE ，服务器并不会立即执行这些命令。只有命令:EXEC,DISCARD,WATCH,MULTI命令会被立即执行,其它命令服务器不会立即执行



#### 命令

- MULTI 启动事务的标识
- EXEC 执行事务
- WATCH 在 EXEC 命令执行之前,监视任意数量的数据库键,并在执行 EXEC 命令时判断是否至少有一个被 watch 的键值被修改
- DISCARD 清空客户端的事务队列里的所有命令,并取消客户端的事务标记,取消所有 WATCH。



### Redis 持久化

#### RDB持久化

​	将Reids在内存中的数据库记录定时dump到磁盘。指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是 fork 一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。

**优势：**
- 整个 Redis 数据库将只包含一个文件，可以非常轻松的将一个单独的文件压缩后再转移到其它存储介质上。
- 性能最大化，使用子线程去执行持久化工作。
- 数据集很大，RDB的启动效率会更高。

**缺陷：**
- 无法保证数据的高可用性，即最大限度的避免数据丢失
- 由于 RDB 是通过 fork 子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。

#### AOF（append only file）持久化

​	将Reids的操作日志以追加的方式写入文件。以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。

**优势：**
- 可以带来更高的数据安全性，即数据持久性。拥有3种同步策略，即每秒同步、每修改同步和不同步。
- 该机制对日志文件的写入操作采用的是 append 模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。
- AOF包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。该日志文件可用于重建。

**缺点：**
- 对于相同数量的数据集而言，AOF文件通常要大于RDB文件。
- 根据同步策略的不同，AOF在运行效率上往往会慢于RDB。



### Redis 热点数据

​	redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。

#### 数据淘汰策略

- volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
- volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
- volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
- allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
- allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
- no-enviction（驱逐）：禁止驱逐数据

#### 热点数据的应用

​	MySQL 中存在2000万条数据，redis 中只存20万数据。限定 Redis 占用的内存（20W 数据大约占用的内存），Redis 会根据自身数据淘汰策略(LRU)，加载热数据到内存。



### 缓存系统面临的问题

#### 缓存一致性问题

1. 缓存系统与底层数据的一致性。这点在底层系统是“可读可写”时，写得尤为重要
2. 有继承关系的缓存之间的一致性。为了尽量提高缓存命中率，缓存也是分层：全局缓存，二级缓存。他们是存在继承关系的。全局缓存可以有二级缓存来组成。
3. 多个缓存副本之间的一致性。为了保证系统的高可用性，缓存系统背后往往会接两套存储系统（如memcache，redis等）



#### 缓存穿透

​	一般的缓存系统，都是按照 key 去缓存查询，如果不存在对应的 value ，就应该去后端系统查找（比如DB）。如果 key 对应的 value 是一定不存在的，并且对该 key 并发请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。

**如何避免**
1. 对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该 key 对应的数据 insert 了之后就清理缓存。
2. 对一定不存在的 key 进行过滤。可以把所有的可能存在的 key 放到一个大的 Bitmap 中，查询时通过该 bitmap 过滤。



#### 缓存雪崩

​	当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统(比如DB)带来很大压力。

**如何避免**
1. 在缓存失效后，通过**加锁或者队列来控制读数据库写缓存的线程数量**。比如对某个 key 只允许一个线程查询数据和写缓存，其他线程等待。
2. 不同的 key，设置不同的过期时间，让**缓存失效的时间点尽量均匀**。
3. 做**二级缓存**，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期。



#### 缓存数据的淘汰

​	缓存淘汰的策略有两种： (1) 定时去清理过期的缓存。 （2）当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂。

> ​	预估失效时间 
>
> ​	版本号（必须单调递增，时间戳是最好的选择）
>
> ​	提供手动清理缓存的接口。
>





### 一致性 Hash 算法

#### 定义

​	一致性 Hash 算法将整个哈希值空间组织成一个虚拟的圆环，好处就是提高**容错性**和**可扩展性**。对于节点的增减都只需重定位环空间中的一小部分数据。

#### 原理

​	一致性Hash算法将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数H的值空间为0-2^32-1（即哈希值是一个32位无符号整形），整个哈希环如下：

<img src="https://mubu.com/document_image/ba256bbf-7db3-463c-94b0-184702483bf2-983181.jpg" width="50%" height="50%"/>

​	整个空间按顺时针方向组织，圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、5、6……直到2^32-1，也就是说0点左侧的第一个点代表2^32-1， 0和2^32在零点中方向重合，我们把这个由2^32个点组成的圆环称为Hash环。

​	各个服务器使用Hash进行一次哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置

​	将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器！

<img src="https://mubu.com/document_image/4047100c-8984-4d3a-a941-1537d0bdc805-983181.jpg" width="50%" height="50%"/>

#### 优势

​	解决分布式系统每个节点都有可能失效，并且新的节点很可能动态的增加进来的情况，<u>保证当系统的节点数目发生变化的时候，只有小部分数据受到影响</u>，我们的系统仍然能够对外提供良好的服务。

#### 缺陷

​	Hash 环的数据倾斜问题，即：一致性 Hash 算法在服务节点很少时，容易因为节点分布不均匀而造成数据倾斜（被缓存的对象大部分集中缓存在某一台服务器上）问题

​	可以采用**虚拟节点机制**。具体做法可以在服务器IP或主机名的后面增加编号来实现。同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射





### Redis、Memcache和MongoDB的区别

#### Redis

- 支持多种数据结构
- 支持持久化操作 RDB、AOF
- 支持简单的事务需求，不支持回滚
- 单线程请求

#### Memcached

- 只支持简单的key/value数据结构
- 无法进行持久化，数据不能备份，只能用于缓存使用，且重启后数据全部丢失
- 应用场景：用于在动态系统中减少数据库负载，提升性能；做缓存，提高性能（适合读多写少，对于数据量比较大，可以采用sharding）

#### mongoDB 

- 文档性的数据库（存放xml、json、bson类型系那个的数据）
- 存放 json 格式数据
- 持久化：延时批量（groupcommit）提交写入
- 数据分析的功能(mapreduce)
- 适合场景：事件记录、内容管理或者博客平台，比如评论系统



### NoSQL

- NoSQL是非关系型数据库，NoSQL = Not Only SQL。
- 关系型数据库采用的结构化的数据，NoSQL 采用的是键值对的方式存储数据。
- 在处理**非结构化/半结构化**的大数据时；在水平方向上进行扩展时；随时应对动态增加的数据项时可以优先考虑使用NoSQL数据库。
- 在考虑数据库的成熟度、支持、分析和商业智能、管理及专业性等问题时，应优先考虑关系型数据库。



> 参考博客：
>
> Redis 事务 https://blog.csdn.net/bugall/article/details/52386698
>
> Redis、Memcache和MongoDB的区别 https://www.cnblogs.com/tuyile006/p/6382062.html