---
title: 安卓学习之2048
date: 2017-07-07 15:11:40
tags: [安卓,andriod,2048]
categories: [安卓学习]
---

### 一个叫做2048的小游戏

- 许久未更新我的博客了，只是因为，这几天觉得并没有什么好写的，好记录下来的。有时候只是学习到编码中的一点点小技巧，大多也是自己通过在网上学习，自己敲代码所总结出来的。可能是自己做的不多吧。

-  这两天重新把自己开始接触安卓时想做的一个小游戏继续完善了一下，两个月之后回头再看看自己当时的代码，还是学的有许多许多需要去改进的地方，这也说明我还是不断的在学习^ - ^。<!--more--> 以前直接将每一种方块看成图片，然后自己做2~2048的图片，以图片的形式填充到每一个ImageView中，现在则是以TextView形式，动态设置每一方块的数字以及背景色。这样使得游戏占得空间小多啦，这也是网上所推荐的方法。

<center>
<img src="http://hexoblog-1253306922.cosgz.myqcloud.com/photo2017/S70707-150825.jpg" width="50%" height="50%" />
 </center>

```
	private LinearLayout layout;
    private Button mainMenu;
    private Button btnReset;
    private Button btnUp;
    private TextView textScore;
    private TextView textBestScore;
    private int[][] oldFlag = new int[4][4];
    private static int score = 0;
    private static int best_score=0;
    //触摸事件手指按下和松开的两个坐标
    private float x1 = 0;
    private float x2 = 0;
    private float y1 = 0;
    private float y2 = 0;
    //16个方块的id
    static int[][] btnBlock = {
            {R.id.btn00, R.id.btn01, R.id.btn02, R.id.btn03},
            {R.id.btn10, R.id.btn11, R.id.btn12, R.id.btn13},
            {R.id.btn20, R.id.btn21, R.id.btn22, R.id.btn23},
            {R.id.btn30, R.id.btn31, R.id.btn32, R.id.btn33}
    };
    //16个方块的对应的值
    static int[][] flag = {
            {0, 0, 0, 0},
            {0, 0, 0, 0},
            {0, 0, 0, 0},
            {0, 0, 0, 0}
    };
```
- 以二维数组的形式存储每一个方块对应的值，然后根据方块中的值，来动态绘制每一个方块的数字以及背景色。
```
//手势滑动
    @TargetApi(Build.VERSION_CODES.M)
    @Override
    public boolean onTouch(View v, MotionEvent event) {
        switch (event.getAction()) {
            case MotionEvent.ACTION_DOWN:
                x1 = event.getX();
                y1 = event.getY();
                break;
            case MotionEvent.ACTION_MOVE:
                x2 = event.getX();
                y2 = event.getY();
                break;
            case MotionEvent.ACTION_UP:
                if (x2 - x1 > 50 && Math.abs(x2 - x1) > Math.abs(y2 - y1)) {
//                    Toast.makeText(this,"向右滑动",Toast.LENGTH_SHORT).show();
                    moveToRight();
                } else if (x1 - x2 > 50 && Math.abs(x2 - x1) > Math.abs(y2 - y1)) {
//                    Toast.makeText(this,"向左滑动",Toast.LENGTH_SHORT).show();
                    moveToLeft();
                } else if (y2 - y1 > 50 && Math.abs(x2 - x1) < Math.abs(y2 - y1)) {
//                    Toast.makeText(this,"向下滑动",Toast.LENGTH_SHORT).show();
                    moveToBottom();
                } else if (y1 - y2 > 50 && Math.abs(x2 - x1) < Math.abs(y2 - y1)) {
//                    Toast.makeText(this,"向上滑动",Toast.LENGTH_SHORT).show();
                    moveToUp();
                }
        }
        return true;
    }
```
​	重写触摸事件，按下的时候记录当前的坐标，手指滑动时记录手指所在坐标。滑动结束时（也就是手指放开时），计算坐标之间的变化来判断手势的滑动方向以进行方块的滑动。
```
//向右滑动
    public void moveToRight() {
        for (int i = 0; i < 16; i++) {
            oldFlag[i / 4][i % 4] = flag[i / 4][i % 4];
        }
        for (int j = 0; j < 4; j++) {
            ArrayList<Integer> list1 = new ArrayList<>();
            for (int i = 0; i < 4; i++) {
                if (flag[j][3 - i] != 0) {
                    list1.add(flag[j][3 - i]);
                }
            }
            ArrayList<Integer> temp = new ArrayList<>();
            int i = 0;
            for (i = 0; i < list1.size() - 1; i++) {
                if (list1.get(i) == 2048){
                }else if (list1.get(i) == list1.get(i + 1)) {
                    temp.add(list1.get(i) * 2);
                    score += list1.get(i) * 2;
                    i++;
                } else {
                    temp.add(list1.get(i));
                }
            }
            if (i == list1.size() - 1) {
                temp.add(list1.get(i));
            }
            if (list1.size() > 1) {
                list1 = temp;
            }
            for (i = 0; i < list1.size(); i++) {
                flag[j][3 - i] = list1.get(i);
                fillBlock(list1.get(i), j, 3 - i);
            }
            for (i = list1.size(); i < 4; i++) {
                flag[j][3 - i] = 0;
                fillBlock(0, j, 3 - i);
            }
        }
        //判断是否变化
        boolean isNext = false;
        for (int i = 0; i < 16; i++) {
            if (oldFlag[i / 4][i % 4] != flag[i / 4][i % 4]) {
                isNext = true;
                break;
            }
        }
        if (isNext) {
            nextBlock();
        } else if (isGameOver()) {
            Toast.makeText(MainActivity.this, "GAME OVER", Toast.LENGTH_SHORT);
            reset();   //重新开始
        }
    }
```
 - 首先记录滑动之前的二维数组（1.判断此次滑动时候有方块变化，2.便于返回上一步），然后根据手势滑动所得的方向，将方块中的值依次添加到四个List<Integer>，接下来遍历一遍，如果当前list.get(i)与list.get(i+1)相等，则两个数据合并，保存到一个temp的List中。最后将temp中的值一次填到二维数组的对应位置中去。
 -  最后将方块显示出来，通过设置每一个方块的数字以及背景色。（这里还是差一个动画的效果，就更完美了！）
 -  还有最高的记录，是用的安卓的SharedPreferences存储，以XML标签的形式将数据保存与本地手机上。每次打开游戏的时候，初始化界面的时候从score_data.xml文件中读取到对应的最高分。
 ```
 //保存数据
    public void saveBest_score(Score score){
        SharedPreferences.Editor editor =getApplicationContext().getSharedPreferences("score_data", Context.MODE_PRIVATE).edit();
        editor.putString("name",score.getName());
        editor.putInt("score",score.getScore());
        editor.putString("time",score.getTime());
        editor.commit();
    }
 ```
<center>
<img src="http://hexoblog-1253306922.cosgz.myqcloud.com/photo2017/S70707-150832.jpg" width="50%" height="50%" />
 </center>

​	我的<b>[2048游戏源码](https://github.com/Mindyu/2048Game.git)</b>
