---
title: Java 内存模型与内存划分
date: 2018-11-13 10:06:41
tags: [Java内存模型,Java内存划分,笔记整理,面经]
categories: [Java 学习]
---

### JVM 内存模型

#### 主要目标

定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样底层细节。此处的变量与Java编程时所说的变量不一样，指包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，后者是线程私有的，不会被共享。



#### 规则

所有的变量都存储在主内存中，每个线程还有自己的工作内存，线程的工作内存中保存了该线程使用到的变量到主内存副本拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。

<!-- more -->

![img](https://mubu.com/document_image/78099ccf-e7f0-414e-b90d-ba6c27c0efab-983181.jpg)



#### 内存间交互操作

关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成
> lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。
>
> unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
>
> read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用
>
> load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
>
> use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。
>
> assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
>
> store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。
>
> write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。



#### 重排序

- 种类

  - 编译器优化的重排序。编译器在不改变单线程程序语义放入前提下，可以重新安排语句的执行顺序。

  - 指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。

  - 内存系统的重排序。由于处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

    ![img](https://mubu.com/document_image/98b6179b-79eb-46fc-82cb-e764cbbb0cfb-983181.jpg)

- 如何避免重排序

  - 为了保证内存的可见性，Java 编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。

  - 内存屏障类型

    ![img](https://mubu.com/document_image/91399535-fcb8-40f3-8935-829f00d0e453-983181.jpg)

  - volatile 原理 <https://www.jianshu.com/p/2ab5e3d7e510>

    - 在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障；
    - 在每个volatile读操作前插入 LoadLoad屏障，在读操作后插入LoadStore屏障；

#### happens-before 原则

happens-before 原则来辅助保证程序执行的原子性、可见性以及有序性的问题，它是判断数据是否存在竞争、线程是否安全的依据

**八条原则**

- 程序顺序原则：即在一个线程内必须保证语义串行性，也就是说按照代码顺序执行。
- 锁规则：解锁(unlock)操作必然发生在后续的同一个锁的加锁(lock)之前，也就是说，如果对于一个锁解锁后，再加锁，那么加锁的动作必须在解锁动作之后(同一个锁)。
- volatile 规则： volatile 变量的写先发生于读，这保证了 volatile 变量的可见性，简单的理解就是，volatile 变量在每次被线程访问时，都强迫从主内存中读该变量的值，而当该变量发生变化时，又会强迫将最新的值刷新到主内存，任何时刻，不同的线程总是能够看到该变量的最新值。
- 线程启动规则：线程的start()方法先于它的每一个动作，即如果线程A在执行线程B的 start 方法之前修改了共享变量的值，那么当线程B执行 start 方法时，线程A对共享变量的修改对线程B可见
- 线程终止规则：线程的所有操作先于线程的终结，Thread.join() 方法的作用是等待当前执行的线程终止。假设在线程B终止之前，修改了共享变量，线程A从线程B的join方法成功返回后，线程B对共享变量的修改将对线程A可见。
- 线程中断规则：对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测线程是否中断。
- 对象终结规则：对象的构造函数执行，结束先于finalize()方法
- 传递性：A先于B ，B先于C 那么A必然先于C



#### JVM 参数列表

> java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxPermSize=16m -XX:MaxTenuringThreshold=0
>
> -Xmx3550m：最大堆内存为3550M。
>
> -Xms3550m：初始堆内存为3550M。此值可以设置与-Xmx相同,以避免每次垃圾回收完成后JVM重新分配内存。空闲空间小于40%时会扩大堆，空闲空间大于70%时会缩小堆。
>
> -Xmn2g：设置年轻代大小为2G。整个堆大小=年轻代大小 + 年老代大小 + 永久代大小。永久代一般固定大小为64m,所以增大年轻代后,将会减小年老代大小。此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8。
>
> -Xss128k：设置每个线程的堆栈大小。
>
> -XX:NewRatio=4：设置年轻代(包括Eden和两个Survivor区)与年老代的比值。设置为4,则年轻代与年老代所占比值为1:4,年轻代占整个堆栈的1/5
>
> -XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的大小比值。设置为4,则两个Survivor区与一个Eden区的比值为2:4,一个Survivor区占整个年轻代的1/6
>
> -XX:MaxPermSize=16m：设置永久代大小为16m。
>
> -XX:MaxTenuringThreshold=15：设置垃圾最大年龄。如果设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代。对于年老代比较多的应用,可以提高效率。如果将此值设置为一个较大值,则年轻代对象会在Survivor区进行多次复制,这样可以增加对象在年轻代的存活时间,增加在年轻代即被回收的概率。



#### JDK1.8 永久代

- 1.8之前32位机器默认永久代大小为64M，64位机器默认永久代大小为85M。永久代的垃圾回收和老年代的垃圾回收是绑定的，一旦其中一个区域的被占满，两个区都需要进行垃圾回收。存在的问题：1. 一旦类的元数据（描述数据的数据，对数据及信息资源的描述性信息。）超过设定的永久代大小，程序就会耗尽内存，并出现OOM。2. 元数据信息会随着每一次 Full GC 发生移动。3. 永久代的空间大小很难确定，类的总数、常量池的大小、方法的总数。
- 1.8取消永久代，将类的元数据信息移到了一个与堆不相连的本地内存区域（元空间）。
- 影响：
  - 将类的元数据分配在本地内存中，元空间的最大可分配空间就是系统的可用内存空间。
  - JVM可以自动根据类的元数据大小动态增加元空间的容量。



### Java 内存划分

#### 运行时数据区

##### 程序计数器（线程私有）

在JVM规范中规定，如果线程执行的是非native方法，则程序计数器中保存的是当前需要执行的指令的地址；如果线程执行的是native方法，则程序计数器中的值是undefined。

由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，因此，对于程序计数器是不会发生内存溢出现象(OutOfMemory)的。该内存区域是唯一一个java虚拟机规范没有规定任何OOM情况的区域。

##### Java 虚拟机栈（线程私有）

Java栈中存放的是一个个的栈帧，每个栈帧对应一个被调用的方法，在栈帧中包括局部变量表(Local Variables)、操作数栈(Operand Stack)、指向当前方法所属的类的运行时常量池的引用(Reference to runtime constant pool)、方法返回地址(Return Address)和一些额外的附加信息。

![img](https://mubu.com/document_image/c7c5e0cd-e108-4b46-bd92-7a53a2655d58-983181.jpg)

当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。因此可知，线程当前执行的方法所对应的栈帧必定位于Java栈的顶部。

生命周期与线程相同。

**栈帧**

- 局部变量表里存储的是基本数据类型、returnAddress类型(指向一条字节码指令的地址)和对象引用,这个对象引用有可能是指向对象起始地址的一个指针,也有可能是代表对象的句柄或者与对象相关联的位置。局部变量所需的内存空间在编译期间确定的。
- 操作数栈的作用主要用来存储运算结果以及运算的操作数,它不同于局部变量表通过索引来访问,而是压栈和出栈的方式
- 每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用,持有这个引用是为了支持方法调用过程中的动态链接。动态链接就是将常量池中的符号引用在运行期转化为直接引用。

##### 本地方法栈（线程私有）

本地方法栈与Java栈的作用和原理非常相似。区别只不过是Java栈是为执行Java方法服务的，而本地方法栈则是为执行本地方法（Native Method）服务的。

##### 堆（线程共享）

用来存储对象本身的以及数组。

堆也是Java垃圾收集器管理的主要区域。

##### 方法区（线程共享）

存储了每个**类的信息**（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。

有时候也称为永久代，在该区内很少发生垃圾回收，但是并不代表不发生GC，在这里进行的GC主要是对方法区里的常量池和对类的卸载。

在方法区中有一个非常重要的部分就是运行时常量池，它是每一个类或接口的常量池的运行时表示形式，在类和接口被加载到 JVM 后，对应的运行时常量池就被创建出来。当然并非 Class 文件常量池中的内容才能进入运行时常量池，在运行期间也可将新的常量放入运行时常量池中，比如 String 的 intern() 方法。



### 内存溢出与内存泄漏

#### 内存溢出 out of memory

程序申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储 int 类型数据的存储空间，但是你却存储 long 类型的数据，那么结果就是内存不够用。

#### 内存泄漏 memory leak 

程序在申请内存后，无法释放已申请的内存空间，一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。 

**存在情况**

- 静态集合类

  如静态的HashMap、LinkedList等。长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收。

- 各种连接

  如数据库连接、网络连接和IO连接等。在对数据库进行操作的过程中，首先需要建立与数据库的连接，当不再使用时，需要调用close方法来释放与数据库的连接。只有连接被关闭后，垃圾回收器才会回收对应的对象。若没有显式关闭，则会造成内存泄漏。

- 变量不合理的作用域

  一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏。另一方面，如果没有及时地把对象设置为null，很有可能导致内存泄漏的发生。

- 内部类持有外部类

  当内部类被长期引用时，由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。

- 改变哈希值

  当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了（需重写 hashCode 方法），否则，对象修改后的哈希值与最初存储进 HashSet 集合中时的哈希值就不同了，在这种情况下，即使在 contains 方法使用该对象的当前引用作为的参数去 HashSet 集合中检索对象，也将返回找不到对象的结果，这也会导致无法从 HashSet 集合中单独删除当前对象，造成内存泄露。





参考博客：

https://www.cnblogs.com/dingyingsi/p/3760447.html