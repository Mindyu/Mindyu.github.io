---
title: 浅析素数环问题
date: 2018-03-18 11:51:06
tags: [数据结构,素数环问题,3*3素数表格]
categories: [算法分析]
---

## 素数环的实现
**问题描述**
 从1到n这n个整数围成一个圆环，若其中任意2个相邻的数字相加，结果均为素数，那么这个环就成为素数环。
  现在要求输入一个n，求n个数围成一圈有多少种素数环，规定第一个数字是1。<!--more-->
  
 **设计思路**
  1.数据结构：res数组用于保存最后满足描述的情况，isUsed数组用于标记1-n这些数字是否被使用，已达到不重复的效果。
  2.规定第一个数字为1，res[0] = 1;
  3.依次后面的值有两个限制 a.不能和前面的数字重复 b.和前一个数字相加为素数。
  
 
  
**代码实现**
``` java
import java.util.Scanner;

public class Main {
	
	final static int max = 20;
	static int N;
	static int[] res = new int[max];
	static boolean[] isUsed = new boolean[max];
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int k = 1;
		for (int i = 0; i < isUsed.length; i++) {
			res[i] = i+1;
			isUsed[i] = false;
		}
		N = sc.nextInt();
		while(N!=0){
			System.out.println("Case "+ k++ +":");
			if (N%2==0) {
				primeRing(1);
			}else {
				System.out.println("No Answer");
			}
			N = sc.nextInt();
		}
		
		sc.close();
	}

	// 递归实现，输出素数环
	public static void primeRing(int cur){          
		if (cur==N && isPrime(res[cur-1]+res[0])) {   // 执行完成，并且首尾相加也是素数
			for (int i = 0; i < N-1; i++) {
				System.out.print(res[i]+" ");
			}System.out.print(res[N-1]);
			System.out.println();
			return;
		}else {
			for (int i = 2; i <= N; i++) {		      // 选取一个满足条件的值，继续递归
				if (!isUsed[i] && isPrime(i+res[cur-1])) {
					res[cur] = i;
					isUsed[i] = true;
					primeRing(cur+1);
					isUsed[i] = false;
				}
			}
		}
	}
	
	// 判断是否为素数
	public static boolean isPrime(int x) {
		if (x<3) {    // 两数相加必定大于2，所以小于3的值不用考虑
			return false;
		}else {
			for (int i = 2; i <= Math.sqrt(x); i++) {
				if (x%i==0) {
					return false;
				}
			}
		}
		return true;
	}
}

```

**运行结果**
![素数环][1]


## 素数表格
**问题描述**
 前两天遇到一个问题和素数有关，从1到n中选择9个数字，填入3*3的表格中，使得相邻的数字相加和为素数。输出所有的情况。
 
 **设计思路**
 在CSDN上面看到过一片关于这个问题的博客。[相邻两方格内的两个整数之和为质数-经典算法详解][2]。理解起来可能还要一时半会儿。但是我觉得有了上述素数环的理解以及实现，只需要稍微修改一下上面的代码就可以达到表格的要求。
 1.将3*3二维表格转换为一维数组。以下表格的数值代表数组中的位置。

| 0   | 1   | 2   |
| --- | --- | --- | --- |
| 7   | 8   | 3   |
| 6   | 5   | 4   |

2.问题可以简化为数组0-7下标组成一个素数环。然后数组res[8]同时与res[1]、res[3]、res[5]、res[7]分别相加合为素数。

**代码实现**

``` java
import java.util.Scanner;

public class Main {
	
	final static int max = 20;
	static int N;
	static int[] res = new int[max];
	static boolean[] isUsed = new boolean[max];
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		for (int i = 0; i < isUsed.length; i++) {
			res[i] = i+1;
			isUsed[i] = false;
		}
		N = sc.nextInt();
		primeRing(1);
		sc.close();
	}

	// 递归实现，输出素数环
	public static void primeRing(int cur){          
		if (cur==8 && isPrime(res[cur-1]+res[0])) {   // res[0]+res[7]和也为素数
			for (int i = 2; i <= N; i++) {		      // 选取最后一个满足条件的值，填入res[8]位置
				if (!isUsed[i] && isPrime(i+res[1]) && isPrime(i+res[3]) && isPrime(i+res[5]) && isPrime(i+res[7])) {
					for (int j = 0; j < 3; j++)       // 输出第一行
						System.out.print(res[j]+" ");
					System.out.println();
					System.out.print(res[7]+" ");	  // 输出第二行
					System.out.print(i+" ");
					System.out.print(res[3]+" ");
					System.out.println();
					for (int j = 6; j > 3; j--) 	  // 输出第三行
						System.out.print(res[j]+" ");
					System.out.println();
					System.out.println();
				}
			}
			return;
		}else if(cur<8){							  // 数组0-7下标组成一个素数环
			for (int i = 2; i <= N; i++) {		      // 选取一个满足条件的值，继续递归
				if (!isUsed[i] && isPrime(i+res[cur-1])) {
					res[cur] = i;
					isUsed[i] = true;
					primeRing(cur+1);
					isUsed[i] = false;
				}
			}
		}
	}
	
	// 判断是否为素数
	public static boolean isPrime(int x) {
		if (x<3) {    // 两数相加必定大于2，所以小于3的值不用考虑
			return false;
		}else {
			for (int i = 2; i <= Math.sqrt(x); i++) {
				if (x%i==0) {
					return false;
				}
			}
		}
		return true;
	}
}

```

**运行截图**
![3*3表格素数][3]
 


  [1]: http://hexoblog-1253306922.cosgz.myqcloud.com/photo2018/%E7%B4%A0%E6%95%B0%E7%8E%AF.png
  [2]: http://blog.csdn.net/yinxusen/article/details/6281687
  [3]: http://hexoblog-1253306922.cosgz.myqcloud.com/photo2018/%E7%B4%A0%E6%95%B0%E8%A1%A8%E6%A0%BC.png