<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[品优购项目笔记（上）]]></title>
    <url>%2F2018%2F12%2F19%2F%E5%93%81%E4%BC%98%E8%B4%AD%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[品牌管理模块功能实现 运用AngularJS前端框架的常用指令 完成品牌管理的列表功能 完成品牌管理的分页列表功能 完成品牌管理的增加功能 完成品牌管理的修改功能 完成品牌管理的删除功能 完成品牌管理的条件查询功能 前端框架 AngularJS四大特征 MVC 模式 Model: 数据,其实就是angular变量($scope.XX); View: 数据的呈现,Html+Directive(指令); Controller: 操作数据,就是function,数据的增删改查; 双向绑定框架采用并扩展了传统HTML，通过双向的数据绑定来适应动态内容，双向的数据绑定允许模型和视图之间的自动同步。遵循声明式编程应该用于构建用户界面以及编写软件构建，而指令式编程非常适合来表示业务逻辑的理念。 依赖注入对象在创建的时候，其依赖对象由框架来自动创建并注入进来。即最少知道法则。 模块化设计 高内聚低耦合法则1)官方提供的模块 ng、ngRoute、ngAnimate2)用户自定义的模块 angular.module(‘模块名’,[ ]) 常见指令 ng-app 定义 AngularJS 应用程序的根元素，表示以下的指令 angularJS 都会识别，且在页面加载完时会自动初始化。 ng-model 指令用于绑定变量,将用户在文本框输入的内容绑定到变量上，而表达式可以实时地输出变量。 ng-init 对变量初始化或调用某方法。 ng-controller 用于指定所使用的控制器，在控制器中定义函数和变量，通过scope 对象来访问。 ng-click 单击事件指令，点击时触发控制器的某个方法。 ng-if 判断语句，条件不存在就不执行。 ng-repeat 指令用于循环集合变量。 $index 用于获取 ng-repeat 指令循环中的索引。 $http 内置服务，用于访问后端数据。 $location 服务，用于获取链接地址中的参数值。$location.search()[&#39;id&#39;]id对应的值。(注：地址中 ? 前需要添加 # ) eg: http://localhost:9102/admin/goods_edit.html#?id=149187842867969 ng-bind-html 指令用于显示 html 内容 app.filter 过滤器，通过 | 来调用过滤器 $sce 服务 严格控制上下文访问，为防止 跨站XSS。该服务可以实现安全控制，比如允许html标签的插入转换。 复选框的使用 ​ 定义一个用于存储选中 ID 的数组，当我们点击复选框后判断是选择还是取消选择，如果是选择就加到数组中，如果是取消选择就从数组中移除。在后续点击删除按钮时需要用到这个存储了 ID 的数组。 12345678910// 存储当前选中复选框的id集合$scope.selectIds = [];$scope.updateSelection = function($event, id)&#123; if ($event.target.checked) &#123; // 当前为勾选状态 $scope.selectIds.push(id); // 向selectIds集合中添加元素 &#125; else &#123; var index = $scope.selectIds.indexOf(id); $scope.selectIds.splice(index, 1); // 参数1：移除的下标位置，参数2：需要移除的元素个数 &#125;&#125; 规格及模板管理前端分层开发 ​ 运用 MVC 的思想，将 js 和 html 代码分离，提高程序的可维护性。 ​ 实现方式：自定义服务，同后端的 service 层，封装一些操作，比如请求后端数据。在不同控制器通过依赖注入相关服务，即可调用服务的方法。将代码分为前端页面、前端服务层、前端控制层。 主键回填 ​ 修改 Mapper.xml 文件 123&lt;selectKey resultType="java.lang.Long" order="AFTER" keyProperty="id"&gt; SELECT LAST_INSERT_ID() AS id&lt;/selectKey&gt; ​ 对于规格与具体规格选项，可以创建一个组合实体类，包括 规格 和 规格选项的集合。在插入规格之后，通过主键回填，获取规格 ID ，然后将 ID 作为外键添加到规格选项中去。 select2 组件-多选下拉列表 引入 select 2 相关的 js 和 css。 设置数据源 1$scope.brandList=&#123;data:[&#123;id:1,text:'联想'&#125;,&#123;id:2,text:'华为'&#125;,&#123;id:3,text:'小米'&#125;]&#125;; // 品牌列表 实现多选下拉框 1&lt;input select2 select2-model="entity.brandIds" config="brandList" multiple placeholder=" 选择品牌（可多选）" class="form-control" type="text"/&gt; multiple 表示可多选 Config 用于配置数据来源 select2-model 用于指定用户选择后提交的变量![select2多选下拉列表](https://hexoblog-1253306922.cos.ap-guangzhou.myqcloud.com/photo2018/%E5%93%81%E4%BC%98%E8%B4%AD/%E5%A4%9A%E9%80%89%E4%B8%8B%E6%8B%89%E6%A1%86.png) 模板列表显示 ​ 将从后台获取的 json 字符串中的某个属性的值提取出来，用逗号分隔，更直观的显示。 12345678910// 提取 json 字符串数据中某个属性，返回拼接字符串逗号分隔$scope.jsonToString = function(jsonString,key)&#123; var json=JSON.parse(jsonString); // 将 json 字符串转换为 json 对象 var value=""; for(var i=0;i&lt;json.length;i++)&#123; if(i&gt;0) value += ","； value += json[i][key]; &#125; return value;&#125; Spring Security 安全框架​ 为基于 Spring 的企业应用系统提供声明式的安全访问控制的解决方案。提供一组可以在 Spring 应用上下文中配置的 Bean。 使用步骤 引入 jar 包 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-web&lt;/artifactId&gt; &lt;version&gt;4.1.0.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt; &lt;version&gt;4.1.0.RELEASE&lt;/version&gt;&lt;/dependency&gt; web.xml 文件中引入 spring-security.xml 配置文件 123456789101112131415161718&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/spring-security.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt; &lt;/listener&gt; &lt;filter&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; spring-security.xml 配置文件设置页面拦截规则、认证管理器以及不拦截的资源（静态资源、登陆页面） 1234567891011121314151617181920212223242526272829&lt;!-- 设置页面不登陆也可以访问 --&gt;&lt;http pattern="/*.html" security="none"&gt;&lt;/http&gt;&lt;http pattern="/css/**" security="none"&gt;&lt;/http&gt;&lt;http pattern="/img/**" security="none"&gt;&lt;/http&gt;&lt;http pattern="/js/**" security="none"&gt;&lt;/http&gt;&lt;http pattern="/plugins/**" security="none"&gt;&lt;/http&gt;&lt;!-- 页面的拦截规则 use-expressions:是否启动SPEL表达式 默认是true --&gt;&lt;http use-expressions="false"&gt; &lt;!-- 当前用户必须有ROLE_USER的角色 才可以访问根目录及所属子目录的资源 --&gt; &lt;intercept-url pattern="/**" access="ROLE_ADMIN"/&gt; &lt;!-- 开启表单登陆功能 --&gt; &lt;form-login login-page="/login.html" default-target-url="/admin/index.html" authentication-failure-url="/login.html" always-use-default-target="true"/&gt; &lt;csrf disabled="true"/&gt; &lt;headers&gt; &lt;frame-options policy="SAMEORIGIN"/&gt; &lt;/headers&gt; &lt;logout/&gt; &lt;!-- 退出登录 --&gt;&lt;/http&gt;&lt;!-- 认证管理器 --&gt;&lt;authentication-manager&gt; &lt;authentication-provider&gt; &lt;user-service&gt; &lt;user name="admin" password="123456" authorities="ROLE_ADMIN"/&gt; &lt;user name="yang" password="123456" authorities="ROLE_ADMIN"/&gt; &lt;/user-service&gt; &lt;/authentication-provider&gt; &lt;/authentication-manager&gt; ​ CSRF（Cross-site request forgery）跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。 ​ XSS(跨站脚本攻击)利用站点内的信任用户，往Web页面里插入恶意Script代码 。 ​ CSRF通过伪装来自受信任用户的请求来利用受信任的网站。 商家系统登录安全控制安全控制 自定义认证类，创建类 UserDetailsServiceImpl.java 实现 UserDetailsService 接口 实现类中添加 SellerService 属性、和 setter 注入方法，修改 loadUserByUserName 方法。 配置 spring-security.xml。认证管理器中 authentication-provider 引用userDetailService 的bean，同时通过 dobbo 去依赖一个 sellerService 对象。 BCrypt 加密算法 ​ 用户表的密码通常使用 MD5 等不可逆算法加密后存储，为防止彩虹表破解更会先使用一个特定的字符串（如域名）加密，然后再使用一个随机的 salt（盐值）加密。 特定字符串是程序代码中固定的，salt 是每个密码单独随机，一般给用户表加一个字段单独存储，比较麻烦。 BCrypt 算法将 salt 随机并混入最终加密后的密码，验证时也无需单独提供之前的 salt，从而无需单独处理 salt 问题。 123456789101112131415161718192021222324252627282930/** * 认证类 * @author YCQ * */public class UserDetailsServiceImpl implements UserDetailsService&#123; private SellerService sellerService; public void setSellerService(SellerService sellerService) &#123; // 通过配置的方式添加 this.sellerService = sellerService; &#125; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;// System.out.println("执行 UserDetailsServiceImpl 认证"); // 构建角色列表 List&lt;GrantedAuthority&gt; grantAuths = new ArrayList&lt;&gt;(); grantAuths.add(new SimpleGrantedAuthority("ROLE_SELLER")); TbSeller seller = sellerService.findOne(username); if (seller!=null &amp;&amp; "1".equals(seller.getStatus())) &#123; return new User(username, seller.getPassword(), grantAuths); &#125;else &#123; return null; &#125; &#125;&#125; spring-security 配置 123456789101112131415161718&lt;!-- 认证管理器 --&gt;&lt;authentication-manager&gt; &lt;authentication-provider user-service-ref="userDetailService"&gt; &lt;password-encoder ref="bcryptEncoder"&gt;&lt;/password-encoder&gt; &lt;/authentication-provider&gt; &lt;/authentication-manager&gt;&lt;!-- 认证类 --&gt;&lt;beans:bean id="userDetailService" class="com.pinyougou.service.UserDetailsServiceImpl"&gt; &lt;beans:property name="sellerService" ref="mSellerService"&gt;&lt;/beans:property&gt;&lt;/beans:bean&gt;&lt;!-- 引用dubbo 服务 --&gt;&lt;dubbo:application name="pinyougou-shop-web" /&gt;&lt;dubbo:registry address="zookeeper://107.191.52.91:2181"/&gt;&lt;dubbo:reference id="mSellerService" interface="com.pinyougou.sellergoods.service.SellerService"&gt;&lt;/dubbo:reference&gt;&lt;beans:bean id="bcryptEncoder" class="org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder"&gt;&lt;/beans:bean&gt; 注：浏览器控制台提示 [DOM] Input elements should have autocomplete attributes (suggested: “current-password”) 为浏览器表单默认的记忆功能，可以在 input 标签中添加 autocomplete=”off|on” 即可。 商品分类管理多级分类列表 ​ 将商品分类分为三级，进入页面首先显示所有一级分类（主分类），点击查询下级，可查看当前主分类下的次分类，再次点击进入三级分类。三级分类为最后一级，列表中不显示查询下级按钮，同时更新面包屑导航。直接点击面包屑导航，可以实现直接层级跳转。 面包屑导航 123456789101112131415161718// 当前面包屑等级$scope.grade = 1;$scope.setGrade=function(value)&#123; $scope.grade = value;&#125;$scope.selectList=function(p_entity)&#123; if ($scope.grade == 1) &#123; $scope.entity_1 = null; $scope.entity_2 = null; &#125; else if ($scope.grade == 2)&#123; $scope.entity_1 = p_entity; $scope.entity_2 = null; &#125; else &#123; $scope.entity_2 = p_entity; &#125; $scope.findByParentId(p_entity.id);&#125; 页面配置 123&lt;li&gt;&lt;a href="#" ng-click="grade=1;selectList(&#123;id:0&#125;)"&gt;顶级分类列表&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#" ng-click="grade=2;selectList(entity_1)"&gt;&#123;&#123;entity_1.name&#125;&#125;&lt;/a&gt;&lt;/li&gt;&lt;li ng-if="entity_2!=null"&gt;&lt;a href="#" ng-click="grade=3;selectList(entity_2)"&gt;&#123;&#123;entity_2.name&#125;&#125;&lt;/a&gt;&lt;/li&gt; 修改商品分类 ​ 实现类型模板的下拉框，采用 select2 组件实现。 123&lt;td&gt;类型模板&lt;/td&gt;&lt;td&gt;&lt;input select2 ng-model="entity.typeId" config="itemList" placeholder="商品类型模板" class="form-control" type="text"/&gt;&lt;/td&gt; ​ config 为数据来源 ​ ng-model 绑定类型对象数据 ​ itemList 的来源：itemCatController 中 findItemList() 方法 -&gt; typeTemplateService 的 selectOptionList() 方法 -&gt; 请求后端 /typeTemplate/selectOptionList -&gt; TypeTemplateService 服务层 -&gt; TypeTemplateMapper 层方法 删除商品分类 ​ 判断所选分类下是否存在子分类，存在则不能删除。 123456789101112131415161718192021222324/** * 批量删除 * @param ids * @return */@RequestMapping("/delete")public Result delete(Long[] ids)&#123; try &#123; // 判断当前所有分类是否存在子分类 boolean flag = false; // 不存在 for (Long id : ids) &#123; if(itemCatService.findByParentId(id)!=null &amp;&amp; itemCatService.findByParentId(id).size()!=0)&#123; flag = true;break; &#125; &#125; if (flag) return new Result(false, "当前所选分类存在子分类，切勿删除"); itemCatService.delete(ids); return new Result(true, "删除成功"); &#125; catch (Exception e) &#123; e.printStackTrace(); return new Result(false, "删除失败"); &#125;&#125; SPU 与 SKU ​ SPU （标准产品单位）为商品信息聚合的最小单位是一组可复用、易检索的标准化信息的集合,该集合描述了一个产品的特性。属性相同、特性相同的商品为一个SPU。 ​ SKU （库存量单位） 为物理上不可分割的最小存货单元。不同的规格、颜色、款式为不同的SKU。 分布式文件服务器 FastDFS ​ FastDFS 是用 c 语言编写的一款开源的分布式文件系统。FastDFS 为互联网量身定制,充分考虑了冗余备份、负载均衡、线性扩容等机制,并注重高可用、高性能等指标,使用FastDFS 很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。 FastDFS 架构包括 Tracker server 和 Storage server。 Tracker server （追踪服务器、调度服务器）作用为负载均衡和调度。 Storage server （存储服务器）作用为文件存储。 客户端请求 Tracker server 进行文件上传、下载,通过 Tracker server 调度最终由 Storage server 完成文件上传和下载。 服务端角色： Tracker : 管理集群，tracker也可以实现集群，每一个节点地位平等，一种备份的机制。tracker负责收集 storage 集群的存储状态。 Stroage ：实际保存文件。分为多个组，组内文件相同，起到备份作用。组间文件不同，起到分布式存储。 商品分类级联刷新 ​ 通过 Angular JS 变量监控方法，实现选择一级分类之后，初始化二级分类的列表信息。 123456789101112// angularjs变量监控方法,查询二级分类信息$scope.$watch('entity.goods.category1Id',function(newValue, oldValue)&#123; if (newValue != undefined &amp;&amp; newValue != "") &#123; // alert("category1Id"+newValue); itemCatService.findByParentId(newValue).success( function(response)&#123; $scope.itemCat2List = response; $scope.entity.goods.category2Id = ""; &#125; ); &#125;&#125;); 商品录入【SKU商品信息】 对于同一个产品分为多种不同的规格组合。根据选择的规格录入商品的 SKU 信息，当用户选择相应的规格，下面的 SKU 列表就会自动生成。 实现思路：（1）我们先定义一个初始的不带规格名称的集合，只有一条记录。（2）循环用选择的规格，根据规格名称和已选择的规格选项对原集合进行扩充，添加规格名称和值，新增的记录数与选择的规格选项个数相同 12345678910111213141516171819202122232425262728293031323334// 创建SKU列表$scope.creatItemList=function()&#123; // 列表初始化，规格对象、价格、库存量、状态、是否默认 $scope.entity.itemList = [ &#123;spec:&#123;&#125;,price:0,num:9999,status:'0',isDefault:'0'&#125; ]; var items = $scope.entity.goodsDesc.specificationItems; for (var i = 0; i &lt; items.length; i++) &#123; $scope.entity.itemList = addColumn($scope.entity.itemList, items[i].attributeName, items[i].attributeValue); &#125;&#125;/** * $scope.entity.itemList: * [&#123;"spec":&#123;"网络":"移动3G","机身内存":"16G"&#125;,"price":0,"num":9999,"status":"0","isDefault":"0"&#125;, * &#123;"spec":&#123;"网络":"移动3G","机身内存":"32G"&#125;,"price":0,"num":9999,"status":"0","isDefault":"0"&#125;, * &#123;"spec":&#123;"网络":"联通3G","机身内存":"16G"&#125;,"price":0,"num":9999,"status":"0","isDefault":"0"&#125;, * &#123;"spec":&#123;"网络":"联通3G","机身内存":"32G"&#125;,"price":0,"num":9999,"status":"0","isDefault":"0"&#125;] */// 深克隆方法 原集合、列名、列值addColumn=function(list, columnName, columnValues)&#123; var newList = []; for (var i = 0; i &lt; list.length; i++) &#123; var oldRow = list[i]; for (var j = 0; j &lt; columnValues.length; j++) &#123; var newRow = JSON.parse( JSON.stringify(oldRow) ); newRow.spec[columnName] = columnValues[j]; newList.push(newRow); &#125; &#125; return newList;&#125; 商家后台列表显示 状态显示： ​ 商品信息表（goods）中状态子段为 audit_status 。存储的为数字，0表示未审核、1表示已审核、2表示审核未通过、3为已关闭。从后台获取的状态值，直接在前端进行修改。通过一个status数组存储： ​ $scope.status=[‘未审核’,’已审核’,’审核未通过’,’关闭’];//商品状态 ​ 然后列表中显示为 。 分类信息显示： ​ 商品分为三级分类。存储于 tb_item_cat 表中。包括 id、父级id、分类名称、对应绑定的类型id。但是为了避免商品查询时重复的关联查询，可以采用现将所有分类信息读取到本地，然后在前端进行分类id到分类名称的转换操作。 1234567891011$scope.itemCatList = [];// 全部商品分类查询，存储在itemList数组中，然后再前端页面通过数组下标直接将商品分类ID转换为商品分类名称，避免后端连接查询。$scope.findItemList = function()&#123; itemCatService.findAll().success( function(response)&#123; for (var i = 0; i &lt; response.length; i++) &#123; $scope.itemCatList[response[i].id] = response[i].name; &#125; &#125; );&#125; ​ 将分类结果 response 对象封装为数组类型，数组下标为商品分类id，数组值为商品分类的名称。然后在列表项中通过 将id转换为名称。 存在的问题 ​ pinyougou-shop-web 模块中分页插件提示 ClassNotFoundException。但是页面可以访问。 12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;$&#123;pagehelper.version&#125;&lt;/version&gt;&lt;/dependency&gt; ​ 如上配置之后，又出现下图错误，导致商品列表无法显示。（但是 manager-web 模块中也没有引入pagehelper,但是没有出现问题） 商品删除 ​ 逻辑删除，通过修改数据库表中的 is_delete 字段为1，然后过滤掉商品。然后查询时，在 findPage() 方法中添加 criteria.andIsDeleteIsNull() 条件。 注解式事务配置 ​ 创建 applicationContext-tx.xml 配置文件 1234567&lt;!-- 事务管理器 --&gt;&lt;bean id="transactionManager"class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt;&lt;/bean&gt;&lt;!-- 开启事务控制的注解支持 --&gt;&lt;tx:annotation-driven transaction-manager="transactionManager"/&gt; ​ 然后在方法或服务实现类上添加 @Transactional 注解。 网站前台广告服务 ​ 设计为广告分类表（id、name）与广告内容表（id、categoryId、title、url、pic、status、order）。广告有首页轮播广告、今日推荐、各品类楼层广告等分类。 ​ Redis 缓存数据库用于解决高访问量对后端数据库造成的很大的访问压力。（另一种解决方案为网页静态化） ​ Spring Data Redis 提供了在 srping 应用中通过简单的配置访问 redis 服务，对 reids 底层开发包(Jedis, JRedis, and RJC)进行了高度封装，RedisTemplate 提供了 redis 各种操作、异常处理及序列化，支持发布订阅，并对 spring 3.1 cache 进行了实现。 spring-data-redis 针对 jedis 提供了如下功能： 1.连接池自动管理，提供了一个高度封装的“RedisTemplate”类。 2.针对 jedis 客户端中大量 api 进行了归类封装,将同一类型操作封装为 operation 接口 操作样例： key-value 键值对操作 ​ 插入：redisTemplate.boundValueOps(“name”).set(“mindyu”); ​ 读取：redisTemplate.boundValueOps(“name”).get(); ​ 删除：redisTemplate.delete(“name”); Set 类型操作（无序集合） ​ 插入：redisTemplate.boundSetOps(“nameset”).add(“曹操”); ​ 读取：redisTemplate.boundSetOps(“nameset”).members(); ​ 删除：redisTemplate.boundSetOps(“nameset”).remove(“曹操”); // 单一元素 redisTemplate.delete(“name”); // 整个集合 List 集合 （有序） ​ rightPush() 、leftPush()、读取：range(0,10)、index(1)、remove(1, “value”) // 1 表示删除数据的个数 Hash 类型 ​ put(“key”,”value”)、读取所有键：keys()、读取所有值：values()、get(“key”)、delete(“key”) ​ 使用 Redis 缓存时，需要注意，当数据修改时需要清除缓存数据，使其达到一致性约束。必须修改广告时，如果修改了该广告所属的分类，那么需要同时清除原分类以及新分类的缓存信息。 出现的问题： ​ 首页在加载广告模块时，出现 “Failed to load resource: net::ERR_BLOCKED_BY_CLIENT” 错误，是因为谷歌浏览器的广告插件，导致无法加载该图片。 搜索解决方案简介 ​ Solr 是一个开源搜索平台，用于构建搜索应用程序。 它建立在 Lucene(全文搜索引擎)之上。 Solr 是企业级的，快速的和高度可扩展的。 使用 Solr 构建的应用程序非常复杂，可提供高性能。Solr 是一个可扩展的，可部署，搜索/存储引擎，优化搜索大量以文本为中心的数据。 安装及配置 安装 Tomcat，解压缩。 解压 solr。 把 solr 下的 dist 目录 solr-4.10.3.war 部署到 webapps 下(去掉版本号，方便访问)。 启动 Tomcat 解压缩 war 包 把solr下 example/lib/ext 目录下的所有的扩展 jar 包，添加到 solr 的工程中(\WEB-INF\lib目录下)。 创建一个 solrhome 。solr 下的 /example/solr 目录就是一个 solrhome。复制此目录到 D 盘改名为 solrhome 关联 solr 及 solrhome。需要修改 solr 工程的 web.xml 文件。 12345&lt;env-entry&gt; &lt;env-entry-name&gt;solr/home&lt;/env-entry-name&gt; &lt;env-entry-value&gt;d:\solrhome&lt;/env-entry-value&gt; &lt;env-entry-type&gt;java.lang.String&lt;/env-entry-type&gt;&lt;/env-entry&gt; 启动 Tomcat 。访问 http://localhost:8080/solr 即可 中文分析器 IK Analyzer ​ IK Analyzer 是一个开源的，基于 java 语言开发的轻量级的中文分词工具包。 配置 把 IKAnalyzer2012FF_u1.jar 添加到 solr 工程的 lib 目录下 solr 工程下创建 WEB-INF/classes 文件夹，用于存放扩展词典、停用词词典、配置文件。 修改 Solrhome 中的 schema.xml 文件，配置一个 FieldType，使用 IKAnalyzer 123&lt;fieldType name="text_ik" class="solr.TextField"&gt; &lt;analyzer class="org.wltea.analyzer.lucene.IKAnalyzer"/&gt;&lt;/fieldType&gt; 配置域 ​ 域相当于数据库的表字段，用户存放数据，用户可根据业务需要去定义相关的 Field（域），一般来说，每一种域对应着一种数据，用户对同一种数据进行相同的操作。域的常用属性： name 域的名称 type 域的类型 indexed 是否索引 stored 是否存储 required 是否必须 multiValued 是否多值 复制域： ​ 将某一个域中的数据复制到另一个域中。比如商品查询时，同样一个关键字可能是品牌、商品标题、商品分类、商家名称等多种可能。此时就需要复制域。 动态域： ​ 对于字段名称不固定的情况下，用于动态扩充字段。比如商品的规格的值不是固定的（不同商品可能存在不同的规格项）。 出现的错误 前端可以从后台获取数据（ itemsearch/search.do正常获取数据 ），但是控制台显示” TypeError: Cannot read property ‘success’ of undefined “错误。 原因是因为： 12345app.service('searchService', function($http)&#123; this.search=function(searchMap)&#123; return $http.post('itemsearch/search.do',searchMap); &#125;&#125;); angularjs 服务层的search方法并未 return。 12. 服务启动超时：com.alibaba.dubbo.remoting.TimeoutException: Waiting server-side response timeout. start time: 2018-12-02 08:35:41.093, end time: 2018-12-02 08:35:46.094, client elapsed: 0 ms, server elapsed: 5001 ms, timeout: 5000 ms。 网站前台 portal-web 模块出现的原因是因为没有启动 redis 服务器。然后前台广告数据获取不到。 搜索模块 search-web ：就很奇怪，dubbox 服务正常、solr 服务正常。昨天晚上还是正常的，上午纠结了半天，然后不知道为啥突然又好了。。。 烦躁 批量数据导入 solr 系统 ​ 将商品数据导入到 solr 系统。 创建 solr-util (jar)，引入 dao 模块以及 spring 相关依赖。 创建spring 的配置文件，添加包扫描。 依赖 pojo 模块，为实体类添加 @Field 注解。 pojo 中引入 spring-data-solr 依赖（会自动引入其所依赖solr包）动态域中@Dynamic 注解是该包提供的 添加 solr.xml 配置文件与 spring 目录中。 123456&lt;!-- solr 服务器地址 --&gt;&lt;solr:solr-server id="solrServer" url="http://127.0.0.1:8080/solr" /&gt;&lt;!-- solr 模板，使用 solr 模板可对索引库进行 CRUD 的操作 --&gt;&lt;bean id="solrTemplate" class="org.springframework.data.solr.core.SolrTemplate"&gt; &lt;constructor-arg ref="solrServer" /&gt;&lt;bean&gt; 通过 spring 注入 SolrTemplate 模板类对象。 使用 SolrTemplate 对象执行相应的方法。 关键字搜索模块 ​ 通过注入 SolrTemplate 对象，使用该对象实现关键字搜索。 123456789101112131415161718192021@Service(timeout=5000) // 超时5S，默认是1Spublic class ItemSearchServiceImpl implements ItemSearchService&#123; @Autowired private SolrTemplate solrTemplate; @Override public Map search(Map searchMap) &#123; Map map = new HashMap(); Query query = new SimpleQuery("*:*"); Criteria criteria = new Criteria("item_keywords").is(searchMap.get("keywords")); query.addCriteria(criteria); ScoredPage&lt;TbItem&gt; page = solrTemplate.queryForPage(query, TbItem.class); map.put("rows", page.getContent()); // page.getContent() 返回一个 List 集合 return map; &#125;&#125; 搜索结果高亮显示 ​ 将搜索关键字在搜索结果中，高亮显示出来。实现原理也就是在关键字前后添加html标签：关键字 ​ 后端实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Overridepublic Map search(Map searchMap) &#123; Map map = new HashMap(); /* Query query = new SimpleQuery("*:*"); Criteria criteria = new Criteria("item_keywords").is(searchMap.get("keywords")); query.addCriteria(criteria); ScoredPage&lt;TbItem&gt; page = solrTemplate.queryForPage(query, TbItem.class); map.put("rows", page.getContent()); // page.getContent() 返回一个 List 集合 */ // 高亮显示 HighlightQuery query = new SimpleHighlightQuery(); // 构建高亮选项 HighlightOptions highlightOptions = new HighlightOptions().addField("item_title"); // 高亮域（可以为多个） highlightOptions.setSimplePrefix("&lt;em style='color:red'&gt;"); // 前缀 highlightOptions.setSimplePostfix("&lt;/em&gt;"); // 后缀 query.setHighlightOptions(highlightOptions); // 为查询设置高亮查询 Criteria criteria = new Criteria("item_keywords").is(searchMap.get("keywords")); query.addCriteria(criteria); HighlightPage&lt;TbItem&gt; page = solrTemplate.queryForHighlightPage(query, TbItem.class); // 高亮入口集合（每条高亮结果的入口） List&lt;HighlightEntry&lt;TbItem&gt;&gt; entryList = page.getHighlighted(); for (HighlightEntry&lt;TbItem&gt; entry : entryList) &#123; // 获取高亮列表（高亮域的个数） List&lt;Highlight&gt; hightLightList = entry.getHighlights(); /* for (Highlight highLight : hightLightList) &#123; // 每个域可能存在多值（复制域） List&lt;String&gt; sns = highLight.getSnipplets(); System.out.println(sns); &#125;*/ if (entry.getHighlights().size()&gt;0 &amp;&amp; entry.getHighlights().get(0).getSnipplets().size()&gt;0) &#123; TbItem item = entry.getEntity(); item.setTitle(entry.getHighlights().get(0).getSnipplets().get(0)); // 用高亮标签结果替换 &#125; &#125; map.put("rows", page.getContent()); return map;&#125; ​ 前端实现： angularJS 会将后端插入的html标签原样输出，而不会去解析。这是防止html攻击采取的一种安全策略。可以使用 $sce 服务的 trustAsHtml 方法来实现转换。 12345678// 定义过滤器app.filter('trustHtml', ['$sce', function($sce)&#123; return function(data)&#123; // 传入参数时，被过滤的内容 return $sce.trustAsHtml(data); // 返回的是过滤后的内容（信任html的转换） &#125; &#125; ]); 然后在页面通过 &lt;div class=&quot;attr&quot; ng-bind-html=&quot;item.title | trustHtml&quot;&gt;&lt;/div&gt;来调用转换方法。 搜索业务规则搜索模块 用户输入搜索关键字，显示列表结果和商品分类信息。因为一个关键字可能对应多种商品分类 根据第一个商品分类，默认查询该分类的模板ID，然后根据模板ID查询品牌列表和规格列表 当用户点击某一个商品分类时，则显示该分类对应商品结果，同时根据该分类的模板ID查询对应的品牌列表和规格列表 当用户点击商品品牌列表时，筛选出当前所选的品牌商品信息 当用户点击商品规格列表时，筛选出当前所选的规格所对应的商品信息 用户点击价格区间时，商品信息根据价格进行过滤 用户点击搜索面板上的条件时，隐藏该条件 系统搜索量很大，所以需要将搜索信息放置到 Redis 缓存数据库中。 缓存商品分类信息 12345678private void saveToRedis() &#123; // 将模板ID放入缓存 分类名称作为key,模板ID作为value List&lt;TbItemCat&gt; itemCatList = findAll(); for (TbItemCat itemCat : itemCatList) &#123; redisTemplate.boundHashOps("itemCat").put(itemCat.getName(), itemCat.getTypeId()); &#125; System.out.println("将模板ID放入缓存");&#125; 缓存所有的品牌信息和规格信息 12345678910111213141516private void saveToRedis() &#123; List&lt;TbTypeTemplate&gt; typeTempList = findAll(); for(TbTypeTemplate template : typeTempList) &#123; Long id = template.getId(); // 将模板ID作为key 品牌列表作为value List brandList = JSON.parseArray(template.getBrandIds(), Map.class); // &#123;id:1,text:联想&#125; redisTemplate.boundHashOps("brandList").put(id, brandList); // 将模板ID作为key 规格列表作为value List&lt;Map&gt; specList = findSpecList(id); redisTemplate.boundHashOps("specList").put(id, specList); &#125; System.out.println("完成品牌列表、规格列表缓存");&#125; 分类列表查询（spring data solr 条件查询） 12345678910111213141516171819202122232425private List&lt;String&gt; searchCategoryList(Map searchMap) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); Query query = new SimpleQuery("*:*"); // 根据关键字查询 Criteria criteria = new Criteria("item_keywords").is(searchMap.get("keywords")); // where ... query.addCriteria(criteria); // 设置分组选项 GroupOptions groupOptions = new GroupOptions().addGroupByField("item_category"); // group by ....（可以有多个分组域） query.setGroupOptions(groupOptions); // 获取分组页 GroupPage&lt;TbItem&gt; queryForGroupPage = solrTemplate.queryForGroupPage(query, TbItem.class); // 获取分组结果对象 GroupResult&lt;TbItem&gt; groupResult = queryForGroupPage.getGroupResult("item_category"); // 获取分组入口页 Page&lt;GroupEntry&lt;TbItem&gt;&gt; groupEntries = groupResult.getGroupEntries(); // 遍历获取每个对象的值 for(GroupEntry&lt;TbItem&gt; entry : groupEntries) &#123; list.add(entry.getGroupValue()); &#125; return list;&#125; 过滤条件的构建 ​ 当点击搜索面板的分类、品牌和规格时，实现查询条件的构建。查询 条件以面包屑的形式显示。当面包屑显示分类、品牌和规格时，要同时隐藏搜索面板对应的区域。点击面包屑查询条件的撤销链接时，重新显示搜索面板相应的区域。 ​ 面包屑其实就是显示搜索对象。可将搜索对象定义为$scope.searchMap={&#39;keywords&#39;:&#39;&#39;,&#39;category&#39;:&#39;&#39;,&#39;brand&#39;:&#39;&#39;,spec:{}};。然后实现添加查询条件和取消查询条件。 1234567891011121314151617181920212223242526// 搜索$scope.search = function() &#123; searchService.search($scope.searchMap).success(function(response) &#123; $scope.resultMap = response; // 搜索返回的结果 &#125;);&#125;// 添加查询搜索项$scope.addSearchItem=function(key,value)&#123; if (key == 'brand' || key == 'category') &#123; // 如果点击品牌和分类 $scope.searchMap[key] = value; &#125;else&#123; $scope.searchMap.spec[key]=value; &#125; $scope.search();&#125;// 取消查询条件$scope.removeSearchItem=function(key)&#123; if (key == 'brand' || key == 'category') &#123; // 如果点击品牌和分类 $scope.searchMap[key] = ""; &#125;else&#123; delete $scope.searchMap.spec[key]; &#125; $scope.search();&#125; 价格区间筛选 ​ 点击搜索面板的价格区间，实现按价格筛选相应的商品。和上述的过滤条件类似，前端依然将价格区间以字符串的形式放入到 searchMap 集合中（如 ‘price’:’500-1000’）。然后后端通过字符串的截取获得相应的价格区间，然后进而筛选。 自定义搜索结果分页 ​ 前端将当前页数和页大小通过 searchMap 传给后端，然后后端通过构建 solr 的 query 对象实现分页效果。然后返回当前页数据和总页数以及总记录数。$scope.searchMap={&#39;keywords&#39;:&#39;&#39;,&#39;category&#39;:&#39;&#39;,&#39;brand&#39;:&#39;&#39;,&#39;spec&#39;:{},&#39;price&#39;:&#39;&#39;,&#39;pageNo&#39;:1,&#39;pageSize&#39;:40 };//搜索条件封装对象 通过当前页数、总页数然后构建分页标签。 12345678910111213141516171819202122232425262728// 构建分页标签buildPageLable=function()&#123; $scope.pageLable=[]; var firstPage = 1; // 开始页码 var lastPage = $scope.resultMap.totalPages; // 截止页码 $scope.firstDot = true; $scope.lastDot = true; if (lastPage &gt; 5)&#123; if ($scope.searchMap.pageNo&lt;=3)&#123; // 当前页码小于3，显示前五页 lastPage = 5; $scope.firstDot = false; &#125;else if ($scope.searchMap.pageNo&gt;=lastPage-2) &#123; // 当前页码大于总页数-2，则显示后5页 firstPage = lastPage - 4; $scope.lastDot = false; &#125;else &#123; firstPage = $scope.searchMap.pageNo - 2; lastPage = $scope.searchMap.pageNo + 2; &#125; &#125;else&#123; $scope.firstDot = false; $scope.lastDot = false; &#125; for (var i = firstPage; i &lt;= lastPage; i++) &#123; $scope.pageLable.push(i); &#125;&#125; 多关键字搜索 ​ 在搜索时，分词器首先会将我们输入的关键字进行分词，然后对每个分词都会去搜索对应的结果，然后求得并集。比如搜索“三星手机”时，会将“三星”的搜索集合和“手机”搜索结构都返回给我们。这样做可以显示更多数据，让用户有更多的选择。同时会根据搜索的关键字匹配度进行排序。 ​ 此时注意：当搜索关键字有空格时，中文分词无法进行分词，那么就会导致搜索出来的结果较少或者没有。然后可以采用在后端去掉关键字中所有的空格。原来如此，我平时搜索的时候经常喜欢敲空格，以为这样多个条件就能更精准的搜索我想要的额，套路套路。 搜索数据排序 ​ 根据综合、价格升降序、新品的来实现排序。前端传递两个参数，分别为待排序的字段名称和排序方式（升序or降序）。 123456789101112// 1.7 排序String sortValue = (String) searchMap.get("sort"); // 升序 or 降序String sortFiled = (String) searchMap.get("sortFiled"); // 升序字段if (!"".equals(sortValue) &amp;&amp; !"".equals(sortFiled)) &#123; if (sortValue.equals("ASC")) &#123; // 升序 Sort sort = new Sort(Sort.Direction.ASC, "item_"+sortFiled); query.addSort(sort); &#125;else if(sortValue.equals("DESC")) &#123; Sort sort = new Sort(Sort.Direction.DESC, "item_"+sortFiled); query.addSort(sort); &#125;&#125; ​ 销量和评价的排序(待完成)： 增加域 item_salecount 用于存储每一个 SKU 的销量信息，然后定时更新每一个 SKU 的销量数据（固定时间，比如一个月，否则会导致新上架的商品无法排在前列），同时每天定时更新一次销量数据。 隐藏品牌列表 ​ 当用户搜索的关键字包含品牌时隐藏品牌列表。也就是判断搜索关键字中是否存在返回的品牌列表中的信息。这个过程中发现，搜索关键字 searchMap.keywords 和输入框进行了绑定。那么当我们修改输入框的时候，可能就会影响品牌列表的显示。 此处将 search 重载，添加一个带 keywords的方法。然后搜索框就不和搜索关键字进行绑定，而是以传递参数的形式赋值给 searchMap。 首页和搜索页对接 ​ 在首页输入框中输入关键字，然后跳转到搜索页面，查询对应关键字的数据。 首页通过 链接的形式传递参数location.href=&quot;http://localhost:9104/search.html#?keywords=&quot;+$scope.keywords; 然后搜索模块使用 $location 服务接受参数。 123456// 引入 $location 服务// 接受首页跳转$scope.loadKeywords=function()&#123; $scope.searchMap.keywords = $location.search()['keywords']; $scope.search();&#125; 索引库的增量更新 ​ 实现在商品审核之后将数据更新到 solr 索引库，在商品删除的时候删除 solr 索引库中相应的记录。(增量更新) ​ 商品审核是对商品表（SPU信息）进行操作，但是索引库中存储的是SKU信息，所以首先需要通过商品的 SPU 信息查询该商品对应的 SKU 信息，然后将查询到的集合提交给 solrTemplate。删除可以直接根据 goodsId 集合进行条件删除。]]></content>
      <categories>
        <category>项目学习</category>
      </categories>
      <tags>
        <tag>品优购</tag>
        <tag>电商系统</tag>
        <tag>项目实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[品优购项目学习笔记]]></title>
    <url>%2F2018%2F12%2F18%2F%E5%93%81%E4%BC%98%E8%B4%AD%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一个综合性的 B2B2C 的电商网站系统。网站采用商家入驻的模式，商家入驻平台提交申请，有平台进行资质审核，审核通过后，商家拥有独立的管理后台录入商品信息。商品经过平台审核后即可发布。 Github地址 项目简介系统模块 网站前台 运营商平台 商家管理平台 框架组合 ​ 前端 angularJS + Bootstrap ​ 后端 Spring + SpringMVC + mybatis + Dubbox 系统架构​ 面向服务的架构（SOA架构）。控制层与服务层分离，通过网络调用。 Dubbox框架 致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。远程服务调用的分布式框架。 原理图 节点角色说明： Provider: 暴露服务的服务提供方。 Consumer: 调用远程服务的服务消费方。 Registry: 服务注册与发现的注册中心。 Monitor: 统计服务的调用次调和调用时间的监控中心。 Container: 服务运行容器。 模块关联关系图：]]></content>
      <categories>
        <category>项目学习</category>
      </categories>
      <tags>
        <tag>品优购</tag>
        <tag>电商系统</tag>
        <tag>项目实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04 常用命令集合]]></title>
    <url>%2F2018%2F04%2F28%2FUbuntu16-04-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[软件安装方法一： 1234sudo apt-get install 软件名 //最常用方法sudo apt-get remove 软件名 //卸载软件sudo apt-get update //更新软件列表，会访问源列表里的每个网址，并读取软件列表，然后保存在本地电脑sudo apt-get upgrade //更新软件，把本地已安装的软件，与刚update软件进行对比，如果发现已安装的软件版本太低，就会提示你更新。 方法二： deb软件包可直接安装 1sudo dpkg -i package.deb //deb包安装方法 deb详解： 123456789dpkg -r package 删除包 dpkg -P package 删除包（包括配置文件）dpkg -L package 列出与该包关联的文件 dpkg -l packag 显示该包的版本edpkg –unpack package.deb 解开 deb 包的内容 dpkg -S keyword 搜索所属的包内容 dpkg -l 列出当前已安装的包dpkg -c package.deb 列出 deb 包的内容 dpkg –configure package 配置包 方法三: rpm软件包安装Ubuntu的软件包格式是deb，如果要安装rpm的包，则要先用alien把rpm转换成deb。 12345sudo apt-get install alien //安装alien工具alien -d *.rpm //转换rpm包为deb包，然后再按方法二安装alien -i *.rpm //直接对rpm包进行安装 文件管理 常用命令： 123456789101112~ //当前用户主目录 cd ~ //home目录（/开头是绝对路径；.开头是相对路径）pwd //获取当前路径mkdir mydir //新建目录mydircp test(此处可为路径) /opt/test //将当前目录下的test复制到test中rm //删除文件mv oldname newname //重命名remove 'y/a-z/A-Z/' *.c //删文件cat test //查看文件test;-n显示行号file test //查看文件类型ls //查看当前目录下的文件ls -l 文件名称 //查看详细信息（文件夹将-l改为-ld） 文件权限说明：12// 文件属性 连接数 文件拥有者 所属群组 文件大小 文件修改时间 文件名drwxrwxr-x 9 mindyu mindyu 4096 4月 29 01:15 Blog r可读，w可写，x 可执行，-不可读/写/执行文件属性占10个位置例如：d rwx rwx r-x第一个字符指定了文件类型：‘- ’ 代表非目录的文件‘d’ 代表一个目录。第二段是文件拥有者User的属性，第三段是文件所属群组Group的属性，第四段是对于其它用户Other的属性。 权限修改方法一： 12//chmod [-R] 模式 文件chmod abc file 其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。r=4，w=2，x=1 例子：若要rwx属性则4+2+1=7；若要rw-属性则4+2=6；若要r-x属性则4+1=5。 123sudo chmod 600 ××× （只有所有者有读和写的权限）sudo chmod 644 ××× （所有者有读和写的权限，组用户和其他用户只有读的权限）sudo chmod 777 ××× （每个人都有读和写以及执行的权限） 方法二： 1chmod [ugoa] &#123;+|-|=&#125; [rwxst] 文件 用户参数：u 文件主 g 同组用户 o 其他用户 a 所有用户操作方法：+ 增加后列权限 - 取消后列权限 = 置成后列权限操作参数：r 可读 w 可写 x 可执行 s 运行时可置UID t 运行时可置GID 123chmod u+rw abc.txt //给用户增加读写权限chmod o-rwx abc.txt //不允许其他用户读写执行chmod g=rx abc.txt //只允许群组读取和执行 apt-get常用命令 update - 取回更新的软件包列表信息 upgrade - 进行一次升级 install - 安装新的软件包(注：软件包名称是 libc6 而非 libc6.deb) remove - 卸载软件包 purge - 卸载并清除软件包的配置 autoremove - 卸载所有自动安装且不再使用的软件包 dist-upgrade - 发布版升级，见 apt-get(8) dselect-upgrade - 根据 dselect 的选择来进行升级 build-dep - 为源码包配置所需的编译依赖关系 clean - 删除所有已下载的包文件 autoclean - 删除已下载的旧包文件 check - 核对以确认系统的依赖关系的完整性 source - 下载源码包文件 download - 下载指定的二进制包到当前目录 changelog - 下载指定软件包，并显示其changelog 解压缩命令.tar解包：tar xvf FileName.tar打包：tar cvf FileName.tar DirName 将DirName文件夹打包成一个FileName.tar文件打包：将一大堆文件或目录变成一个总的文件，压缩：将一个大的文件通过一些压缩算法变成一个小文件。 .gz解压1：gunzip FileName.gz解压2：gzip -d FileName.gz压缩：gzip FileName .tar.gz 和 .tgz解压：tar zxvf FileName.tar.gz压缩：tar zcvf FileName.tar.gz DirName .bz2解压1：bzip2 -d FileName.bz2解压2：bunzip2 FileName.bz2压缩： bzip2 -z FileName .tar.bz2解压：tar jxvf FileName.tar.bz2压缩：tar jcvf FileName.tar.bz2 DirName .bz解压1：bzip2 -d FileName.bz解压2：bunzip2 FileName.bz压缩：未知 .tar.bz解压：tar jxvf FileName.tar.bz压缩：未知 .Z解压：uncompress FileName.Z压缩：compress FileName .tar.Z解压：tar Zxvf FileName.tar.Z压缩：tar Zcvf FileName.tar.Z DirName .zip解压：unzip FileName.zip压缩：zip FileName.zip DirName .rar解压：rar x FileName.rar压缩：rar a -r FileName.rar DirName解压需要安装：sudo apt-get install unrar压缩需要安装：sudo apt-get install rar]]></content>
      <categories>
        <category>Ubuntu学习</category>
      </categories>
      <tags>
        <tag>Ubuntu16.04</tag>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04 常用软件安装]]></title>
    <url>%2F2018%2F04%2F26%2FUbuntu%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[Ubuntu系统尝鲜不知何时起，对Linux操作系统充满了好奇心，想去接触一番。 都说学编程搞开发的都离不开Linux操作系统，个人觉得Linux操作系统更适合学习，少了各种弹窗，界面更加清爽，系统任由你自己去操控，系统也更加稳定，许多的服务器也基本上都是Linux操作系统。然后就自己倒腾，在Windows上装了一个Ubuntu16.04LTS的双系统，通过日常是的使用去渐渐熟悉Linux操作系统，以及各种命令的使用～ 常用软件安装 Shadowsocks安装 12345sudo add-apt-repository ppa:hzwhuang/ss-qt5 sudo apt-get update sudo apt-get install shadowsocks-qt5 在Ubuntu系统上使用还需要设置系统代理，在 设置-》网络-》网络代理 中设置代理模式，最好设置为自动代理方式，然后添加一个pac文件，应用到整个系统即可。 小书匠安装一款Markdown编辑器，支持多平台使用。详细的安装及添加桌面快捷方式可见我的另一篇博客。 安装搜狗输入法其实个人感觉系统自带的输入法也还可以。 3.1 在官网下载搜狗输入法安装包 3.2 切换到deb包所在的目录，并执行以下命令：sudo dkpg -i deb包名 3.3 若出现由于缺少相关依赖文件的错误。执行以下命令，安装所缺少的依赖文件，然后再次使用3.2命令完成安装：sudo apt-get -f install 3.4 在“语言支持”面板，添加汉语支持，并将输入法系统设置为fcitx。然后重启 3.5 在Dash中搜索fcitx configuartion，在Input Method中添加和配置sogoupinyin即可 JDK安装 添加ppa 12sudo add-apt-repository ppa:webupd8team/javasudo apt-get update 安装oracle-java-installer 123456JDK8sudo apt-get install oracle-java8-installerJDK7sudo apt-get install oracle-java7-installer 安装时会提示你同意Oracle的服务条款，选择ok，然后选择yes Eclipse安装安装Eclipsesudo apt-get install eclipse启动Eclipseeclipse以及快捷方式制作，可见小书匠安装的详细博客 MyEclipse安装 在官方中文网下载MyEclipse安装包 我现在的是离线版，解压后为.run为后缀名的文件 双击执行，然后就和windows安装过程一样。选择安装目录比如/opt/MyEclipse/，一路Next即可。最后一步取消勾选。不立即打开MyEclipse。 然后下载对应的破解包，解压之后，执行cracker.jar包java -jar cracker.jar 之后的步骤和Windows破解过程一样。如果你一遍成功，那么就恭喜你。 我第一次安装失败了，因为破解包的问题，所以要确保破解包的正确性。 失败之后存在一个卸载不干净的问题。我也没有找到解决办法。 换了一台电脑，另外找了一个破解包，完美破解。 Google浏览器安装 下载 Chrome（Linux 版）https://www.google.cn/intl/zh-CN/chrome/ 终端下输入如下内容来安装.deb文件sudo dpkg -i 软件包名.deb 然后在Dash中搜索Google，打开即可。 使用中可能遇到两个问题： （1）重启之后，Google浏览器就打不开了 （2）设置新标签页打开网页 解决方案： 问题1： 网上的解决办法，大多是删除chrome的配置文件 rm -r~/.config/google-chrome 但是指标不治本，下次打开依然会出现问题 真正的解决方案是： 安装gnome-keyring。因为在登录谷歌账户之后，chrome会使用gnome-keyring来保护你的账户。 sudo apt install gnome-keyring 问题2： 打开google页面，任意搜索一个内容，在搜索结果页面的上面靠中间位置有一个设置，点击设置然后选择 搜索设置 ，即进入如下页面。 然后勾选结果打开方式的 在新的浏览器窗口中打开所选的每条搜索结果即可。 系统监视器实时查看电脑的cpu，内存占用率，更可以查看网速安装：12345sudo add-apt-repository ppa:fossfreedom/indicator-sysmonitor sudo apt-get update sudo apt-get install indicator-sysmonitor WPS 安装 在WPS官网下载alpha版本，我下载的是wps-office_10.1.0.5672~a21_amd64.deb 执行安装命令：sudo dpkg -i wps-office_10.1.0.5672~a21_amd64.deb 安装完成后，在Dash中即可搜索到，打开会发现字体缺失的问题 下载字体包 创建目录：sudo mkdir /usr/share/fonts/wps-office 将下载的字体复制到创建的目录：sudo cp -r wps_symbol_fonts.zip /usr/share/fonts/wps-office 切换到/usr/share/fonts/wps-office目录解压字体包：sudo unzip wps_symbol_fonts.zip 解压后删除字体包：sudo rm -r wps_symbol_fonts.zip再次打开就不会提示缺失字体包了！ 下载工具uget安装 12345sudo add-apt-repository ppa:plushuang-tw/uget-stable sudo apt-get update sudo apt-get install uget 终端和浏览器下载东西比较慢的时候可以试试，下载速度还是比较可观！ 参考博客：https://www.cnblogs.com/wadxy1314/p/6880264.html https://blog.csdn.net/Jesse_Mx/article/details/52816928 https://blog.csdn.net/u011324454/article/details/78497021 https://blog.csdn.net/VectorWWW/article/details/78820156 https://my.oschina.net/renwofei423/blog/635798]]></content>
      <categories>
        <category>Ubuntu学习</category>
      </categories>
      <tags>
        <tag>Ubuntu16.04</tag>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu安装小书匠并创建桌面快捷方式]]></title>
    <url>%2F2018%2F04%2F24%2FUbuntu%E5%AE%89%E8%A3%85%E5%B0%8F%E4%B9%A6%E5%8C%A0%E5%B9%B6%E5%88%9B%E5%BB%BA%E6%A1%8C%E9%9D%A2%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[小书匠简介 小书匠编辑器是一款专为markdown写作而设计的编辑器。 支持多种编辑模式。单栏编辑，双栏编辑，三栏编辑，实时预览，全屏写作，全屏阅读…想怎么切换，就怎么切换，就是这样随心所欲。 多种主题选择、丰富的语法支持、第三方同步等功能特色。原先在windows上习惯了使用小书匠，然后就想着在Ubuntu上也装一个。 小书匠安装小书匠已经托管到github，首先下载对应版本到本地。https://github.com/suziwen/markdownxiaoshujiang 解压下载下来的zip文件到指定文件夹：# unzip Story-writer-linux64.zip.zip -d /opt/Story-Writer/ 切换到解压出来的文件夹根目录，然后启动软件# ./Story-writer即可启动软件 存在的问题但是存在两个问题： 无快捷方式，每次打开过于麻烦 不能设置小书匠为系统默认打开.md文件 创建小书匠桌面快捷方式对于没有快捷方式这个问题，让我很容易想到当初安装Eclipse的时候也没有快捷启动方式。然后在网上找到解决方案。 UBuntu的菜单图标保存在/usr/share/applications目录下，所以先在该目录下建一个eclipse.desktop文件sudo gedit /usr/share/applications/eclipse.desktop 在文件中输入以下内容 12345678910[Desktop Entry]Encoding=UTF-8Name=Eclipse Platfrom //图标名字，可修改Comment=Eclipse IDE //注释，可修改Exec=/opt/eclipse/eclipse //Eclipse文件夹下eclipse的路径Icon=/opt/eclipse/icon.xpm //Eclipse文件夹下图标icon.xpm的路径Terminal=falseStartupNotify=trueType=ApplicationCategories=Application;Development; 3.对该文件进行赋权chmod u+x /usr/share/applications/eclipse.desktop 4.双击eclipse的图标就可以运行，然后复制到桌面就可以了 根据Ecllipse图标的制作，同理，然后试了小书匠是否也可以。 12345678910[Desktop Entry]Encoding=UTF-8Name=Story_Writer Comment=Story_WriterExec=/opt/Story_Writer/Story-writerIcon=/opt/Story_Writer/Story-writer.pngTerminal=falseStartupNotify=trueType=ApplicationCategories=Application;Development; 如图： 然后就出现了一个Story_Writer的快捷方式，双击即可打开小书匠。是不是很简单～ 对于另一个问题目前还没找到解决方案…. 原谅我还只是一个小白。如果有幸你可以看到，请留言我！]]></content>
      <categories>
        <category>Ubuntu学习</category>
      </categories>
      <tags>
        <tag>Ubuntu16.04</tag>
        <tag>小书匠</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析素数环问题]]></title>
    <url>%2F2018%2F03%2F18%2F%E6%B5%85%E6%9E%90%E7%B4%A0%E6%95%B0%E7%8E%AF%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[素数环的实现问题描述 从1到n这n个整数围成一个圆环，若其中任意2个相邻的数字相加，结果均为素数，那么这个环就成为素数环。 现在要求输入一个n，求n个数围成一圈有多少种素数环，规定第一个数字是1。 设计思路 1.数据结构：res数组用于保存最后满足描述的情况，isUsed数组用于标记1-n这些数字是否被使用，已达到不重复的效果。 2.规定第一个数字为1，res[0] = 1; 3.依次后面的值有两个限制 a.不能和前面的数字重复 b.和前一个数字相加为素数。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.util.Scanner;public class Main &#123; final static int max = 20; static int N; static int[] res = new int[max]; static boolean[] isUsed = new boolean[max]; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int k = 1; for (int i = 0; i &lt; isUsed.length; i++) &#123; res[i] = i+1; isUsed[i] = false; &#125; N = sc.nextInt(); while(N!=0)&#123; System.out.println("Case "+ k++ +":"); if (N%2==0) &#123; primeRing(1); &#125;else &#123; System.out.println("No Answer"); &#125; N = sc.nextInt(); &#125; sc.close(); &#125; // 递归实现，输出素数环 public static void primeRing(int cur)&#123; if (cur==N &amp;&amp; isPrime(res[cur-1]+res[0])) &#123; // 执行完成，并且首尾相加也是素数 for (int i = 0; i &lt; N-1; i++) &#123; System.out.print(res[i]+" "); &#125;System.out.print(res[N-1]); System.out.println(); return; &#125;else &#123; for (int i = 2; i &lt;= N; i++) &#123; // 选取一个满足条件的值，继续递归 if (!isUsed[i] &amp;&amp; isPrime(i+res[cur-1])) &#123; res[cur] = i; isUsed[i] = true; primeRing(cur+1); isUsed[i] = false; &#125; &#125; &#125; &#125; // 判断是否为素数 public static boolean isPrime(int x) &#123; if (x&lt;3) &#123; // 两数相加必定大于2，所以小于3的值不用考虑 return false; &#125;else &#123; for (int i = 2; i &lt;= Math.sqrt(x); i++) &#123; if (x%i==0) &#123; return false; &#125; &#125; &#125; return true; &#125;&#125; 运行结果 素数表格问题描述 前两天遇到一个问题和素数有关，从1到n中选择9个数字，填入3*3的表格中，使得相邻的数字相加和为素数。输出所有的情况。 设计思路 在CSDN上面看到过一片关于这个问题的博客。相邻两方格内的两个整数之和为质数-经典算法详解。理解起来可能还要一时半会儿。但是我觉得有了上述素数环的理解以及实现，只需要稍微修改一下上面的代码就可以达到表格的要求。 1.将3*3二维表格转换为一维数组。以下表格的数值代表数组中的位置。 0 1 2 7 8 3 6 5 4 2.问题可以简化为数组0-7下标组成一个素数环。然后数组res[8]同时与res1、res3、res[5]、res[7]分别相加合为素数。 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.util.Scanner;public class Main &#123; final static int max = 20; static int N; static int[] res = new int[max]; static boolean[] isUsed = new boolean[max]; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); for (int i = 0; i &lt; isUsed.length; i++) &#123; res[i] = i+1; isUsed[i] = false; &#125; N = sc.nextInt(); primeRing(1); sc.close(); &#125; // 递归实现，输出素数环 public static void primeRing(int cur)&#123; if (cur==8 &amp;&amp; isPrime(res[cur-1]+res[0])) &#123; // res[0]+res[7]和也为素数 for (int i = 2; i &lt;= N; i++) &#123; // 选取最后一个满足条件的值，填入res[8]位置 if (!isUsed[i] &amp;&amp; isPrime(i+res[1]) &amp;&amp; isPrime(i+res[3]) &amp;&amp; isPrime(i+res[5]) &amp;&amp; isPrime(i+res[7])) &#123; for (int j = 0; j &lt; 3; j++) // 输出第一行 System.out.print(res[j]+" "); System.out.println(); System.out.print(res[7]+" "); // 输出第二行 System.out.print(i+" "); System.out.print(res[3]+" "); System.out.println(); for (int j = 6; j &gt; 3; j--) // 输出第三行 System.out.print(res[j]+" "); System.out.println(); System.out.println(); &#125; &#125; return; &#125;else if(cur&lt;8)&#123; // 数组0-7下标组成一个素数环 for (int i = 2; i &lt;= N; i++) &#123; // 选取一个满足条件的值，继续递归 if (!isUsed[i] &amp;&amp; isPrime(i+res[cur-1])) &#123; res[cur] = i; isUsed[i] = true; primeRing(cur+1); isUsed[i] = false; &#125; &#125; &#125; &#125; // 判断是否为素数 public static boolean isPrime(int x) &#123; if (x&lt;3) &#123; // 两数相加必定大于2，所以小于3的值不用考虑 return false; &#125;else &#123; for (int i = 2; i &lt;= Math.sqrt(x); i++) &#123; if (x%i==0) &#123; return false; &#125; &#125; &#125; return true; &#125;&#125; 运行截图]]></content>
      <categories>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>素数环问题</tag>
        <tag>3*3素数表格</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析n元素出栈序列]]></title>
    <url>%2F2018%2F02%2F24%2F%E6%B5%85%E6%9E%90n%E5%85%83%E7%B4%A0%E5%87%BA%E6%A0%88%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[栈的简介 栈（stack）又名堆栈，它是一种运算受限的线性表。其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。遵循后进先出的原则。 n个元素出栈顺序种数 问题描述有n个元素依次进栈，请问总共有多少种出栈序列？ 算法分析首先列举出简单的情况：当1个元素进栈，有1种出栈顺序；当2个元素进栈，有2种出栈顺序；当3个元素进栈，有5种出栈顺序 ；我们把n个元素的出栈个数的记为f(n), 则对于1，2，3有 123f(1) = 1 //即 1f(2) = 2 //即 12、21f(3) = 5 //即 123、132、213、321、231 对于f(4)，我们假定是a,b,c,d四个元素。任意一个元素在其出栈序列中只有4个位置。取元素a分别讨论其在出栈序列中的位置：1.当a元素在位置1时，只可能是a先入栈，然后出栈。接下来就是其它三个元素b,c,d的出栈序列，也就是子问题f(3)。2.元素a在位置2处，有一个元素比a先出栈可能的序列即f(1)，另外两个元素在位置3，4即f(2)。3.元素a在位置3处，有两个元素比a先出栈可能的序列即f(2)，另外两个元素在位置4即f(1)。4.元素a在位置4处，有三个元素比a先出栈可能的序列即f(3).那么f(4) = f(3) + f(2) f(1) + f(1) f(2) + f(3);然后推广到n，按同理我们可以很容易的得到：f(n) = f(0)f(n-1) + f(1)f(n-2) + … + f(n-1)*f(0) 上式也就是卡特兰数（Catalen）:卡特兰数的通项公式为：变换形式：另类递归式： C(n)=((4n-2)/(n+1))C(n-1); 卡特兰数的应用：1.括号化问题。 矩阵链乘： P=a1×a2×a3×……×an，依据乘法结合律，不改变其顺序，只用括号表示成对的乘积，试问有几种括号化的方案？(C(n-1)种) 2.出栈次序问题。 n个元素依次进栈，请问总共有多少种出栈序列？ 案例：2012腾讯实习招聘笔试题在图书馆一共6个人在排队，3个还《面试宝典》一书，3个在借《面试宝典》一书，图书馆此时没有了面试宝典了，求他们排队的总数？ 解析：还书相当于入栈，借书相当于出栈。只有当栈内元素不为空时才可以借书。C(3) = 5。借书3个人，还书3个人求全排列。 总数为53!3! = 180。 3.将多边行划分为三角形问题。将一个凸N+2多边形区域分成三角形区域的方法数?类似：一位大城市的律师在她住所以北n个街区和以东n个街区处工作。每天她走2n个街区去上班。如果她从不穿越（但可以碰到）从家到办公室的对角线，那么有多少条可能的道路？ 类似：在圆上选择2n个点,将这些点成对连接起来使得所得到的n条线段不相交的方法数? 4.给顶节点组成二叉树的问题。给定N个节点，能构成多少种不同的二叉树？（能构成Cn个）Catalan数的解法:Catalan数的组合公式为 Cn=C(2n,n) / (n+1);此数的递归公式为 C(n ) = C(n-1)(4n-2) / (n+1) 代码实现 123456789101112131415161718192021222324252627282930313233343536373839import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[] arr = new int[n+1]; arr[0] = 1;arr[1] = 1; Catalen_1(arr, n);// Catalen_2(arr, n); for (int i = 1;i&lt;=n;i++)&#123; System.out.println(arr[i]); &#125; sc.close(); &#125; public static void Catalen_1(int[] arr, int n) &#123; // 递推关系式 f(n) = f(0)*f(n-1) + f(1)*f(n-2) + … + f(n-1)*f(0) for (int i=2; i&lt;=n; ++i) &#123; for (int j=0; j&lt;i; ++j) &#123; arr[i] += arr[j] * arr[i-1-j]; &#125; &#125; &#125; public static void Catalen_2(int[] arr, int n) &#123; // 递推关系式 C(n)=((4*n-2)/(n+1))*C(n-1) for (int i=2; i&lt;=n; ++i) &#123; arr[i] = arr[i-1] * (4*i-2) / (i+1); &#125; &#125; &#125; 运行结果 n个元素出栈序列输出1.设计思路所需数据结构，1栈2队列，输入队列从头部取出数据压入栈中，数据出栈进入输出队列。最终输出队列即为出栈序列的情况。采用递归的方式，将大问题分解为小问题。栈存在两种状态：1.输入队列入栈，2.输出队列出栈。 2.代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.util.LinkedList;import java.util.Queue;import java.util.Scanner;import java.util.Stack;public class Main &#123; static int n; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); n = sc.nextInt(); // 元素个数 Stack&lt;Integer&gt; s = new Stack&lt;Integer&gt;(); Queue&lt;Integer&gt; in = new LinkedList&lt;Integer&gt;(); for (int i = 1; i &lt;= n; i++) &#123; in.offer(i); &#125; Queue&lt;Integer&gt; out = new LinkedList&lt;Integer&gt;(); printAllOutStackSeq(in, s, out); sc.close(); &#125; @SuppressWarnings("unchecked") public static void printAllOutStackSeq(Queue&lt;Integer&gt; in, Stack&lt;Integer&gt; s, Queue&lt;Integer&gt; out) &#123; if (out.size()==n) &#123; // 所有元素都出栈了 while( !out.isEmpty() )&#123; System.out.print(out.poll()+"");; &#125; System.out.println(); return; &#125; Queue&lt;Integer&gt; inCopy = new LinkedList&lt;Integer&gt;(in); Stack&lt;Integer&gt; sCopy = (Stack&lt;Integer&gt;) s.clone(); Queue&lt;Integer&gt; outCopy = new LinkedList&lt;Integer&gt;(out); if( !s.empty() ) &#123; // 出栈，将元素出栈，push到结果队列中 out.offer( s.pop() ); printAllOutStackSeq( inCopy, s, out ); &#125; if ( !in.isEmpty() ) &#123; // 入栈，将输入队列出队，进行入栈 sCopy.push(in.poll()); printAllOutStackSeq( in, sCopy, outCopy ); &#125; return; &#125;&#125; 3.运行结果 判断一个序列是否是可能的出栈序列1.设计思路输入一个序列，判断该序列是否可能是正确的出栈序列（反向推理）。代码中A代表着有序的输入队列（1，2，3….，n）代码中B代表着所输入的目标序列的下标，从下标为1的位置开始匹配。代码中S代表栈，进行入栈、出栈操作。A == target[B] 当前输入队列头元素与目标序列B位置元素相同，也就是输入队列元素取头元素进行入栈，然后立即出栈。!s.isEmpty() &amp;&amp; s.peek() == target[B] 当前栈顶元素与目标序列B位置元素相同，也就是栈内元素出栈。A &lt;= n 上述两种情况都不满足时，也就是输入队列的头元素一直进行入栈操作。最后也不入栈也不出栈，也不就意味着目标序列不是出栈序列。 2.代码实现123456789101112131415161718192021222324252627282930313233343536import java.util.Scanner;import java.util.Stack;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while(sc.hasNext())&#123; int n = sc.nextInt(); // 元素个数 if (n==0) break; int[] target = new int[n+1]; Stack&lt;Integer&gt; s = new Stack&lt;Integer&gt;(); for (int i = 1; i &lt;= n; i++) &#123; target[i] = sc.nextInt(); &#125; int A = 1, B = 1, flag = 1; while(B &lt;= n)&#123; if (A == target[B]) &#123; A++;B++; &#125;else if (!s.isEmpty() &amp;&amp; s.peek() == target[B]) &#123; s.pop(); B++; &#125;else if (A &lt;= n ) &#123; s.push(A++); &#125;else &#123; flag = 0; break; &#125; &#125; System.out.println(flag==1?"Yes":"No"); &#125; sc.close(); &#125;&#125; 3.运行结果]]></content>
      <categories>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>数据结构</tag>
        <tag>卡特兰数</tag>
        <tag>Catalen</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统经典算法之银行家算法]]></title>
    <url>%2F2017%2F12%2F13%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E4%B9%8B%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[需求分析1. 银行家算法的实现思想 允许进程动态地申请资源，系统在每次实施资源分配之前，先计算资源分配的安全性，若此次资源分配安全（即资源分配后，系统能按某种顺序来为每个进程分配其所需的资源，直至最大需求，使每个进程都可以顺利地完成），便将资源分配给进程，否则不分配资源，让进程等待。 2. 死锁的概念 死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。 此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。银行家算法是避免死锁的一种重要方法。 操作系统按照银行家制定的规则为进程分配资源，当进程首次申请资源时，要测试该进程对资源的最大需求量，如果系统现存的资源可以满足它的最大需求量则按当前的申请量分配资源，否则就推迟分配。当进程在执行中继续申请资源时，先测试该进程已占用的资源数与本次申请的资源数之和是否超过了该进程对资源的最大需求量。若超过则拒绝分配资源，若没有超过则再测试系统现存的资源能否满足该进程尚需的最大资源量，若能满足则按当前的申请量分配资源，否则也要推迟分配。 3. 产生死锁的必要条件① 互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。② 请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。③ 不可抢占条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。④ 循环等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，•••，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。 4.功能实现 理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁。所以，在系统设计、进程调度等方面注意如何能够不让这四个必要条件同时成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源,在系统运行过程中，对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源，若分配后系统可能发生死锁，则不予分配，否则予以分配 。因此，对资源的分配要给予合理的规划。 概要设计1.数据结构1) 可利用资源向量Available。这是一个含有m个元素的数组，其中的而每一个元素代表一类可利用资源数目，其初始值是系统中所配置的该类全部可用资源的数目，其数值随该类资源的分配和回收而动态的改变。如果Available[j]=K,则表示系统中现有Rj类资源K个。 2) 最大需求矩阵Max。这是一个n * m的矩阵，它定义了系统中n个进程中的每一个进程对m类资源的最大需求。如果Max[i,j]=K；则表示进程i需要Rj类资源的最大数目为K。 3) 分配矩阵Allocation。这也是一个n * m的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。如果Allocation[i,j]=K，则表示进程i当前已分得Rj类资源的数目为K。 4) 需求矩阵Need。这也是一个n m的矩阵，用以表示每一个进程尚需的各类资源数。如果Need[i,j]=K,则表示进程i还需要Rj类资源K个，方能完成任务。 上述三个矩阵间存在下述关系：*Need[i,j]=Max[i,j]-Allocation[i,j] 设计思路第一部分：银行家算法模块1．如果Request&lt;=Need,则转向2;否则,出错2．如果Request&lt;=Available,则转向3,否则等待3．系统试探分配请求的资源给进程4．系统执行安全性算法 第二部分:安全性算法模块 设置两个向量① 工作向量:Work=Available(表示系统可提供给进程继续运行所需要的各类资源数目)② Finish:表示系统是否有足够资源分配给进程(True:有;False:没有).初始化为False 若Finish[i]=False&amp;&amp;Need&lt;=Work,则执行3;否则执行4(i为资源类别) 进程P获得第i类资源,则顺利执行直至完成，并释放资源: Work=Work+Allocation; Finish[i]=true;转2 若所有进程的Finish[i]=true,则表示系统安全;否则,不安全! 详细设计1.银行家算法 设Request i是进程Pi的申请向量，如果Request i[j]=K,则表示进程Pi需要K个Rj类型的资源。当Pi发出资源请求后，系统按下述步骤进行检查：1) 如果Request i[j]&lt;=Need[i,j]，便转向步骤2）；否则认为出错，因为它所需要的资源数已经超过它所宣布的最大值。2) 如果Request i[j]&lt;=Available[i,j]，便转向步骤3）；否则，表示尚无足够资源，Pi需等待。3) 系统试探着把资源分配给进程Pi，并修改下面数据结构中的数值： Available[j]:=Available[j]-Request i[j]; Allocation[i,j]:=Allocation[i,j]+Request i[j]; Need[i,j]:=Need[i,j]-Request i[j];4) 系统执行安全性算法，检查此次资源分配后系统是否处于安全状态。若安全，才正式将资源分配给进程Pi，以完成本次分配；否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程Pi等待。 2.安全性算法系统所执行的安全性算法可描述如下：1) 设置两个向量① 工作向量Work，它表示系统可提供给进程继续运行所需的各类资源数目，它含有m个元素，在执行安全算法开始时，Work：=Available。② Finish，它表示系统是否有足够的资源分配给进程，使之运行完成。开始时先做Finish[i]:=false;当有足够资源分配给进程时，再令Finish[i]:=ture.2) 从进程集合中找到一个满足下述条件的进程：① Finish[i]=false;② Need[i,j]&lt;=Work[j];若找不到，执行步骤3），否则，执行步骤4）。3） 当进程Pi获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行： Work[j]:=Work[j]+Allocation[i,j]; Finish[i]:=true; Go to step 2;4) 如果所有进程的Finish[i]=true都满足，则表示系统处于安全状态；否则，系统处于不安全状态。 代码流程图： 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int Available[10]; //可使用资源向量int Max[10][10]; //最大需求矩阵int Allocation[10][10] = &#123; 0 &#125;; //分配矩阵int Need[10][10] = &#123; 0 &#125;; //需求矩阵int Work[10]; //工作向量bool Finish[10]; //是否有足够的资源分配，状态标志int Request[10][10]; //进程申请资源向量int Pause[10];int arr[] = &#123; 0 &#125;; //各类资源总数int List[10];int i, j;int n; //系统资源种类数int m; //总的进程数int a; //当前申请的进程号int l, e, z = 0; //计数器int b = 0, c = 0, f = 0, g; //显示菜单void menu()&#123; printf("*************************银行家算法**************************\n\n"); printf("\n\n\t1:初始化数据"); printf("\n \t2:设置进程资源申请"); printf("\n \t3:查看资源分配状态"); printf("\n \t4:退出程序"); printf("\n\n\t\t\t 请输入你的选择: ");&#125;//显示资源分配状态void mainshow()&#123; printf("\n\n"); if (n == 3) &#123; printf(" 最大需求量 已分配 尚需要量 \n进程"); &#125; if (n == 2) &#123; printf(" 最大需求 已分配 尚需要量 \n进程"); &#125; for (i = 1; i &lt;= 3; i++) &#123; for (j = 1; j &lt;= n; j++) &#123; printf(" %d类", j); &#125; &#125; for (i = 1; i &lt;= m; i++) &#123; printf("\nP[%d]", i); for (j = 1; j &lt;= n; j++) &#123; printf(" %2d ", Max[i][j]); //最大需求 &#125; for (j = 1; j &lt;= n; j++) &#123; printf(" %2d ", Allocation[i][j]); //分配 &#125; for (j = 1; j &lt;= n; j++) &#123; printf(" %2d ", Need[i][j]); //需求 &#125; &#125; printf("\n\n系统剩余资源量： "); for (i = 1; i &lt;= n; i++) &#123; printf(" %d ", Available[i]); &#125; printf("\n");&#125;//安全性检测int securitycheck()&#123; printf("\n\n"); printf("**************************安全性检测**************************\n\n"); printf(" 工作向量 尚需求量 已分配 工作向量+已分配 Finish \n进程 "); for (c = 1; c &lt;= 4; c++) &#123; for (j = 1; j &lt;= n; j++) &#123; printf(" %d类", j); &#125; &#125; for (j = 1; j &lt;= n; j++) &#123; Pause[j] = Available[j]; //Pause[i]为防止在下面安全性检查时修改到Available[i]而定义的备份 &#125; for (i = 1; i &lt;= m; i++) &#123; Finish[i] = false; &#125; for (i = 1; i &lt;= m; i++) &#123; b = 0; //计数器初始化 if (!Finish[i])&#123; for (j = 1; j &lt;= n; j++) //资源种类数 &#123; if (Need[i][j] &lt;= Pause[j]) //可使用资源向量备份，若3类资源均满足条件 &#123; b = b + 1; &#125; else &#123; break; &#125; if (b == n) &#123; Finish[i] = true; printf("\nP[%d] ", i); //依次输出进程安全序列 for (l = 1; l &lt;= n; l++) &#123; printf(" %2d ", Pause[l]); &#125; for (j = 1; j &lt;= n; j++) &#123; printf(" %2d ", Need[i][j]); &#125; for (j = 1; j &lt;= n; j++) &#123; //Allocation[i][j]=Pause[j]-Need[i][j]; printf(" %2d ", Allocation[i][j]); &#125; for (j = 1; j &lt;= n; j++) &#123; printf(" %2d ", Pause[j] + Allocation[i][j]); &#125; printf(" true"); for (l = 1; l &lt;= n; l++) &#123; Pause[l] = Pause[l] + Allocation[i][l]; //回收该进程资源 &#125; i = 0; break; &#125; &#125; &#125; &#125; printf("\n\n"); for (i = 1; i &lt;= m; i++) &#123; if (Finish[i] == true) f = f + 1; //统计Finish[i]＝＝true的个数 &#125; if (f == m) //全为true &#123; printf("处于安全状态"); printf("\n\n系统剩余资源量： "); for (i = 1; i &lt;= n; i++) &#123; printf(" %d ", Available[i]); &#125; f = 0; //将计数器f重新初始化，为下一次提出新的进程申请做准备 printf("\n\n"); return 1; &#125; else &#123; printf("处于不安全状态"); for (i = 1; i &lt;= n; i++) &#123; Available[i] = Available[i] + Request[a][i]; Allocation[a][i] = Allocation[a][i] - Request[a][i]; Need[a][i] = Need[a][i] + Request[a][i]; &#125; printf("\n\n"); return 0; &#125;&#125;//初始化数据void initialize()&#123; printf("请输入系统的资源种类数："); scanf_s("%d", &amp;n); printf("请输入%d类资源总数(以空格分隔)： ", n); for (i = 1; i &lt;= n; i++) &#123; scanf_s("%d", &amp;arr[i]); &#125; printf("请输入进程总数："); scanf_s("%d", &amp;m); for (i = 1; i &lt;= m; i++) &#123; printf("进程P[%d]对这%d类资源的最大需求量(以空格分隔)： ", i, n); for (j = 1; j &lt;= n; j++) &#123; scanf_s("%d", &amp;Max[i][j]); &#125; &#125; for (i = 1; i &lt;= m; i++) &#123; printf("进程P[%d]对这%d类资源已分配数(以空格分隔)： ", i, n); for (j = 1; j &lt;= n; j++) &#123; scanf_s("%d", &amp;Allocation[i][j]); Need[i][j] = Max[i][j] - Allocation[i][j]; //尚需资源数为 最大-已分配 &#125; &#125; for (i = 1; i &lt;= n; i++) &#123; for (j = 1; j &lt;= m; j++) &#123; arr[i] -= Allocation[j][i]; //各类资源总数-各进程分配的资源数 &#125; &#125; for (i = 1; i &lt;= n; i++) Available[i] = arr[i]; securitycheck();&#125;//进程申请资源void mainrequest()&#123; printf("请输入申请资源的进程："); scanf_s("%d", &amp;a); for (i = 1; i &lt;= n; i++) &#123; printf("请输入进程P[%d]对%d类资源的申请量：", a, i); scanf_s("%d", &amp;Request[a][i]); if (Request[a][i] &gt; Need[a][i]) &#123; printf("\n出错！进程申请的资源数多于它自己申报的最大需求量\n"); return; &#125; if (Request[a][i] &gt; Available[i]) &#123; printf("\nP[%d]请求的资源数大于可用资源数，必须等待\n", a); return; &#125; &#125; for (i = 1; i &lt;= n; i++) &#123; //以下是试探性分配 Available[i] = Available[i] - Request[a][i]; Allocation[a][i] = Allocation[a][i] + Request[a][i]; Need[a][i] = Need[a][i] - Request[a][i]; &#125; int ret = securitycheck(); if (ret == 1) &#123; int key = 0; for (j = 1; j &lt;= n; j++) &#123; if (Need[a][j] == 0) &#123; key++; &#125; &#125; if (key == n) &#123; for (j = 1; j &lt;= n; j++) &#123; Available[j] += Allocation[a][j]; Allocation[a][j] = 0; &#125; &#125; &#125;&#125;int main()&#123; int key = 0; printf("\n\n"); while (1) &#123; menu(); scanf_s("%d", &amp;key); printf("\n\n"); switch (key) &#123; case 1: initialize(); break; case 2: mainrequest(); break; case 3: mainshow(); break; case 4: printf("\n\n\t\t谢谢使用 \n"); printf("\n\t\tMade by 杨陈强!\n\n\n"); system("pause"); return 0; &#125; &#125; system("pause"); return 0;&#125; 结果分析程序菜单界面： 初始化数据：（模拟课本113例子） T0时刻的安全性： 由上图可知，存在安全序列{P2,P4,P1,P3,P5},（存在多种情况，此处只寻找到一种可行的情况）故系统处于安全状态。 P2请求资源：P2发出请求向量Request2（1，0，2），系统按银行家算法进行检查。然后再通过安全性算法检查此时系统是否处于安全状态。上图为安全状态！ 银行家算法测试:当进程1申请的资源大于系统剩余的资源时，提示进程必须等待！ 安全性算法测试：当进程1申请的资源过多时，导致各进程处于请求与保持状态，提示系统处于不安全状态！并且此次资源申请无效 查看资源分配情况：（依然处于第一次P2请求资源结束的状态） 通过这次课程设计，让我对银行家算法（避免死锁）有了更深入的理解，同时借鉴网上一些优秀的实现过程，自己理解并修改而记之！]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Android Canvas绘制折线图]]></title>
    <url>%2F2017%2F12%2F08%2F%E4%BD%BF%E7%94%A8Android-Canvas%E7%BB%98%E5%88%B6%E6%8A%98%E7%BA%BF%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[优化画图方法 原先磁感应力检测仪项目的绘图方法一直是采用的Android AChartEngine方法，简单介绍一下AChartEngine，它是 Android 平台的图表开发库, 能绘制 折线图, 饼图, 气泡图, 柱状图, 散点图, 面积图等统计图表。网上有很多例子，推荐一个Android 图表绘制 achartengine 示例解析。该方法优点：使用简单，只需要将数据传入到数据集，并设置相应渲染器的绘制颜色，线的粗细等等。缺点：当数据量较大时，在移动与缩放时会显得比较卡顿。 接下来就介绍一种新的绘制方法：Android Canvas方法 当我们在自定义 View的时候，我们经常需要绘制一些自己想要的效果。通过Canvas对象我们就可以绘制出我们自己想要的效果。比如折线图、平面图等等。对于一些简单的原理操作网上有很多Demo，推荐一个我在简书上面看到的一篇Android Canvas 方法总结，里面介绍了关于Canvas的平移、缩放、旋转，以及后面使用Canvas对象绘制直线、各种形状以及文字。通过图形的展示，我相信很快就可以看懂啦！ 正式开始我做的内容： 首先贴一张我们所需要最终达到的效果图 1.坐标线的绘制：此时需要注意的是Canvas画布的坐标是以 左上角为坐标原点的，水平向右为X轴的正方向，垂直向下为Y轴的正方向，而为了美观以及需求，我们需要将坐标原点设置在左下角，同时Y轴的正方向为垂直向上。而达到最终效果。坐标原点设置在左下角可以通过简单的平移画布而实现坐标（0，0）位于View的左下角，但是方向岂不是还要通过翻转？ 这里其实并没有翻转这个方法，我指的其实就是通过坐标数据计算它对应的位置。画布的坐标原点并非你所显示的坐标原点。这样会使得画图麻烦很多。此时通过一个巧妙地方法，坐标数据的Y值我给它一个负号，那么如果是（2，5）和（3，7），而我实际将它们绘制在画布上的（2，-5）和（3，-7）；而-7比-5小，正好-7就在-5的上方，从而模拟出正方形为垂直向上。123456789//绘制坐标线@Overridepublic void drawAxis(Canvas canvas) &#123; canvasWidth -= 140f; //留有边距以显示坐标对应的值 canvasHeight -= 140f; canvas.translate(110f, canvasHeight + 40f); // 使画布向 x 轴正向移动 110f，向 y 轴移动 40f canvas.drawLine(0, 0, canvasWidth, 0, paint); // 绘制 x 轴 canvas.drawLine(0, 0, 0,-canvasHeight, paint); // 绘制 y 轴&#125; 2.坐标刻度的绘制坐标主要需要完成动态的适配，当平移和缩放的时候坐标动态显示，并且完成它们之间的间距控制，所显示的画布上坐标轴上只显示2-6个坐标，避免坐标刻度太密而使得刻度值挤在一块无法显示。实现思路是：a.通过float interval = measureInterval(xDistance/xScale); //每组值得间隔计算当前显示区域的相邻坐标的间距。b.通过int n = (int) Math.ceil((xDistance/xScale)/interval); //一组有几个值计算当前显示区域的坐标数量也就对于上述的（2-6）c.通过1int first = (int) Math.floor((xStart-((1-xScale)/2+xTranslate/canvasWidth)*xDistance/xScale)/interval); 计算出所显示的首坐标的位置。d.循环n次，依次显示n个从first+i开始的坐标刻度值。 123456// 所需要的坐标属性： protected float xDistance; // x 方向总距离 protected float yDistance; // y 方向总距离 protected float xStart=0, yStart=0; // 起始点坐标 protected float xTranslate = 0, yTranslate = 0; // 分别控制 x 和 y 方向的平移距离，单位为屏幕像素，达到手指移动多少，坐标平移多少 protected float xScale = 1, yScale = 1; // 分别控制 x 和 y 方向的缩放程度 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 //绘制坐标值及刻度 @Override public void drawCoordinates(Canvas canvas) &#123; String number; DecimalFormat df1 = new DecimalFormat("0.0"); DecimalFormat df2 = new DecimalFormat("0.00"); DecimalFormat df3 = new DecimalFormat("0.000"); // 绘制 x 轴坐标 canvas.save(); // 保存画布状态 canvas.clipRect(0, 0, canvasWidth, 60f); // 切割画布，使坐标显示在一定范围内 canvas.translate((1 - xScale) / 2 * canvasWidth, 0); // 缩放时，平移使得与折线图一致 canvas.translate(xTranslate, 0); // 使坐标跟着图形一起平移 float interval = measureInterval(xDistance/xScale); //每组值得间隔 int n = (int) Math.ceil((xDistance/xScale)/interval); //一组有几个值 int first = (int) Math.floor((xStart-((1-xScale)/2+xTranslate/canvasWidth)*xDistance/xScale)/interval); for (int i = 0; i &lt;= n; i++)&#123; if (interval &lt; 0.01)&#123; number = df3.format((first+i)*interval); &#125;else if (interval &lt;= 0.1)&#123; number = df2.format((first+i)*interval); &#125;else if (interval &lt; 1)&#123; number = df1.format((first+i)*interval); &#125;else &#123; number = String.valueOf((first+i)*(int)interval); &#125; canvas.drawLine((canvasWidth * (first+i) * interval / xDistance * xScale), 0f, (canvasWidth * (first+i) * interval / xDistance * xScale), 10f,paint); canvas.drawText( number, (canvasWidth * (first+i) * interval / xDistance * xScale), 40f, paint); &#125; canvas.restore(); // 使画布返回上一个状态 // 绘制 y 轴坐标 canvas.save(); // 保存画布状态 canvas.clipRect(-110f, -canvasHeight, 0, 0); // 切割画布，使坐标显示在一定范围内 canvas.translate(0, -(1 - yScale) / 2 * canvasHeight); // 缩放时平移使得与折线图一致 canvas.translate(0, (yTranslate/yScale-yStart/yDistance*canvasHeight)*yScale); // 使坐标跟着图形一起平移 interval = measureInterval(yDistance/yScale); //每组值得间隔// Log.d("Chart","interval="+interval); n = (int) Math.ceil((yDistance/yScale)/interval); //一组有几个值// Log.d("Chart","n="+n); first = -(int) Math.floor((yStart+yDistance/yScale/2*(1-yScale)-yTranslate/yScale/canvasHeight*yDistance)/interval);// Log.d("Chart","first="+first); for (int i = 0; i &lt;= n; i++)&#123; if (interval &lt; 0.01)&#123; number = df3.format((first+i)*interval); &#125;else if (interval &lt;= 0.1)&#123; number = df2.format((first+i)*interval); &#125;else if (interval &lt; 1)&#123; number = df1.format((first+i)*interval); &#125;else &#123; number = String.valueOf((first+i)*(int)interval); &#125; canvas.drawLine(-10f, -(canvasHeight * (first+i) * interval / yDistance * yScale), 0f, -(canvasHeight * (first+i) * interval / yDistance * yScale),paint); canvas.drawText( number, -5f, -(canvasHeight * (first+i) * interval / yDistance * yScale)-4, paint); &#125; canvas.restore(); // 使画布返回上一个状态 &#125; 以下为坐标完成动态适配的效果图： 3.折线与图形的绘制由于需要绘制两种不同的图形，去噪图（折线图）和扫描图（平面图），此处将画图方法抽象出来：子类通过重写drawAction方法来完成各自所需绘制的图形。同时后期如果需要绘制其他类型的图，继承此抽象类然后重写自己的drawAction方法即可实现不同类型的图形绘制。以下为折线图的drawAction方法：根据平移与缩放值，将画布进行相应的平移与缩放，同时设置图形的缩放中心，以所显示图形的中心点为缩放中心。然后设置画笔样式及颜色，通过所获取的xList与yList值连接相邻点达到绘制折线的效果。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//绘制曲线 @Override public void drawAction(Canvas canvas) &#123; // 裁切矩形，把画面控制在坐标平面内 canvas.clipRect(0, 0, canvasWidth, -canvasHeight); // 手势缩放移动 canvas.translate(xTranslate/xScale, yTranslate/yScale-yStart/yDistance*canvasHeight); float px = (canvasWidth / 2 - xTranslate/xScale); float py = (canvasHeight / 2 + yTranslate/yScale-yStart/yDistance*canvasHeight); canvas.scale(xScale, yScale, px, -py); //以图的中心点缩放 paint.setDither(true); //设定是否使用图像抖动处理，会使绘制出来的图片颜色更加平滑和饱满，图像更加清晰 paint.setFilterBitmap(true); //如果该项设置为true，则图像在动画进行中会滤掉对Bitmap图像的优化操作，加快显示速度，本设置项依赖于dither和xfermode的设置 paint.setStyle(Paint.Style.FILL_AND_STROKE); //设置画笔的样式，Style.FILL: 实心 STROKE:空心 FILL_OR_STROKE:同时实心与空心 paint.setStrokeJoin(Paint.Join.ROUND); //设置绘制时各图形的结合方式，如平滑效果等 BEVEL斜角 //paint.setStrokeWidth(4/xScale); //当画笔样式为STROKE或FILL_OR_STROKE时，设置笔刷的粗细度 int[] colors = GlobalParameter.getInstance().getColors(); // 绘制图形 for (int i=0; i&lt;showIDs.size(); i++) &#123; //通道数 for (int j=0; j&lt; yList.get(showIDs.get(i)).size()-1; j++) &#123; paint.setColor(colors[showIDs.get(i)]); if ((yList.get(showIDs.get(i)).get(j+1)-yList.get(showIDs.get(i)).get(j))&lt;15&amp;&amp;(yList.get(showIDs.get(i)).get(j+1)-yList.get(showIDs.get(i)).get(j))&gt;-15)&#123; paint.setStrokeWidth(3/yScale); &#125;else &#123; paint.setStrokeWidth(3/xScale); &#125; canvas.drawLine( //xDistance x方向的总距离 xList.get(j) / xDistance * canvasWidth, -yList.get(showIDs.get(i)).get(j) / yDistance * canvasHeight, xList.get(j+1) / xDistance * canvasWidth, -yList.get(showIDs.get(i)).get(j+1) / yDistance * canvasHeight, paint ); &#125; &#125; if (points!=null)&#123; paint.setColor(Color.RED); for (int i=0;i&lt;points.size()-1;i++)&#123; canvas.drawLine( //xDistance x方向的总距离 points.get(i).getX() / xDistance * canvasWidth, -points.get(i).getY() / yDistance * canvasHeight, points.get(i+1).getX() / xDistance * canvasWidth, -points.get(i+1).getY() / yDistance * canvasHeight, paint ); &#125; &#125; initPaints(); //画笔reset &#125; 以下为PopWindow弹出框中横屏显示折线图的效果： 4.Touch手势事件的监听Android Canvas 没有提供有关手势缩放的功能，但我们可以利用onTouchListener 来监测手势，并根据手势的不同对扫描图作不同处理，比如移动和缩放。采用接口回调机制，在所需用到AbstractChartService对象处，进行手势监控，减少抽象类间的耦合性。 通过设置OnTouchListener监听，只要有手指触碰到绘制的图形，就会触发 onTouch 方法，同时通过判断event.getAction() 获取到手势的不同动作，来完成你所重写的响应事件。重写onTouch方法，通过 event.getAction() 获取到的值，自动判断执行哪一个 case 中的代码，即通过监测不同的动作来对图形作出相应处理。我们的处理主要就是移动和缩放，通过event.getX、event.getY方法所获取的手势点击的屏幕坐标，计算图形的平移及缩放值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// 设置折线图的触摸事件，使扫描图保持同步平移和缩放 chartView.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View view, MotionEvent event) &#123; switch (event.getAction()) &#123; // 一根手指按下时 case MotionEvent.ACTION_DOWN: if (!mPopupWindow.isShowing()) &#123; //大图未显示时 // 双击扫描图跳转到大图 if (event.getEventTime() - chartView.getUpTime() &lt; 200) &#123; addToBigchartLayout(chartView); &#125; &#125; chartView.setxDown(event.getX()); chartView.setyDown(event.getY()); break; // 手指抬起时 case MotionEvent.ACTION_UP: chartView.setUpTime(event.getEventTime()); break; // 手指移动时 case MotionEvent.ACTION_MOVE: // 只有一根手指移动时 if (event.getPointerCount() == 1 &amp;&amp; event.getAction() != 261 &amp;&amp; chartView.getxDown() != 0 &amp;&amp; chartView.getyDown() != 0 ) &#123; // 实现图形平移 chartView.setxTranslate(chartView.getxTranslate()+(event.getX() - chartView.getxDown()) ); chartView.setyTranslate(chartView.getyTranslate()+(event.getY() - chartView.getyDown()) ); chartView.setxDown(event.getX()); chartView.setyDown(event.getY()); &#125; // 有两根手指移动时 else if (event.getPointerCount() == 2) &#123; // 实现扫描图缩放 double xLenMove = Math.abs(event.getX(0) - event.getX(1)); double yLenMove = Math.abs(event.getY(0) - event.getY(1)); double lenMove = Math.sqrt(xLenMove * xLenMove + yLenMove * yLenMove); // 动态更新 // 设置最小缩放比例为 0.4 if (chartView.getxScale() + (lenMove / chartView.getLenDown() - 1) &gt; 0.4) &#123; chartView.setxScale((float) (chartView.getxScale() + (lenMove / chartView.getLenDown() - 1))); chartView.setyScale((float) (chartView.getyScale() + (lenMove / chartView.getLenDown() - 1))); chartView.setLenDown(lenMove); &#125; chartView.setxDown(0); chartView.setyDown(0); &#125; break; // 有两根手指按下时 case 261: double xLenDown = Math.abs(event.getX(0) - event.getX(1)); double yLenDown = Math.abs(event.getY(0) - event.getY(1)); chartView.setLenDown(Math.sqrt(xLenDown * xLenDown + yLenDown * yLenDown)); break; // 两根手指中的一根抬起时 case MotionEvent.ACTION_POINTER_UP: chartView.setxDown(0); chartView.setyDown(0); break; default: break; &#125; chartView.postInvalidate(); //手势完成时重绘 scanView.setxTranslate(chartView.getxTranslate()); scanView.setxScale(chartView.getxScale()); scanView.postInvalidate(); // 只有当返回 false 时才会开启手势检测效果，否则折线图将无法移动和缩放 return false; &#125; &#125;); 最后通过计算的平移值以及缩放值，重绘图形。 完成以上步骤就可以在其它Activity中使用自己封装的对象来完成各种不同图形的绘制。如下是适配设备校准的绘图方法： 项目源码可见我的Github仓库漏磁检测系统。]]></content>
      <categories>
        <category>安卓学习</category>
      </categories>
      <tags>
        <tag>安卓</tag>
        <tag>漏磁检测</tag>
        <tag>Andriod</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[校准数据处理篇-漏磁检测]]></title>
    <url>%2F2017%2F12%2F04%2F%E6%A0%A1%E5%87%86%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%AF%87-%E6%BC%8F%E7%A3%81%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[优化校准数据处理问题描述： 校准模块通过正反方向两次校准。每次进行数据处理获取到该次校准四个梯度(20%、40%、60%、80%)的去噪值以及对应步长（X坐标），以便后续的曲线拟合。 处理方法1：（维护极大值间的顺序关系） 所有极大值按Y值（去噪值）排序。 根据最大的两个极大值点，计算x坐标满足的关系（x坐标递增或者递减），通过改关系以剔除错误数据。 选择最大的四个极大值 该方法的处理效果： 去噪值排序后，X轴也满足递增或者递减的顺序。可以排除当20%的缺陷去噪值小于其他区间的误差值。如下图： 上图阴影部分为可去噪的效果。在阴影部分出现的缺陷值都可以过滤掉。 缺点：当某些地方误差值过大时，可能掩盖真实缺陷比处的值。（A、C为真实缺陷百分比对应的值，而B点为错误值。因为B&gt;C而过滤掉C点） 处理方法2：（改进方法，x坐标之间间隔控制，同时维护间距） 所有极大值按Y值（去噪值）排序。 首先获取数据最大为80%缺陷对对应的去噪值，以此寻找第二个值，通过这两个值计算步数间隔。 继续计算下一个点的位置，在第二个点的基础上增加间隔internal，从该X坐标左右寻找存在的去噪值。 更新间隔internal,按此方法计算第四个满足条件的值。 若无满足的条件，依次选取第二大的去噪值为80%对应的缺陷值。重复2-4步骤。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148import com.tomatoLCJC.tools.Parameter.SystemParameter;import java.util.ArrayList;import java.util.Collections;import java.util.HashMap;import java.util.List;import java.util.Map;/** * Created by YCQ on 2017/10/10. */public class InstrumentCalibration &#123; private static double range = 0.1; //左右寻找10%的区域 通过修改这个确定精确度 /******************************************************************************************* * 函数名称：getMaximumValue * 函数介绍：获取曲线的极大值, 原理是:已知输入曲线有4个峰,该算法的思想就是求出这每个峰的起始x坐标和结束x坐标（即求出峰所在的区间） 然后在该区间中搜最大值从而求出极大值。 * 输入参数：order 表示第几次获取极大值 * 输出参数：无 * 返回值 ：无 ********************************************************************************************/ public static List&lt;Point&gt; getMaximumValue(List&lt;Double&gt; yValue) //获取极大值 &#123; List&lt;Point&gt; maxValue=new ArrayList&lt;&gt;(); double key = 10; //设置标记值为10（即认为从某个大于60的点开始到某个小于60的点结束为峰的区间）也可以为其他值，根据需要来定 int end = yValue.size(); List&lt;Integer&gt; xValue=new ArrayList&lt;&gt;(); //记录所有峰的起始坐标和结束坐标（就是记录所有峰的区间） int flag = 0; //信号量 因为算法要求记录峰值的起始和结束坐标，当某一点大于标记值key以后因为峰的单调递增性会有很多点也大于可以 //所以用flag标记当获取了第一个大于标记值key以后让程序不再记录x坐标直到条件再次满足 for (int i = 0; i &lt; end; ++i) //这是搜索峰的区间部分 &#123; if (key &lt; yValue.get(i) &amp;&amp; 0 == flag) &#123; xValue.add(i); flag = 1; &#125; if (key &gt; yValue.get(i) &amp;&amp; 1 == flag) &#123; xValue.add(i); flag = 0; &#125; &#125; xValue.add(end - 1); int length = xValue.size(); for (int i = 0; i &lt; length / 2; ++i) //根据区间搜索极大值 &#123; double temp = yValue.get(xValue.get(2*i)); int k = xValue.get(2*i) + 1; for (int j = k; j &lt; xValue.get(2*i+1); ++j) &#123; if (temp &lt; yValue.get(j)) &#123; temp = yValue.get(j); k = j; &#125; &#125; maxValue.add(new Point(k,Float.valueOf(String.valueOf(temp)))); &#125; Collections.sort(maxValue); //根据Y值 从大到小排序 if (maxValue.size()&lt;4) &#123; return maxValue; //极大值个数小于4，在后续过程会滤掉该情况，直接返回 &#125; else &#123;// return adjustOrder(maxValue); //第一种校准方法 return adjustOrder2(maxValue); //第二种校准方法 &#125; &#125; //第一种调整方法，根据递增和递减顺序 public static List&lt;Point&gt; adjustOrder(List&lt;Point&gt; value )&#123; List&lt;Point&gt; resValue=new ArrayList&lt;&gt;(); resValue.add(value.get(0)); //滤掉可能出现的错误 double flag_x = value.get(0).getX(); int flag_pOm = value.get(1).getX()-value.get(0).getX() &gt; 0 ? 1:-1; //设置正序标记 //剔除x非正序的Point for (int i=1;i&lt;value.size();i++)&#123; if ((value.get(i).getX()-flag_x &gt; 0 ? 1:-1)==flag_pOm)&#123; resValue.add(value.get(i)); flag_x = value.get(i).getX(); &#125; &#125; resValue = new ArrayList&lt;&gt;(resValue.subList(0 , Math.min(4,resValue.size()))); //size&gt;4时仅获取前四个值， return resValue; &#125; //第二种调整方法，根据递增和递减顺序 public static List&lt;Point&gt; adjustOrder2(List&lt;Point&gt; value )&#123; //x为步数，y为去噪值 Map&lt;Integer,Float&gt; map = new HashMap&lt;&gt;(); for (int i= 0;i&lt;value.size();i++)&#123; map.put((int) value.get(i).getX(), value.get(i).getY()); &#125; List&lt;Point&gt; resValue=new ArrayList&lt;&gt;(); for(int i=0;i&lt;4;i++) resValue.add(new Point(0.0f, 0.0f)); //初始化4个point int interval; //间隔 for (int i=0 ; i&lt;value.size()-4 ; i++)&#123; resValue.set(0,value.get(i)); //循环以此向后寻找一个最优的缺陷 80% for(int j=i+1;j&lt;value.size()-3; j++)&#123; resValue.set(1,value.get(j)); //60% interval = (int) (resValue.get(1).getX()-resValue.get(0).getX()); //80与60之间的间距（步数） for (int k=0;k&lt;Math.abs((int)(interval*range));k++)&#123; if (map.containsKey((int)(resValue.get(1).getX()+interval+k)) &amp;&amp; map.get((int)(resValue.get(1).getX()+interval+k)) &lt; resValue.get(1).getY())&#123; resValue.set(2,new Point((resValue.get(1).getX()+interval+k), map.get((int)(resValue.get(1).getX()+interval+k)))); int interval1= (((int) (resValue.get(2).getX()-resValue.get(1).getX()))+interval)/2; for (int m=0;m&lt;Math.abs((int)(interval1*range));m++)&#123; if (map.containsKey((int)(resValue.get(2).getX()+interval1+m)) &amp;&amp; map.get((int)(resValue.get(2).getX()+interval1+m)) &lt; resValue.get(2).getY())&#123; resValue.set(3,new Point((resValue.get(2).getX()+interval1+m), map.get((int)(resValue.get(2).getX()+interval1+m)))); return resValue; &#125; if (map.containsKey((int)(resValue.get(2).getX()+interval1-m)) &amp;&amp; map.get((int)(resValue.get(2).getX()+interval1-m)) &lt; resValue.get(2).getY())&#123; resValue.set(3,new Point((resValue.get(2).getX()+interval1-m), map.get((int)(resValue.get(2).getX()+interval1-m)))); return resValue; &#125; &#125; &#125; if (map.containsKey((int)(resValue.get(1).getX()+interval-k)) &amp;&amp; map.get((int)(resValue.get(1).getX()+interval-k)) &lt; resValue.get(1).getY() )&#123; resValue.set(2,new Point((resValue.get(1).getX()+interval-k), map.get((int)(resValue.get(1).getX()+interval-k)))); int interval1= (((int) (resValue.get(2).getX()-resValue.get(1).getX()))+interval)/2; for (int m=0;m&lt;Math.abs((int)(interval1*range));m++)&#123; if (map.containsKey((int)(resValue.get(2).getX()+interval1+m)) &amp;&amp; map.get((int)(resValue.get(2).getX()+interval1+m)) &lt; resValue.get(2).getY())&#123; resValue.set(3,new Point((resValue.get(2).getX()+interval1+m), map.get((int)(resValue.get(2).getX()+interval1+m)))); return resValue; &#125; if (map.containsKey((int)(resValue.get(2).getX()+interval1-m)) &amp;&amp; map.get((int)(resValue.get(2).getX()+interval1-m)) &lt; resValue.get(2).getY())&#123; resValue.set(3,new Point((resValue.get(2).getX()+interval1-m), map.get((int)(resValue.get(2).getX()+interval1-m)))); return resValue; &#125; &#125; &#125; &#125; &#125; &#125; return new ArrayList&lt;&gt;(); &#125; //list逆序 public static List&lt;Point&gt; invertedOrder(List&lt;Point&gt; value )&#123; List&lt;Point&gt; resValue = new ArrayList&lt;&gt;(); for (int i=1;i &lt;= value.size();i++)&#123; //从小到大排列，逆序填充 resValue.add(new Point( value.get(value.size()-i).getX()*(float) SystemParameter.getInstance().disSensorStepLen/1000 , value.get(value.size()-i).getY() )); &#125; return resValue; &#125;&#125;]]></content>
      <categories>
        <category>安卓学习</category>
      </categories>
      <tags>
        <tag>安卓</tag>
        <tag>漏磁检测</tag>
        <tag>Andriod</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python入门（1）]]></title>
    <url>%2F2017%2F11%2F07%2FPython%E5%85%A5%E9%97%A8%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[自学廖雪峰教程代码笔记通过自己在廖雪峰Python教程的学习，自己也尝试实现里面的一些基本语法，加强自己的理解，是学习一门语言最重要的部分！Python是一种解释型、面向对象、动态数据类型的高级程序设计语言。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355# -*- coding: utf-8 -*-L = [ ['Apple', 'Google', 'Microsoft'], ['Java', 'Python', 'Ruby', 'PHP'], ['Adam', 'Bart', 'Lisa']]# 打印Apple:print(L[0][0])# 打印Python:print(L[1][1])# 打印Lisa:print(L[2][2])print('') # python每次输出默认为一行，print('') 相当于换行# 条件判断height = 1.75weight = 80.5bmi = weight / (height * height)if bmi &lt; 18.5: print('过轻')elif bmi &lt; 25: print('正常')elif bmi &lt; 28: print('过重')elif bmi &lt; 32: print('肥胖')else: print('严重肥胖')print('')# 循环计算高斯公式，range的使用sum = 0# for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:for x in range(11): # 生成0-10的11个整数 sum = sum + xprint(sum)print('')# List的使用L = ['Bart', 'Lisa', 'Adam']for x in L: print('Hello,', x)print('')# 循环n = 1while n &lt;= 20: if n == 5: n = n + 1 # while循环，+1运算在循环尾，此处需要加1，才可保证 continue if n &gt; 10: # 当n = 11时，条件满足，执行break语句 break # break语句会结束当前循环 print(n) n = n + 1print('END')print('')# list的特点：# 1.查找和插入的时间随着元素的增加而增加；# 2.占用空间小，浪费内存很少。# dict（字典-相当于map）的特点：(以空间换时间)# 1.查找和插入的速度极快，不会随着key的增加而变慢；# 2.需要占用大量的内存，内存浪费多d = &#123;'Michael': 95, 'Bob': 75, 'Tracy': 85&#125;print(d['Bob'])print('')# set可以看成数学意义上的无序和无重复元素的集合s = set([1, 1, 2, 2, 3, 3]) # 重复数据自动过滤掉for x in s: print(x)print('')s = set((1, 2, 3)) # 将元组赋给setfor x in s: print(x)print('')# s = set((1,[2,3])) # 不可以将tuple(不可变对象)赋给set# for x in s:# print(x)# print('')# python内置函数n1 = 255n2 = 1000print(hex(n1))print(hex(n2))print('')def my_abs(x): if x &gt;= 0: return x else: return -xx = -20print(my_abs(x))print('')def power(x, n=2): # x为必选参数，n为默认参数 s = 1 while n &gt; 0: n = n - 1 s = s * x return sprint(power(5))print(power(5, 3))print('')def enroll(name, gender, age=6, city='Beijing'): print('name:', name) print('gender:', gender) print('age:', age) print('city:', city)enroll('Yang', 'A', 18)print('-------------')enroll('Chen', 'B', city='wuhan') # 当不按顺序提供部分默认参数时，需要把参数名写上print('')def add_end(L=[]): # 默认参数L也是一个变量，它指向对象[] L.append('END') print(L)add_end([1, 2, 3])add_end() # ['END']add_end() # ['END', 'END']print('')def add_end_1(L=None): # 默认参数必须指向不变对象！ None为不变对象 if L is None: L = [] L.append('END') print(L)add_end_1()add_end_1()print('')# 可变参数 (可变参数在函数调用时自动组装为一个tuple元组)def calc(*numbers): sum = 0 for n in numbers: sum = sum + n * n return sumprint(calc(1, 2, 3, 4))print('')# 关键字参数 （关键字参数在函数内部自动组装为一个dict字典） 作用：可以扩展函数的功能def person(name, age, **kw): print('name:', name, 'age:', age, 'other:', kw)person('Adam', 45, gender='M', job='Engineer')print('')extra = &#123;'city': 'Beijing', 'job': 'Engineer'&#125;person('Jack', 24, **extra) # **kw关键字参数获取到extra字典（dict）的一个拷贝print('')# 必选参数、默认参数、可变参数、关键字参数和命名关键字参数的参数组合def f1(a, b, c=0, *args, **kw): print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw)def f2(a, b, c=0, *, d, **kw): # * 后面的参数被视为命名关键字参数 print('a =', a, 'b =', b, 'c =', c, 'd =', d, 'kw =', kw)f1(1, 2)f1(1, 2, c=3)f1(1, 2, 3, 'a', 'b') # （'a', 'b'）可变参数f1(1, 2, 3, 'a', 'b', x=99)f2(1, 2, d=99, ext=None)print('')# 递归函数 与尾递归（在函数返回的时候，调用自身本身，并且return语句不能包含表达式）# 计算n的阶乘def fact(n): if n == 1: return 1 return n * fact(n - 1)print(fact(100))print('')# 上述递归中，如果调用次数过多就会出现栈溢出。 解决方法就是使用尾递归。def fact_back(n): return fact_iter(n, 1)def fact_iter(num, product): if num == 1: return product return fact_iter(num - 1, num * product) # 每次递归时就把该次结果作为参数传递给下一轮循环print(fact_back(100))print('')# 切片的使用L = list(range(100))print(L)print('')# 切片的三个参数的意义：1.首位置 2.末尾置 3.每n一取 [ )左闭右开区间print(L[:10])print(L[-10:])print(L[10:20])print(L[:10:2])print(L[::5])print('')# 迭代器 可迭代对象有：字符串、list、tuple(元组)、dict、setfor ch in 'ABC': print(ch)print('')for i, value in enumerate(['A', 'B', 'C']): # enumerate把一个list变成索引-元素对 print(i, value)print('')for x, y in [(1, 1), (2, 4), (3, 9)]: # 两个变量的迭代 print(x, y)print('')# 列表生成器print(list(range(1, 11))) # 生成1-10的list，左闭右开print('')print([x * x for x in range(1, 11) if x % 2 == 0]) # 生成1-10之间偶数的平方print('')print([m + n for m in 'ABC' for n in 'XYZ']) # 两层循环生成全排列print('')import os # 导入os模块，模块的概念后面讲到print([d for d in os.listdir('.')]) # [] 生成listprint('')d = &#123;'x': 'A', 'y': 'B', 'z': 'C'&#125; # dictprint([k + '=' + v for k, v in d.items()]) # 使用两个变量来生成listprint('')L1 = ['Hello', 'World', 18, 'Apple', None]print(L1)print('')L2 = [s.lower() for s in L1 if isinstance(s, str)] # 如果s为字符串，则转换为小写生成列表print(L2)print('')# 生成器：generator。 （用于一边循环一边推到下一个值）g = (x * x for x in range(10))print(g) # 输出：&lt;generator object &lt;genexpr&gt; at 0x0000009576A0A4C0&gt;# next(g) 使用生成器生成下一个元素的值print('')for n in g: print(n)print('')def fib(max): # 斐波纳契数列 n, a, b = 0, 0, 1 # 变量初始化，相当于 n=0;a=0;b=1 while n &lt; max: print(b) a, b = b, a + b n = n + 1 return 'done'print(fib(6))print('')def fibonacci(max): n, a, b = 0, 0, 1 while n &lt; max: yield b # 每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行 a, b = b, a + b n = n + 1 return 'done'g = fibonacci(6)print(next(g))print(next(g))print(next(g))print(g)print('')while True: # 必须捕获StopIteration错误，才可以获取到fibonacci（）的返回值 try: x = next(g) print('g:', x) except StopIteration as e: print('Generator return value:', e.value) breakprint('')# 杨辉三角，生成器写法def triangles(): L = [1] while True: yield L L.insert(0, 0) #首尾添加一个0，便于循环计算 L.append(0) L = [L[i] + L[i + 1] for i in range(len(L)-1)]n=0for t in triangles(): print(t) n = n + 1 if n == 10: breakprint('')# 迭代器# 可迭代对象（Iterable） （特点：可直接作用于for循环的）# 1.集合数据类型，如list、tuple、dict、set、str等；# 2.generator，包括生成器和带yield的generator function# 迭代器（Iterator）对象：生成器# list、tuple、dict、set、str可以通过iter()返回Iterator对象from collections import Iterableprint(isinstance([], Iterable))print('')from collections import Iteratorprint(isinstance([], Iterator))print(isinstance(iter([]), Iterator)) 身边有许多人都赶上AI学习的浪潮，我还是想努力做好一件事，在学习之余，自己看了看python，对这门语言很是好奇！很想先接触一下，虽然对python以后的方向并不是很清楚，适当扩展扩展自己的知识面也是灰常重要的！]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[static虽好，可不要滥用]]></title>
    <url>%2F2017%2F10%2F30%2Fstatic%E8%99%BD%E5%A5%BD%EF%BC%8C%E5%8F%AF%E4%B8%8D%E8%A6%81%E6%BB%A5%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Java中static作用详解 在自己的项目中已经两次入了static的坑，正如title所讲，static虽好但是请别滥用。 static表示”静态”、”全局”的意思，可以修饰成员变量、方法，以及静态代码块，一下列举几种常用的static用法： 静态域（静态变量）如果将类中的域定义为static，那么所有该类的对象共享这一个静态域。域分为实例域与静态域。静态域属于类而不属于任何一个独立的对象。 这也是我做项目是出现问题的所在，因为静态域可以更方便的访问，直接使用类名.静态域就可以轻松的访问，而忽略该类所有对象共用这一个域导致初始化出现遗漏。第一次是在图表类ChartService中将通道数设置为了静态变量，因为纵向梯度曲线比原始数据曲线数量少1，而导致原始数据数据集与数据渲染器初始化少了1，无法显示完整的曲线。第二次在读数据线程中，将暂停的flag设置为了静态变量，导致后面继续测量无法获取到数据，而调试了好久。 静态常量（使用比静态变量多）比如Math类中定义到： 12345public class Math&#123; ... public static final double PI = 3.14159265358979323846; ...&#125; 然后就可以通过Math.PI的形式访问。另外我们输出经常会用到System.out，它其实也是一个静态常量 1public static final PrintStream out = ...; 但是Syetem类中却有一个setOut的方法，并且可以将System.out设置为不同的流。原因是setOut是一个本地方法，而不是通过java语言实现，本地方法可以绕过java语言的存取控制机制。 静态方法静态方法是一种不能向对象实施操作的方法。Math.pow(x,a)计算x的a次方。静态方法是没有this参数的方法。静态方法不能访问实例域（静态方法不能操作对象），只能访问自身类中的静态域。 4.静态代码块 123static &#123; ...&#125; 静态代码块在类中独立于类成员，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。执行顺序先于构造函数。]]></content>
      <categories>
        <category>安卓学习</category>
      </categories>
      <tags>
        <tag>安卓</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A New Begining]]></title>
    <url>%2F2017%2F09%2F23%2FA-New-Begining%2F</url>
    <content type="text"><![CDATA[许久没有更新博客了… 开学已经好久，上一次更新还是两个月前，都说坚持一件事情很难，果不其然。总是找各种理由（借口）不想写。大三学期已经开始三周了，除了上课感觉自己还是不知道该做些什么，浑浑噩噩，想学点东西，做点东西，却又不知道从何开始。不想考研，可是自己的能力却又远远不够。想学的东西很多，还是得静下心来，好好完成一件事。一步一个脚印。 坚持一个有规划的大学生活 学好java，从项目中多学习经验与技巧 感觉设计模式是一门很有用的课，对以后项目开发都很有用，学好设计模式 坚持早起，有时间就去去图书馆、实验室。 计算机网络还挺有意思，老师讲的还挺好 上课得提高效率，平时多做做感兴趣的事情 想学算法，期待和大神一样的厉害 想接触人工智能，机器学习，等等。。。 总之，好多好多…… 突然想起一句话，想的太多，做的太少。好像用来描述此时的我，太合适不过了。还不如选定一个小小的方向，努力去做好一件事情，坚持下去。我想收获会更多，你是否也这样觉得？]]></content>
      <categories>
        <category>每日一记</category>
      </categories>
      <tags>
        <tag>心情</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DatePicker与TimePicker的使用]]></title>
    <url>%2F2017%2F07%2F20%2FDatePicker%E4%B8%8ETimePicker%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[安卓系统DatePicker与TimePicker的妙用 其实安卓系统自带的DatePicker和TimePicker的界面都已经很好看啦~可以直接拿过来直接用，当然也可以自定义。 它们可以直接以界面的形式显示，也可以用new DatePickerDialog()的方法以弹框的形式显示，使用特别方便。不信？你看~ main.xml:定义一个需要用到的Datepicker和TimePicker，首先然后先设置visibility为gone，我想通过按钮来实现它们的显示效果，而不会两个同时显示时，无法完全显示在界面上。12345678910111213&lt;DatePicker android:id=&quot;@+id/datePicker&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;0dp&quot; android:visibility=&quot;gone&quot; android:layout_weight=&quot;1&quot; /&gt; &lt;TimePicker android:id=&quot;@+id/timePicker&quot; android:layout_width=&quot;match_parent&quot; android:visibility=&quot;gone&quot; android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;1&quot; /&gt; MainActivity.java类：添加四个按钮，分别实现不同的点击事件（事件的监听，三种方法：1.匿名内部类 2.在MainActivity类中实现 View.OnClickListener接口，3.自定义监听类，实现接口），完成TimePicker、DatePicker以及它们的弹框形式的分别显示。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143package com.example.datetimepicker;import android.app.DatePickerDialog;import android.app.TimePickerDialog;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.DatePicker;import android.widget.TimePicker;import java.util.Calendar;public class MainActivity extends AppCompatActivity implements View.OnClickListener&#123; private TimePicker timePicker; private DatePicker datePicker; private Calendar calendar; private int year; private int month; private int day; private int hour; private int minute; private Button timeBtn; private Button dateBtn; private Button timeBtnDia; private Button dateBtnDia; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); timeBtn= (Button) findViewById(R.id.timePickerBtn); dateBtn= (Button) findViewById(R.id.datePickerBtn); timeBtnDia= (Button) findViewById(R.id.timePickerDia); dateBtnDia= (Button) findViewById(R.id.datePickerDia); //获取日历对象 calendar=Calendar.getInstance(); //获取年月日时分秒的信息 year=calendar.get(Calendar.YEAR); month=calendar.get(Calendar.MONTH)+1; //Calendar.MONTH获取的月份从0开始 day=calendar.get(Calendar.DAY_OF_MONTH); hour=calendar.get(Calendar.HOUR_OF_DAY); minute=calendar.get(Calendar.MINUTE); setTitle(year+&quot;-&quot;+month+&quot;-&quot;+day+&quot; &quot;+hour+&quot;:&quot;+minute); datePicker= (DatePicker) findViewById(R.id.datePicker); timePicker= (TimePicker) findViewById(R.id.timePicker); //datePicker的初始化日期Picker的年月日初始值 datePicker.init(year, month-1, day, new DatePicker.OnDateChangedListener() &#123; @Override public void onDateChanged(DatePicker datePicker, int i, int i1, int i2) &#123; setTitle(i+&quot;-&quot;+(i1+1)+&quot;-&quot;+i2); &#125; &#125;); timePicker.setOnTimeChangedListener(new TimePicker.OnTimeChangedListener() &#123; @Override public void onTimeChanged(TimePicker timePicker, int i, int i1) &#123; setTitle(i+&quot;:&quot;+i1); &#125; &#125;); //添加监听，在MainActivity中，直接添加this timeBtn.setOnClickListener(this); timeBtnDia.setOnClickListener(this); dateBtn.setOnClickListener(this); dateBtnDia.setOnClickListener(this); //使用匿名内部类的方法实现监听 //initEvent(); &#125; public void showDatePickerDialog()&#123; new DatePickerDialog(this, new DatePickerDialog.OnDateSetListener() &#123; @Override public void onDateSet(DatePicker datePicker, int i, int i1, int i2) &#123; setTitle(i+&quot;-&quot;+(i1+1)+&quot;-&quot;+i2); &#125; &#125;,year,month-1,day).show(); &#125; public void showTimePickerDialog()&#123; new TimePickerDialog(this, new TimePickerDialog.OnTimeSetListener() &#123; @Override public void onTimeSet(TimePicker timePicker, int i, int i1) &#123; setTitle(i+&quot;:&quot;+i1); &#125; &#125;,hour,minute,true).show(); &#125; @Override public void onClick(View view) &#123; switch (view.getId())&#123; case R.id.datePickerBtn: datePicker.setVisibility(View.VISIBLE); timePicker.setVisibility(View.GONE); break; case R.id.timePickerBtn: datePicker.setVisibility(View.GONE); timePicker.setVisibility(View.VISIBLE); break; case R.id.timePickerDia: showTimePickerDialog(); break; case R.id.datePickerDia: showDatePickerDialog(); break; &#125; &#125; public void initEvent()&#123; dateBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; datePicker.setVisibility(View.VISIBLE); timePicker.setVisibility(View.GONE); &#125; &#125;); timeBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; datePicker.setVisibility(View.GONE); timePicker.setVisibility(View.VISIBLE); &#125; &#125;); dateBtnDia.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; showDatePickerDialog(); &#125; &#125;); timeBtnDia.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; showTimePickerDialog(); &#125; &#125;); &#125;&#125; 注意事项： 最后的显示效果：]]></content>
      <categories>
        <category>安卓学习</category>
      </categories>
      <tags>
        <tag>andriod</tag>
        <tag>安卓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndriodManifest.xml配置]]></title>
    <url>%2F2017%2F07%2F19%2FAndriodManifest-xml%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[AndriodManifest的配置基础1.全局篇应用的包名以及版本信息，控制安卓的版本信息。 2.组件篇（四大组件） Activity(活动) ：启动一个没有在清单中定义的Activity会抛出异常 Service(服务) ：做为后台运行的一个逻辑代码的处理 Content Provider(内容提供者) ：是用来管理数据库访问以及程序内和程序间共享的 Broadcast Receiver(广播接收者) 其属性可以设置：图标：android:icon标题：android:label主题样式：android:theme注意：只能包含一个application节点 3.权限篇 申请系统权限自定义权限，限制其它应用使用该应用的效果。123456789&lt;permission andriod:name=&quot;com.example.test&quot; andriod:protectionLevel=&quot;normal&quot;&gt;&lt;/permission&gt;&lt;activity andriod:permission=&quot;com.example.test&quot; .... &gt; 然后在其他应用中若希望调用该应用则必须声明权限：1&lt;uses-permission andriod:name=&quot;com.example.test&quot;&gt; ListView的使用数据适配器：纯文字使用ArrayAdapter,有图片有文字又复杂的一系列内容的用SimpleAdapter.1.ArrayAdapter(context, 当前listview加载的每一个列表项所对应的布局文件，数据源)2.SimpleAdapter( context, data , resource , from ,to )：context：上下文data：数据源（List&lt;? extends Map&gt; data）一个由Map组成的List合集 每一个Map都对应ListView列表中的一行 每一个Map（键-值对）中的键都必须包含所有在from中所指定的键resource：列表项的布局文件IDfrom：Map中的键名to：绑定数据视图中的ID，与from成对应关系。监听器：]]></content>
      <categories>
        <category>安卓学习</category>
      </categories>
      <tags>
        <tag>andriod</tag>
        <tag>安卓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓自定义控件]]></title>
    <url>%2F2017%2F07%2F17%2F%E5%AE%89%E5%8D%93%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[自定义UI组件 许久没有更新自己的博客了，感觉这些天，并没有做什么额。想想接下来这些时间还是多学习学习安卓的基础，多花时间尝试做一些小Demo。 昨天，跟着网易云课堂自己做了一个自定义UI控件的小例子，分为以下三个步骤： 1.设计需要的属性： 新建一个attrs.xml文件声明以下内容 12345678910111213141516171819202122232425262728 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;declare-styleable name=&quot;Topbar&quot;&gt; &lt;!--自定义属性--&gt; &lt;!--中间的标题--&gt; &lt;attr name=&quot;title&quot; format=&quot;string&quot; /&gt; &lt;attr name=&quot;titleTextSize&quot; format=&quot;dimension&quot; /&gt; &lt;attr name=&quot;titleTextColor&quot; format=&quot;color&quot; /&gt; &lt;!--左边的按钮--&gt; &lt;attr name=&quot;leftTextColor&quot; format=&quot;color&quot;/&gt; &lt;attr name=&quot;leftTextSize&quot; format=&quot;dimension&quot;/&gt; &lt;attr name=&quot;leftText&quot; format=&quot;string&quot;/&gt; &lt;attr name=&quot;leftBackground&quot; format=&quot;color|reference&quot;/&gt; &lt;!--右边的按钮--&gt; &lt;attr name=&quot;rightTextColor&quot; format=&quot;color&quot;/&gt; &lt;attr name=&quot;rightTextSize&quot; format=&quot;dimension&quot;/&gt; &lt;attr name=&quot;rightText&quot; format=&quot;string&quot;/&gt; &lt;attr name=&quot;rightBackground&quot; format=&quot;color|reference&quot;/&gt; &lt;/declare-styleable&gt; &lt;!--&quot;reference&quot; //引用--&gt; &lt;!--&quot;color&quot; //颜色--&gt; &lt;!--&quot;boolean&quot; //布尔值--&gt; &lt;!--&quot;dimension&quot; //尺寸值--&gt; &lt;!--&quot;float&quot; //浮点值--&gt; &lt;!--&quot;integer&quot; //整型值--&gt; &lt;!--&quot;string&quot; //字符串--&gt; &lt;!--&quot;fraction&quot; //百分数,比如20%--&gt;&lt;/resources&gt; 2.实现一个我们的自定义View 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136package com.example.topbardemo;import android.content.Context;import android.content.res.TypedArray;import android.graphics.Color;import android.graphics.drawable.Drawable;import android.support.annotation.Dimension;import android.util.AttributeSet;import android.view.View;import android.view.ViewGroup;import android.widget.Button;import android.widget.RelativeLayout;import android.widget.TextView;public class Topbar extends RelativeLayout&#123; //自定义控件中的组件 private Button leftButton,rightButton; private TextView tvTitle; //各组件的属性 private String title; private float titleTextSize; private int titleTextColor; private int leftButtonColor; private String leftText; private Drawable leftBack; private float leftTextSize; private int rightButtonColor; private String rightText; private Drawable rightBack; private float rightTextSize; private LayoutParams leftParam,rightParam,titleParam; private topbarClickListener listener; public interface topbarClickListener&#123; void leftClick(); void rightClick(); &#125; //接口回调机制，实现组件的事件 public void setTopbarClickListener(topbarClickListener listener)&#123; this.listener=listener; &#125; public Topbar(Context context, AttributeSet attrs) &#123; super(context, attrs); //引用自定义的属性name TypedArray typedArray = context.obtainStyledAttributes(attrs,R.styleable.Topbar); //获取到自定义的各个属性 title=typedArray.getString(R.styleable.Topbar_title); titleTextColor=typedArray.getColor(R.styleable.Topbar_titleTextColor,0); titleTextSize=typedArray.getDimension(R.styleable.Topbar_titleTextSize,1); leftText = typedArray.getString(R.styleable.Topbar_leftText); leftButtonColor = typedArray.getColor(R.styleable.Topbar_leftTextColor,0); leftTextSize = typedArray.getDimension(R.styleable.Topbar_leftTextSize,1); leftBack = typedArray.getDrawable(R.styleable.Topbar_leftBackground); rightText = typedArray.getString(R.styleable.Topbar_rightText); rightButtonColor = typedArray.getColor(R.styleable.Topbar_rightTextColor,0); rightTextSize = typedArray.getDimension(R.styleable.Topbar_rightTextSize,1); rightBack = typedArray.getDrawable(R.styleable.Topbar_rightBackground); //调用结束后务必调用recycle()方法，否则这次的设定会对下次的使用造成影响 typedArray.recycle(); //定义各个组件 leftButton= new Button(context); rightButton = new Button(context); tvTitle =new TextView(context); //为组件添加属性 leftButton.setText(leftText); leftButton.setTextColor(leftButtonColor); leftButton.setTextSize(leftTextSize); leftButton.setBackground(leftBack); rightButton.setText(rightText); rightButton.setTextColor(rightButtonColor); rightButton.setTextSize(rightTextSize); rightButton.setBackground(rightBack); tvTitle.setText(title); tvTitle.setTextColor(titleTextColor); tvTitle.setTextSize(titleTextSize); setBackgroundColor(0xFFF1233); //布局参数样式 leftParam = new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,LayoutParams.WRAP_CONTENT); leftParam.addRule(RelativeLayout.ALIGN_PARENT_LEFT,TRUE); //组件以leftParam样式添加到View中 addView(leftButton,leftParam); rightParam = new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,LayoutParams.WRAP_CONTENT); rightParam.addRule(RelativeLayout.ALIGN_PARENT_RIGHT,TRUE); addView(rightButton,rightParam); titleParam = new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,LayoutParams.WRAP_CONTENT); titleParam.addRule(RelativeLayout.CENTER_IN_PARENT,TRUE); addView(tvTitle,titleParam); //组件的点击事件 leftButton.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View view) &#123; listener.leftClick(); &#125; &#125;); rightButton.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View view) &#123; listener.rightClick(); &#125; &#125;); &#125; //其他事件的完善 public void setLeftButtonVisable(boolean flag)&#123; if (flag)&#123; leftButton.setVisibility(VISIBLE); &#125;else &#123; leftButton.setVisibility(GONE); &#125; &#125;&#125; 3.引用我们的View 在activity_main.xml中引入xmlns:custom=&quot;http://schemas.android.com/apk/res-auto&quot;声明引用的组件并设置属性值 123456789101112131415&lt;com.example.topbardemo.Topbar android:id=&quot;@+id/topbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;50dp&quot; custom:leftText=&quot;Left&quot; custom:leftTextColor=&quot;@color/colorPrimaryDark&quot; custom:leftTextSize=&quot;8sp&quot; custom:rightText=&quot;Right&quot; custom:rightTextColor=&quot;@color/colorPrimaryDark&quot; custom:rightTextSize=&quot;8sp&quot; custom:title=&quot;自定义标题&quot; custom:titleTextColor=&quot;@color/colorAccent&quot; custom:titleTextSize=&quot;10sp&quot; &gt; &lt;/com.example.topbardemo.Topbar&gt; 在Activity中定义各个组件的事件。1234567891011121314151617181920topbar= (Topbar) findViewById(R.id.topbar); topbar.setTopbarClickListener(new Topbar.topbarClickListener() &#123; @Override public void leftClick() &#123; Toast.makeText(getApplicationContext(),&quot;Left&quot;,Toast.LENGTH_SHORT).show(); &#125; @Override public void rightClick() &#123; Toast.makeText(getApplicationContext(),&quot;Right&quot;,Toast.LENGTH_SHORT).show(); &#125; &#125;); button = (Button) findViewById(R.id.button1); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; topbar.setLeftButtonVisable(false); &#125; &#125;); 最后的完成的效果：]]></content>
      <categories>
        <category>安卓学习</category>
      </categories>
      <tags>
        <tag>安卓</tag>
        <tag>自定义控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓学习之2048]]></title>
    <url>%2F2017%2F07%2F07%2F%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0%E4%B9%8B2048%2F</url>
    <content type="text"><![CDATA[一个叫做2048的小游戏 许久未更新我的博客了，只是因为，这几天觉得并没有什么好写的，好记录下来的。有时候只是学习到编码中的一点点小技巧，大多也是自己通过在网上学习，自己敲代码所总结出来的。可能是自己做的不多吧。 这两天重新把自己开始接触安卓时想做的一个小游戏继续完善了一下，两个月之后回头再看看自己当时的代码，还是学的有许多许多需要去改进的地方，这也说明我还是不断的在学习^ - ^。 以前直接将每一种方块看成图片，然后自己做2~2048的图片，以图片的形式填充到每一个ImageView中，现在则是以TextView形式，动态设置每一方块的数字以及背景色。这样使得游戏占得空间小多啦，这也是网上所推荐的方法。 12345678910111213141516171819202122232425262728private LinearLayout layout; private Button mainMenu; private Button btnReset; private Button btnUp; private TextView textScore; private TextView textBestScore; private int[][] oldFlag = new int[4][4]; private static int score = 0; private static int best_score=0; //触摸事件手指按下和松开的两个坐标 private float x1 = 0; private float x2 = 0; private float y1 = 0; private float y2 = 0; //16个方块的id static int[][] btnBlock = &#123; &#123;R.id.btn00, R.id.btn01, R.id.btn02, R.id.btn03&#125;, &#123;R.id.btn10, R.id.btn11, R.id.btn12, R.id.btn13&#125;, &#123;R.id.btn20, R.id.btn21, R.id.btn22, R.id.btn23&#125;, &#123;R.id.btn30, R.id.btn31, R.id.btn32, R.id.btn33&#125; &#125;; //16个方块的对应的值 static int[][] flag = &#123; &#123;0, 0, 0, 0&#125;, &#123;0, 0, 0, 0&#125;, &#123;0, 0, 0, 0&#125;, &#123;0, 0, 0, 0&#125; &#125;; 以二维数组的形式存储每一个方块对应的值，然后根据方块中的值，来动态绘制每一个方块的数字以及背景色。123456789101112131415161718192021222324252627282930//手势滑动 @TargetApi(Build.VERSION_CODES.M) @Override public boolean onTouch(View v, MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: x1 = event.getX(); y1 = event.getY(); break; case MotionEvent.ACTION_MOVE: x2 = event.getX(); y2 = event.getY(); break; case MotionEvent.ACTION_UP: if (x2 - x1 &gt; 50 &amp;&amp; Math.abs(x2 - x1) &gt; Math.abs(y2 - y1)) &#123;// Toast.makeText(this,&quot;向右滑动&quot;,Toast.LENGTH_SHORT).show(); moveToRight(); &#125; else if (x1 - x2 &gt; 50 &amp;&amp; Math.abs(x2 - x1) &gt; Math.abs(y2 - y1)) &#123;// Toast.makeText(this,&quot;向左滑动&quot;,Toast.LENGTH_SHORT).show(); moveToLeft(); &#125; else if (y2 - y1 &gt; 50 &amp;&amp; Math.abs(x2 - x1) &lt; Math.abs(y2 - y1)) &#123;// Toast.makeText(this,&quot;向下滑动&quot;,Toast.LENGTH_SHORT).show(); moveToBottom(); &#125; else if (y1 - y2 &gt; 50 &amp;&amp; Math.abs(x2 - x1) &lt; Math.abs(y2 - y1)) &#123;// Toast.makeText(this,&quot;向上滑动&quot;,Toast.LENGTH_SHORT).show(); moveToUp(); &#125; &#125; return true; &#125; 重写触摸事件，按下的时候记录当前的坐标，手指滑动时记录手指所在坐标。滑动结束时（也就是手指放开时），计算坐标之间的变化来判断手势的滑动方向以进行方块的滑动。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//向右滑动 public void moveToRight() &#123; for (int i = 0; i &lt; 16; i++) &#123; oldFlag[i / 4][i % 4] = flag[i / 4][i % 4]; &#125; for (int j = 0; j &lt; 4; j++) &#123; ArrayList&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 4; i++) &#123; if (flag[j][3 - i] != 0) &#123; list1.add(flag[j][3 - i]); &#125; &#125; ArrayList&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); int i = 0; for (i = 0; i &lt; list1.size() - 1; i++) &#123; if (list1.get(i) == 2048)&#123; &#125;else if (list1.get(i) == list1.get(i + 1)) &#123; temp.add(list1.get(i) * 2); score += list1.get(i) * 2; i++; &#125; else &#123; temp.add(list1.get(i)); &#125; &#125; if (i == list1.size() - 1) &#123; temp.add(list1.get(i)); &#125; if (list1.size() &gt; 1) &#123; list1 = temp; &#125; for (i = 0; i &lt; list1.size(); i++) &#123; flag[j][3 - i] = list1.get(i); fillBlock(list1.get(i), j, 3 - i); &#125; for (i = list1.size(); i &lt; 4; i++) &#123; flag[j][3 - i] = 0; fillBlock(0, j, 3 - i); &#125; &#125; //判断是否变化 boolean isNext = false; for (int i = 0; i &lt; 16; i++) &#123; if (oldFlag[i / 4][i % 4] != flag[i / 4][i % 4]) &#123; isNext = true; break; &#125; &#125; if (isNext) &#123; nextBlock(); &#125; else if (isGameOver()) &#123; Toast.makeText(MainActivity.this, &quot;GAME OVER&quot;, Toast.LENGTH_SHORT); reset(); //重新开始 &#125; &#125; 首先记录滑动之前的二维数组（1.判断此次滑动时候有方块变化，2.便于返回上一步），然后根据手势滑动所得的方向，将方块中的值依次添加到四个List，接下来遍历一遍，如果当前list.get(i)与list.get(i+1)相等，则两个数据合并，保存到一个temp的List中。最后将temp中的值一次填到二维数组的对应位置中去。 最后将方块显示出来，通过设置每一个方块的数字以及背景色。（这里还是差一个动画的效果，就更完美了！） 还有最高的记录，是用的安卓的SharedPreferences存储，以XML标签的形式将数据保存与本地手机上。每次打开游戏的时候，初始化界面的时候从score_data.xml文件中读取到对应的最高分。 12345678//保存数据 public void saveBest_score(Score score)&#123; SharedPreferences.Editor editor =getApplicationContext().getSharedPreferences(&quot;score_data&quot;, Context.MODE_PRIVATE).edit(); editor.putString(&quot;name&quot;,score.getName()); editor.putInt(&quot;score&quot;,score.getScore()); editor.putString(&quot;time&quot;,score.getTime()); editor.commit(); &#125; 我的2048游戏源码]]></content>
      <categories>
        <category>安卓学习</category>
      </categories>
      <tags>
        <tag>andriod</tag>
        <tag>安卓</tag>
        <tag>2048</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JNI（java 本地接口）开发]]></title>
    <url>%2F2017%2F07%2F02%2FJNI%EF%BC%88java-%E6%9C%AC%E5%9C%B0%E6%8E%A5%E5%8F%A3%EF%BC%89%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[JNI开发之NDK环境搭建 首先得先说说JNI是什么，Java Native Interface(java本地接口)的缩写，主要是实现Java与其他语言的通信（主要是C，C++）。当实际项目中一些接口并不支持java安卓的时候，就得靠自己进行封装，来达到目的。缺点是java与本地以编译好的代码交互，可能会丧失平台可移植性，另外程序安全性降低使用不当可能是整个程序崩溃，使用时尽量降低语言之间的耦合性。开发JNI项目前提是需要有NDK（Native Development Kit）的支持。因此，在开发前需要先安装和配置NDK。推荐一个NDK安装教程 对于windows系统依然适用。 1.项目配置文件gradle.properties中添加 1android.useDeprecatedNdk=true 2.local.properties文件添加：（如果是在AS-&gt;SDK Manager-&gt;Appearance&amp;Behavior-&gt;System Settings-&gt;Andriod SDK-&gt;SDK Tools安装，会自动配置） ndk.dir=NDK的路径3.打开模块的build.gradle文件，在android/defaultConfig下面添加ndk节点，如下所示：12345ndk &#123; moduleName &quot;JNIDemo&quot; stl &quot;stlport_static&quot; ldLibs &quot;log&quot; &#125; 4.创建JNIUtil类，声明本地方法。编译后在Terminal终端面板中定位到cd app/build/intermediates/classes/debug/ 执行javah 包名.JNIUtil（JNIUtil是刚刚定义的类名）执行成功之后会在刚刚的debug目录下生成一个.h的头文件（文件名为:Java.类名.包名.h(‘.’换成’_‘)）。5.在app目录下新建JNI目录，拷贝第四步生成的.h文件，再创建一个.cpp文件实现头文件中的方法。6.ok~ 编译运行。完美~]]></content>
      <categories>
        <category>安卓学习</category>
      </categories>
      <tags>
        <tag>安卓</tag>
        <tag>NDK</tag>
        <tag>JNI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[又见周末...]]></title>
    <url>%2F2017%2F07%2F02%2F%E5%8F%88%E8%A7%81%E5%91%A8%E6%9C%AB%2F</url>
    <content type="text"><![CDATA[一周过去了… 回想起这周做的事情，感觉并不是很满意。差不多也花了两天时间，各种找如何用github+hexo搭建博客，一步一步尝试，最后达到了现在的效果，感觉还是挺不错的效果。很喜欢这个网页！希望自己可以坚持做好这件事情，尽量把每天每周做的事情都写下来，一是总结自己所做的事情，规划自己的时间，二是也可以记录一些学习中遇到的问题，解决技巧等等。 下一周，多看看安卓的基础，感觉很多事还是得从基础做起。另外学习学习JNI（java 本地接口）的开发。 下图为如何上传本地项目到github的步骤： 这个评论好尴尬呀，发个链接就提示请文明发言。我也是很无奈。就只好加在这里。Github上传项目步骤及常见问题的分享]]></content>
      <categories>
        <category>每日一记</category>
      </categories>
      <tags>
        <tag>心情</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[磁感应力检测Bug修复]]></title>
    <url>%2F2017%2F06%2F30%2F%E7%A3%81%E6%84%9F%E5%BA%94%E5%8A%9B%E6%A3%80%E6%B5%8BBug%E4%BF%AE%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[又是忙碌的一天…&nbsp;&nbsp;&nbsp;&nbsp;又是一天过去，昨天的生成报告的插图始终还是没有头绪，一直停留在原地。&nbsp;&nbsp;&nbsp;&nbsp;今天测试的时候发现原来做的通道选择的弹框和地磁场校准的位置有两个小小的bug，通道选择，点击全部通道之后，再点击其它的通道，取消该通道时，全部通道的选择并没取消。在点击每个通道时，如果该通道已被选则判断全部通道是否被选，若被选则取消全部通道的选择。 修改后的效果： (function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","loop":true,"video":{"url":"http://hexoblog-1253306922.cosgz.myqcloud.com/video2017/%E9%80%9A%E9%81%93%E9%80%89%E6%8B%A9.mp4"},"danmaku":{"id":"9E2E3368B56CDBB4","api":"http://dplayer.daoapp.io","token":"tokendemo"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() &nbsp;&nbsp;&nbsp;&nbsp;另外通道校准画图时，ChartService是以系统参数的通道数初始化的，导致校准非全部通道时，未被选择的通道也绘制了折线。 &nbsp;&nbsp;&nbsp;&nbsp;项目差不多接近尾声了，但是实际调试的过程中，依然会遇到许多许多的Bug，而这些是你在开始设计时、编码时未注意到的小细节。事情往往都是看起来挺简单，但是想要做好，可并不容易哦~ &nbsp;&nbsp;&nbsp;&nbsp;暑假这两个月，得好好规划一下自己的时间。 学好安卓，看看web。另外算法的能力也得提高，学会如何把代码写的优雅~]]></content>
      <categories>
        <category>安卓学习</category>
      </categories>
      <tags>
        <tag>安卓</tag>
        <tag>Andriod</tag>
        <tag>磁感应力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我想吐个槽~]]></title>
    <url>%2F2017%2F06%2F29%2F%E6%88%91%E6%83%B3%E5%90%90%E4%B8%AA%E6%A7%BD%2F</url>
    <content type="text"><![CDATA[贴图贴图你真烦~&nbsp;&nbsp;&nbsp;&nbsp;短学期已经开始了好几天，我的任务就是继续完成实验室的安卓磁感应力检测仪的功能完善，实验室大佬去实习了，留下我跟刘昊东两个人并肩作战，先是画图过程比较卡，特别是后退的时候，很是难理解，后来修改了主线程的数据添加过程，将数据添加放在数据处理的线程中，然后通过Handler消息机制通知UI线程重绘。 因为安卓改变UI必须放在主线程中，主线程也被称之为UI线程，所以无法做到多线程绘制界面的效果。另外后退过程避免了多余数据的传递与处理，使得最后过程更加流畅。 &nbsp;&nbsp;&nbsp;&nbsp;另外修复了一个bug，安卓6.0及以上系统版本，对软件权限的管理更加严格，分为普通权限和危险权限，危险权限在软件安装时并不会获取权限，只能在使用过程中动态获取权限，因为生成报告中必须使用存储权限（危险权限），如果没有权限，会导致文件生成失败，显示无效的问价，所以得增加一个动态权限申请的功能，体现用户的交互性。 &nbsp;&nbsp;&nbsp;&nbsp;最后就是一个最难的问题，word文档中插入图片，找了许多资料，安卓上并没有很好的解决方案，Apache POI主要是对Excel操作，对word的操作显得有点尴尬，只想吐槽网上的博客方法都似乎是一个人写的，都一样…很是无奈， 今天想到了一个点子，可是可行性并不是很好，实现起来也并不简单，将doc转成xml文件 然后进行操作，添加图片，最后改成doc的格式，网上也看见过这样的想法，帖子下面还想并没想法，就很尴尬。1234567891011121314151617181920212223242526272829303132public byte[] bitmap2Byte(Bitmap bm) &#123; Bitmap outBitmap = Bitmap.createScaledBitmap(bm, 150, bm.getHeight() * 150 / bm.getWidth(), true); if (bm != outBitmap) &#123; bm.recycle(); bm = null; &#125; byte[] compressData = null; ByteArrayOutputStream baos = new ByteArrayOutputStream(); try &#123; try &#123; outBitmap.compress(Bitmap.CompressFormat.PNG, 100, baos); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; compressData = baos.toByteArray(); baos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return compressData; &#125; public String getBase64(byte[] image) &#123; String string = &quot;&quot;; try &#123; BASE64Encoder encoder = new BASE64Encoder(); string = encoder.encodeBuffer(image).trim(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return string; &#125; 这是将图片（Bitmap格式）转成二进制数组再转成Base64编码，而这种编码正好是xml文件中图片的编码方式，在电脑上试着用暴力更改文件后缀的方式测试，还真行的通，想法归想法， 实现起来 似乎也并不简单… 哎~ 心累~ 睡觉~ 明天继续………]]></content>
      <categories>
        <category>每日一记</category>
      </categories>
      <tags>
        <tag>安卓</tag>
        <tag>心情</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客完善]]></title>
    <url>%2F2017%2F06%2F28%2FHexo%E5%8D%9A%E5%AE%A2%E5%AE%8C%E5%96%84%2F</url>
    <content type="text"><![CDATA[你的Blog得优化~&nbsp;&nbsp;&nbsp;&nbsp;至此，我的博客已经建成，但是总觉得不够完美，还差一点，于是今天花了半天的时间在博客的优化上面，遇到了很多问题，自己一个一个去百度，按照其他博客的步骤来做，当然无法避免有些博客写的并不是很好，有些问题并没有很好的解决。&nbsp;&nbsp;&nbsp;&nbsp;今天下午主要完成了三件事： 博客分类的完善，添加了博客分类，博客标签以及关于我。目的是为了后期更好的管理这些博客，对了还有搜索的功能，可以检索博客中的关键字词。在博客目录下右键Git Bash执行命令:$ hexo new pages tags,在对应blog/source/下新建tags文件夹，用于标签的显示界面，此时你可能会问，为什么不自己直接建一个文件夹呀？ 当然你也可以自己建，只不过用命令的方式会默认在tags文件夹下建立一个index.md文件，改一个自己喜欢的title，并添加一行 type: &quot;tags&quot;即可。如下图所示： &nbsp;&nbsp;&nbsp;&nbsp;博客分类亦是如此，对应类型为type: &quot;cateagories&quot;。关于我并没有添加类型。&nbsp;&nbsp;&nbsp;&nbsp;站点内容搜索功能： 安装hexo-generator-searchdb对应博客目录下git bash执行：$ npm install hexo-generator-searchdb --save站点配置文件_config.yml中添加search字段，如下： 12345search: path: search.xml field: post format: html limit: 10000 第二是添加评论的功能：注册一个友言账号，友言官网，注册成功后进入后台管理获取uid，然后在站点配置文件_config.yml中找到youyan_uid:，附上刚刚的uid，最后部署一下网页即可。 最后就是添加站点阅读量，这个也是我最花时间的一件事情，开始尝试了百度统计，代码也安装成功，只不过访问数据得在百度统计上查看，需求是想在自己的网页footer位置添加一条网页阅读量的消息。尝试了好久，并没有找到好的方法。这里附上一个推荐的教程，对于hexo博客的创建有详细的步骤~ 不说了，我也去加一个打赏的功能~]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何上传文章]]></title>
    <url>%2F2017%2F06%2F27%2F%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[文章怎么上传了？&nbsp;&nbsp;&nbsp;&nbsp;有了博客网页，首先第一步得熟悉如何上传文章，熟悉hexo的基本操作。一般分为三个步骤： （1）第一步新建文章文件，在Git Bash执行命令：$ hexo new &quot;my new post&quot;，然后电脑对应 \bolg\source\_post 中打开my-new-post.md，打开方式可以使用记事本或notepad++。使用Markdown语法进行编辑文章。【当然也可以直接在目录下面新建一个my-new-post.md文件】 （2）Git Bash执行命令：$ hexo g生成静态文件。 （3）Git Bash执行命令：$ hexo d部署到github。稍后就可以在自己的网站上看到自己的文章【第2.3步可以直接执行命令 $ hexo d -g即可完成生成文件并部署到github】 另外可以在Git Bash执行命令：$ hexo s可以本地localhost:4000查看预览效果！ 清除缓存文件db.json和已生成的静态文件public。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令$ hexo clean。]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇文章]]></title>
    <url>%2F2017%2F06%2F27%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[GitHub+hexo搭建我的博客&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先了，先讲讲为什么搭建这个博客，去年暑假的时候，因为邹萌学姐的一个个人网站，让我有了做一个属于自己的网站，可以贴一贴自己的博客，自己学习的心得，还是蛮有趣的一件事情！ &nbsp;&nbsp;&nbsp;&nbsp;因为自己原来实验室学过一点点java和javaweb的知识，但是觉得自己真的并没有学到一些什么实在的东西。缺乏自己实践的能力，寒假有想过做一个网页，看了一些jsp的后台开发技术，也可以连接数据库，做个用户登录与注册的界面，后来来到学校之后，突然发现自己的时间也并不多，就一直留了下来。后来退了原来的实验室，来到了现在的107，学长学姐们都还是特别好，很热心，就像一家人一样，经常也会参加一些活动,丰富我们在实验室学习的经历~~&nbsp;&nbsp;&nbsp;&nbsp;前几天，因为看了实验室刘昊东的个人网页，觉得挺炫的，虽然实质上是一个静态的网页，不过也是挺好的学习机会。自己尝试着百度，自己搭建环境，第一天晚上，用github建了一个网站，以为就是这样的了… 后来总觉得自己界面未免也太丑了，人家的咋那么炫了，然后才有了hexo，又花了一个下午的时间自己去尝试用hexo在github上搭建自己的博客，最后在本地localhost:4000上看到了效果，始终没能部署到github上。昨天下午问了问刘昊东，两个人误打误撞，最后部署到了github上。也就是现在的这个样子~]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04LTS安装及配置Hadoop]]></title>
    <url>%2F2017%2F04%2F27%2FUbuntu16-04%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AEHadoop%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前言 这学期有一门云计算的课程，有接触到Hadoop，后来需要完成Hadoop的安装及配置，折腾了好久，决定以此记录下来。以供学习！课本附录简单介绍了在Windows上的安装及配置过程，但是推荐在Linux系统下完成，正好对Linux系统及一些命令比较感兴趣，趁着这个机会正好学习一波。以此记录之！ Hadoop简介此处引用百度百科： Hadoop是一个由Apache基金会所开发的分布式系统基础架构。用户可以在不了解分布式底层细节的情况下，开发分布式程序。充分利用集群的威力进行高速运算和存储。 Hadoop实现了一个分布式文件系统（Hadoop Distributed File System），简称HDFS。HDFS有高容错性的特点，并且设计用来部署在低廉的（low-cost）硬件上；而且它提供高吞吐量（high throughput）来访问应用程序的数据，适合那些有着超大数据集（large data set）的应用程序。HDFS放宽了（relax）POSIX的要求，可以以流的形式访问（streaming access）文件系统中的数据。 Hadoop的框架最核心的设计就是：HDFS和MapReduce。HDFS为海量的数据提供了存储，则MapReduce为海量的数据提供了计算。 Hadoop在Ubuntu上的安装与配置安装环境及版本说明Ubuntu 16.04LTS 64位操作系统 Hadoop版本：2.7.3 [下载地址](https://archive.apache.org/dist/hadoop/core/hadoop-2.7.3/) Jdk版本：1.8.0 MyEclipse版本：MyEclipse2017 CI 10 安装路径信息hadoop安装路径：/usr/local/hadoop/hadoop-2.7.3 jdk路径：/usr/lib/jvm/java-8-oracle MyEclipse路径：/opt/MyEclipse 2017 一、Java 环境安装此处引用我朋友的CSDN上一篇关于java web环境配置的博客 添加ppa 12sudo add-apt-repository ppa:webupd8team/javasudo apt-get update 安装oracle-java-installerJDK8：sudo apt-get install oracle-java8-installerJDK7：sudo apt-get install oracle-java7-installer 安装时会提示你同意Oracle的服务条款，选择ok，然后选择yes这种方式安装后jdk路径为/usr/lib/jvm/java-8-oracle。 二、安装ssh server 实现免密码登录Hadoop需要使用ssh进行通信，首先我们需要在我们的操作系统上安装ssh。在安装之前，我们需要查看系统是否已经安装并且启动了ssh。 12345#查看ssh安装包情况dpkg -l | grep ssh #查看是否启动ssh服务ps -e | grep ssh 如果系统中没有ssh服务，需要先安装：sudo apt-get install openssh-server我安装时出现了connect to host localhost port 22: Connection refused问题，在CSDN博客上找到解决方法： 先用：sudo apt-get install -f 解决依赖问题 然后：sudo apt-get install openssh-server 就可以了 安装完成之后，启动服务：sudo /etc/init.d/ssh start 三、安装Hadoop及配置根据上述地址下载hadoop-2.7.3.tar.gz文件 解压缩下载的文件到指定文件夹tar -zxvf hadoop-2.7.3 -C /usr/local/hadoop/ 配置/usr/local/hadoop/hadoop-2.7.3/etc/hadoop/目录下三个文件 core-site.xml配置如下：12345678910&lt;configuration&gt; &lt;property&gt; &lt;name&gt;fs.default.name&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/home/mindyu/tmp&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; hdfs-site.xml配置如下： 12345678910&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.permissions&lt;/name&gt; &lt;value&gt;false&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; hadoop-env.sh中进行对应的配置： 1234# The java implementation to use.export JAVA_HOME=/usr/lib/jvm/java-8-oracleexport HADOOP_HOME=/usr/local/hadoop/hadoop-2.7.3export PATH=$PATH:/usr/local/hadoop/hadoop-2.7.3/bin 在系统环境变量中写入hadoop路径：vim /etc/environment然后在文件尾追加:/usr/local/hadoop/hadoop-2.7.3/bin:/usr/local/hadoop/hadoop-2.7.3/sbin 重启系统 验证Hadoop单机模式安装完成hadoop version 启动hdfs 使用伪分布模式，首先完成格式化hadoop namenode -format 启动hdfssbin/start-all.sh 显示进程jps若显示以上内容即说明hdfs已经成功 Hadoop资源管理GUI：Hadoop节点管理GUI： 停止hdfssbin/stop-all.sh Ubuntu16.04 上运行 Hadoop2.7.3 自带wordCount摸索记录 启动hadoop: 运行命令：ps -ef|grep hadoop查询是否有hadoop进程： 在hdfs下创建input文件夹。准备两个文件，比如abc.txt和def.txt 里面各写上一句话(用于统计)。然后导入到hdfs文件系统中的input文件夹下。hadoop fs -put *.txt /input 执行：bin/hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.3.jar wordcount /input /output下次执行时需要将当前的output目录删除或者更换目录hadoop fs -rmr /output 查看hdfs下output中的文件： 查看结果：hadoop fs -cat /output/part-r-00000 myeclipse下搭建hadoop2.7.3开发环境 下载对应版本的myeclipse-hadoo-plugins插件 把解压后的插件（jar文件）放到myeclipse安装目录下的plugins文件夹下 重启MyEclipse window-&gt;preferences中会出现Hadoop Map/Reduce选项，选中并设置hadoop 的安装路径 在show view中把map/reduce显示到工具栏 打开 Hadoop Location配置窗口： 配置Map/Reduce Master和DFS Mastrer，Host和Port配置成与core-site.xml的一致 配置完成之后。（如果出现错误，检查hadoop集群是否启动成功，看日志是否有错误，先把错误调完，正确启动集群后再干别的） 新建测试项目File—&gt;Project，选择Map/Reduce Project，输入项目名称等。 将Hadoop源码(源码可在上文hadoop下载链接中下载)中的WordCount类拷贝到项目中 设置Run Configration的arguments参数： 执行WordCount类，查看结果。结果如下：]]></content>
      <categories>
        <category>Ubuntu学习</category>
      </categories>
      <tags>
        <tag>Ubuntu16.04</tag>
        <tag>Hadoop</tag>
        <tag>MyEclipse</tag>
      </tags>
  </entry>
</search>