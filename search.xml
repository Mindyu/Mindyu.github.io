<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[品优购项目笔记（下）]]></title>
    <url>%2F2018%2F12%2F22%2F%E5%93%81%E4%BC%98%E8%B4%AD%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[购物车解决方案用户在商品详细页点击加入购物车，提交商品 SKU 编号和购买数量，添加到购物车。当用户在未登录的情况下，将此购物车存入 cookies , 在用户登陆的情况下，将购物车数据存入 redis 。如果用户登陆时，cookies 中存在购物车，需要将 cookies 的购物车合并到 redis 中存储.购物车数据存储结构： 购物车实体类： 123456public class Cart implements Serializable&#123; // 对每一个商家购物车的封装 private String sellerId; // 商家ID private String sellerName; // 商家名称 private List&lt;TbOrderItem&gt; orderItemList; // 购物车明细 // setter getter方法 &#125; Cookie 存储购物车 服务实现层：向购物车列表中添加物品 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091@Overridepublic List&lt;Cart&gt; addGoodsToCartList(List&lt;Cart&gt; cartList, Long itemId, Integer num) &#123; // 1. 根据skuID （itemId）查询商品明细sku的对象 TbItem item = itemMapper.selectByPrimaryKey(itemId); if (item == null) throw new RuntimeException("商品不存在"); // 时间差，比如在添加提交订单时，商品下架了 if (!"1".equals(item.getStatus())) throw new RuntimeException("商品不存在"); // 2. 根据sku对象获取商家ID String sellerId = item.getSellerId(); // 3. 根据商家ID在购物车列表中查询购物车对象 Cart cart = searchCartBySellerId(cartList, sellerId); // 4.如果购物车列表中不存在该商家ID对应的购物车对象 if (cart == null) &#123; // 4.1创建该商家的购物车对象 cart = new Cart(); cart.setSellerId(sellerId); cart.setSellerName(item.getSeller()); // 创建购物车明细对象 List&lt;TbOrderItem&gt; orderItemList = new ArrayList&lt;&gt;(); TbOrderItem orderItem = createOrderItem(item, num); orderItemList.add(orderItem); cart.setOrderItemList(orderItemList); // 4.2将该购物车对象添加到购物车列表中 cartList.add(cart); &#125;else &#123; // 5. 如果购物车列表中存在该商家ID对应的购物车对象 // 然后判断购物车对象中是否存在该商品的明细对象 TbOrderItem orderItem = searchOrderItemByItemId(cart.getOrderItemList(), itemId); if (orderItem == null) &#123; // 5.1 如果明细列表中不存在，创建明细对象添加到购物车对象中 // 创建购物车明细对象 orderItem = createOrderItem(item, num); cart.getOrderItemList().add(orderItem); &#125;else &#123; // 5.2 如果明细列表中存在，则增加对应的数量 orderItem.setNum(orderItem.getNum()+num); // 更改数量 orderItem.setTotalFee( new BigDecimal(orderItem.getPrice().doubleValue()*orderItem.getNum()) ); // 更改价格 if(orderItem.getNum()&lt;1) cart.getOrderItemList().remove(orderItem); // 当明细的数量小于1时移除 if (cart.getOrderItemList().size()&lt;1) cartList.remove(cart); // 当购物车的明细项数为0时，移除购物车列表该对象 &#125; &#125; return cartList;&#125;/** * 根据商家ID在购物车列表中查询该商家的购物车 * @param cartList * @param sellerId * @return */private Cart searchCartBySellerId(List&lt;Cart&gt; cartList, String sellerId) &#123; for(Cart cart :cartList) &#123; if (sellerId.equals(cart.getSellerId())) &#123; return cart; &#125; &#125; return null;&#125;// 创建新的购物明细对象private TbOrderItem createOrderItem(TbItem item, Integer num) &#123; if(num&lt;1) throw new RuntimeException("非法数量"); TbOrderItem order = new TbOrderItem(); order.setGoodsId(item.getGoodsId()); order.setItemId(item.getId()); order.setNum(num); order.setPicPath(item.getImage()); order.setPrice(item.getPrice()); order.setSellerId(item.getSellerId()); order.setTitle(item.getTitle()); order.setTotalFee(new BigDecimal( item.getPrice().doubleValue()*num )); return order;&#125;/** * 在购物车明细列表中，根据SKUID查询购物车明细对象 * @param orderItemList * @param itemId * @return */private TbOrderItem searchOrderItemByItemId(List&lt;TbOrderItem&gt; orderItemList, Long itemId) &#123; for(TbOrderItem orderItem : orderItemList) &#123; if (orderItem.getItemId().longValue()==itemId.longValue()) &#123; return orderItem; &#125; &#125; return null;&#125; 控制层： 12345678910111213141516171819202122232425262728293031323334353637/** * 购物车列表 * * @param request * @return */@RequestMapping("/findCartList")public List&lt;Cart&gt; findCartList() &#123; String cartListString = util.CookieUtil.getCookieValue(request, "cartList", "UTF-8"); if (cartListString == null || cartListString.equals("")) &#123; cartListString = "[]"; &#125; List&lt;Cart&gt; cartList_cookie = JSON.parseArray(cartListString, Cart.class); return cartList_cookie;&#125;/** * 添加商品到购物车 * * @param request * @param response * @param itemId * @param num * @return */@RequestMapping("/addGoodsToCartList")public Result addGoodsToCartList(Long itemId, Integer num) &#123; try &#123; List&lt;Cart&gt; cartList = findCartList();// 获取购物车列表 cartList = cartService.addGoodsToCartList(cartList, itemId, num); util.CookieUtil.setCookie(request, response, "cartList", JSON.toJSONString(cartList), 3600 * 24, "UTF-8"); return new Result(true, "添加成功"); &#125; catch (Exception e) &#123; e.printStackTrace(); return new Result(false, "添加失败"); &#125;&#125; 前端服务层：将逻辑实现放在服务层，以便重用。 1234567891011121314// 购物车明细求和this.sum=function(cartList)&#123; var total = &#123;totalNum:0, totalMoney:0&#125;; for(var i=0;i&lt;cartList.length;i++)&#123; var cart = cartList[i]; for(var j=0;j&lt;cart.orderItemList.length;j++)&#123; var item=cart.orderItemList[j]; // 购物车明细 total.totalNum +=item.num; total.totalMoney += item.totalFee; &#125; &#125; return total;&#125; Redis 存储购物车 判断当前用户是否登陆，如果未登录采用 Cookie 存储，如果登录则采用 Redis 存储。登录后要进行 Cookie 购物车与 Redis 购物车的合并操作，并清除 Cookie 购物车。 首先修改 spring-security 配置文件 123456789101112&lt;!-- &lt;http pattern="/cart/*.do" security="none"&gt;&lt;/http&gt; --&gt; &lt;!-- 这种方式会导致不会经过登录认证操作，无法获取登录用户名 --&gt;&lt;!-- entry-point-ref 入口点引用 --&gt;&lt;http use-expressions="false" entry-point-ref="casProcessingFilterEntryPoint"&gt; &lt;intercept-url pattern="/cart/*.do" access="IS_AUTHENTICATED_ANONYMOUSLY"/&gt; &lt;intercept-url pattern="/**" access="ROLE_USER"/&gt; &lt;csrf disabled="true"/&gt; &lt;!-- custom-filter为过滤器， position 表示将过滤器放在指定的位置上，before表示放在指定位置之前 ，after表示放在指定的位置之后 --&gt; &lt;custom-filter ref="casAuthenticationFilter" position="CAS_FILTER" /&gt; &lt;custom-filter ref="requestSingleLogoutFilter" before="LOGOUT_FILTER"/&gt; &lt;custom-filter ref="singleLogoutFilter" before="CAS_FILTER"/&gt; &lt;/http&gt; 之前配置的过滤购物车拦截的方式，会导致该逻辑不会经过spring security的生命周期。那么在 CartController 中就无法通过 SecurityContextHolder.getContext().getAuthentication().getName() 的方式来获取当前登录用户名。报空指针异常。 access=”IS_AUTHENTICATED_ANONYMOUSLY” 用于设置资源可以在不登陆时可以访问。此 配 置 与 security=”none” 的 区 别 在 于 当 用 户 未 登 陆 时 获 取 登 陆 人 账 号 的 值 为 anonymousUser ，而 security=”none”的话，无论是否登陆都不能获取登录人账号的值。 服务层实现 12345678910111213@Overridepublic List&lt;Cart&gt; findCartListFromRedis(String username) &#123; // System.out.println("从redis中获取购物车数据"); List&lt;Cart&gt; cartList = (List&lt;Cart&gt;) redisTemplate.boundHashOps("cartList").get(username); if(cartList == null) cartList = new ArrayList&lt;&gt;(); return cartList;&#125;@Overridepublic void addCartListToRedis(String username, List&lt;Cart&gt; cartList) &#123; // System.out.println("向Redis中存储购物车数据"); redisTemplate.boundHashOps("cartList").put(username, cartList);&#125; 控制层实现，通过判断用户是否登录来选择从cookie还是redis中读取数据 123456789101112131415161718192021222324252627@RequestMapping("/findCartList")public List&lt;Cart&gt; findCartList() &#123; // 获取当前登录用户名 String username = SecurityContextHolder.getContext().getAuthentication().getName(); // 从cookie中读取购物车数据 String cookieValue = util.CookieUtil.getCookieValue(request, "cartList", "UTF-8"); if (cookieValue == null || "".equals(cookieValue)) cookieValue = "[]"; List&lt;Cart&gt; cartList_cookie = JSON.parseArray(cookieValue, Cart.class); if (username.equals("anonymousUser")) &#123; // 如果未登录 从cookie中读取 // System.out.println("从cookie中读取"); return cartList_cookie; &#125;else &#123; // 用户已登录 从redis中读取 List&lt;Cart&gt; cartList_redis = cartService.findCartListFromRedis(username); if (cartList_cookie.size()&gt;0) &#123; // 本地购物车未合并 // System.out.println("合并本地和redis购物车数据"); // 合并本地和redis购物车数据 cartList_redis = cartService.mergeCartList(cartList_cookie, cartList_redis); // 在存储到redis中 cartService.addCartListToRedis( username, cartList_redis); // 清空本地缓存购物车 util.CookieUtil.deleteCookie(request, response, "cartList"); &#125; return cartList_redis; &#125;&#125; 合并购物车 当用户登录时，需要将存储在cookie中的购物车数据添加到redis服务器中。同时清空本地cookie中的数据。已达到合并的效果。 12345678910@Overridepublic List&lt;Cart&gt; mergeCartList(List&lt;Cart&gt; cartList1, List&lt;Cart&gt; cartList2) &#123; if(cartList1==null &amp;&amp; cartList2 == null) return new ArrayList&lt;Cart&gt;(); for(Cart cart : cartList2) &#123; for(TbOrderItem orderItem : cart.getOrderItemList()) &#123; cartList1 = addGoodsToCartList(cartList1, orderItem.getItemId(), orderItem.getNum()); &#125; &#125; return cartList1;&#125; 循环一个 cartList 中的 orderItem 数据，然后逐个添加到另一个 cartList 中。然后控制层在 findCartList 中调用，因为用户登录之后，进入购物车页面时必定经过查询购物车数据的方法。在前面的控制层实现中已经给出代码实现。 跳板页的思想 用户添加购物车完成之后，如果需要购买那么必须先完成登录。该系统使用cas实现的单点登录。如果我们通过直接跳转到 http://localhost:9100/cas/login cas服务器地址来完成登录，这样会出现登录完成之后页面会跳转到cas服务器的登录成功的提示页面，而不是我们想要的购物车页面。 我们可以采用一种跳板页的方法来实现。点击登录然后跳转到跳板页 login.html。但是由于当前状态为未登录，该页面会被Spring Security拦截然后重定向到cas服务器的登录页，登录成功后会重新回到 login.html 页面。然后在 login.html 页面中执行 js 回跳到购物车页面即可。 1234&lt;!-- login.html中添加跳转页面 --&gt;&lt;script type="text/javascript"&gt; location.href="cart.html";&lt;/script&gt; 跨域解决方案与提交订单JS 跨域请求 通过 js 在不同的域之间进行数据传输或通信，比如用 ajax 向一个不同的域请求数据，或者通过 js 获取页面中不同域的框架中(iframe)的数据。只要协议、域名、端口有任何一个不同，都被当作是不同的域。这也是面试中经常会问到的一个问题。 商品详情页面点击提交订单，就会异步调用购物车模块的添加商品到购物车的逻辑。该过程就会用到跨域操作。如果不考虑跨域问题会出现如下问题。点击添加购物车没有响应。 跨域解决方案 CORS CORS 是一个 W3C 标准，全称是”跨域资源共享”（Cross-origin resource sharing）。CORS 需要浏览器和服务器同时支持。除了 IE10 以前的浏览器之外其它浏览器都支持。（IE并未实现W3C标准） CORS 可以解决跨越问题，允许浏览器向跨源服务器发出 XMLHttpRequest 请求。当存在跨域请求时，浏览器会自动添加附加的头信息，有时候会多一次附加请求，但是用户不会察觉。实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信。 请求过程：首先浏览器向服务器发送一个预请求，服务器返回一个 Preflight Response，如果服务器同意跨域请求，那么浏览器才能继续发送跨域请求。 123// 服务器只需要配置 response 响应头信息即可response.setHeader("Access-Control-Allow-Origin", "http://localhost:9105"); // 允许跨域请求response.setHeader("Access-Control-Allow-Credentials", "true"); // 允许携带cookie （方法中如果会操作cookie的话，必须添加该配置） Access-Control-Allow-Origin 的配置表示服务器支持跨域请求的地址。此时也就是允许 http://localhost:9105 该地址的跨域请求。 另外 Spring 4.2 版本之后支持注解式跨域请求@CrossOrigin(origins=&quot;http://localhost:9105&quot;,allowCredentials=&quot;true&quot;) // spring 4.2版本以上支持注解的方式，allowCredentials=&quot;true&quot;可以缺省 CORS 请求默认不发送 Cookie 和 HTTP 认证信息。如果要把 Cookie 发到服务器，一方面要服务器同意，指定 Access-Control-Allow-Credentials 字段。另一方面，开发者必须在 AJAX 请求中打开 withCredentials 属性。否则，即使服务器同意发送 Cookie，浏览器也不会发送（点击添加购物车，登录之后，cookie中的购物车数据不会合并到用户的购物车中）。或者，服务器要求设置 Cookie，浏览器也不会处理。 123456789101112131415// 添加到购物车$scope.addToCart=function()&#123; // alert('sku_id:'+ $scope.sku.id); // 执行跨域请求 $http.get("http://localhost:9107/cart/addGoodsToCartList.do?itemId="+ $scope.sku.id +"&amp;num=" + $scope.num, &#123;'withCredentials':true&#125;).success( function(response)&#123; if (response.success) &#123; location.href="http://localhost:9107/cart.html"; // 跳转到购物车页面 &#125;else&#123; alert(response.message); &#125; &#125; );&#125; 结算页信息显示 收件人的的选择 点击购物车进入结算页，首先会让用户选择收货地址以及收货人信息。而收获人信息是个用户进行关联的，所以将该模块放置在user模块中，在 AddressService 中新增一个通过用户ID查询收货人的信息的方法。然后在controller层，通过SpringSecurityu获取当前登录用户的ID，然后通过服务方法从数据库中取出用户的收获信息列表。前端以列表的信息显示出来。 123456789101112131415161718192021222324// 查询用户的收货地址信息$scope.findAddress=function()&#123; cartService.findAddress().success( function(response)&#123; $scope.addressList = response; // 查找默认地址 for(var i=0;i&lt;$scope.addressList.length;i++)&#123; if($scope.addressList[i].isDefault=='1')&#123; $scope.address=$scope.addressList[i];break; &#125; &#125; &#125; );&#125;// 选择地址$scope.selectAddress=function(address)&#123; $scope.address = address;&#125;// 该地址是否被选$scope.isSelectedAddress=function(address)&#123; return ($scope.address == address);&#125; 支付方式 通过 $scope.order={paymentType:&#39;1&#39;};中的paymentType字段来绑定页面的支付方式，1表示微信支付，2表示货到付款 。 商品清单与金额显示 cartController.js 中之前实现了获取购物车的信息。此处的商品清单也可以通过该方法，从redis中获取用户购买的信息。然后通过 ng-repeat 循环遍历显示即可。合计金额也可以通过 sum 方法计算求和。 分布式 ID 生成器 snowflake 算法。由 Twitter 推出的一款开源的分布式自增ID生成算法。 结构： 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 第一位为未使用，接下来的41位为毫秒级时间(41位的长度可以使用69年)，然后是5位datacenterId和5位workerId(10位的长度最多支持部署1024个节点），最后12位是毫秒内的计数（12位的计数顺序号支持每个节点每毫秒产生4096个ID序号） 一共加起来刚好64位，为一个Long型。(转换成字符串后长度最多19) snowflake生成的ID整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞（由datacenter和workerId作区分不同机器之间也就不会出现重复ID的情况），并且效率较高。经测试snowflake每秒能够产生26万个ID。 注：UUID 存在的问题：128位（16字节）较占内存，无法生成有序的ID。 IdWorker 生成器工具类位于 common 工程。创建一个 IdWorker 对象，然后调用 nextId() 即可生成一个全局唯一ID。在Spring工程中，我们可以通过配置的方式来构造bean。 123456&lt;bean id="idWorker" class="util.IdWorker"&gt; &lt;!-- 进程 ID --&gt; &lt;constructor-arg index="0" value="0"&gt;&lt;/constructor-arg&gt; &lt;!-- 数据中心 ID --&gt; &lt;constructor-arg index="1" value="0"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 保存订单 取出 redis 中存储的用户购物车数据，生成对应的订单项，采用 snowflake 算法生成唯一的订单ID，然后根据商品的SKU信息生成多个订单项。 微信二维码支付模块二维码生成插件 qrious qrious 是一款基于 HTML5 Canvas 的纯 JS 二维码生成插件。通过 qrious.js 可以快速生成各种二维码，你可以控制二维码的尺寸颜色，还可以将生成的二维码进行 Base64 编码。 配置参数： 微信扫码支付 商户系统按微信支付协议生成支付二维码，用户再用微信“扫一扫”完成支付的模式。该模式适用于 PC 网站支付、实体店单品或订单支付、媒体广告支付等场景。 具体开发文档：https://pay.weixin.qq.com/wiki/doc/api/index.html 主要了解Native支付的统一下单和查询订单API。 实现原理：首先引入微信支付的sdk依赖。使用 HttpClient 工具类，来模拟浏览器行为，去调用微信支付的 api 接口，向该地址提交相应的数据，然后获取结果。 由于使用微信扫码支付的申请条件比较苛刻，所以这一模块无法完成测试。提供的公共号、商户号、秘钥信息等，无法完成签名。返回的信息为签名错误。 服务接口层 pay-interface 服务实现层 pay-service 依赖 pay 接口，和common模块（将 httpclient 工具类放在公共层、以及微信支付的基本信息配置），spring dubbo 依赖以及微信的 SDK。实现生成二维码和查询订单状态的方法。 控制层 cart-web 模块依赖支付服务，生成订单之后进入支付页面，调用服务层的生成二维码的方法，得到返回的 code_url ，然后让前端 qrious 插件根据该 url 去生成二维码即可。然后后端定时调用查询订单状态的方法，每隔3秒钟去查询订单支付状态，同时每隔五分钟之后就提示二维码支付超时，然后前端就收到超时信息之后，可以将其显示出来或者重新生成二维码信息。同时如果前端页面被关闭，后端会在五分钟之后返回超时的提示。 支付日志 （1）在用户下订单时，判断如果为微信支付，就向支付日志表添加一条记录，信息包括支付总金额、订单 ID（一个支付日志对应多个订单）、用户 ID 、下单时间等信息，支付状态为 0（未支付） （2）生成的支付日志对象放入 redis 中，以用户 ID 作为 key，这样在生成支付二维码时就可以从 redis 中提取支付日志对象中的金额和订单号。 （3）当用户支付成功后，修改支付日志的支付状态为 1（已支付），并记录微信传递给我们的交易流水号。根据订单 ID（多个）修改订单的状态为 2（已付款）。同时删除缓存中的支付日志。 秒杀解决方案秒杀的特点就是在特定的时间对限量的商品进行抢购。在该时间可能存在很高的并发请求，而造成对后端数据库的巨大压力。此时可以采用缓存机制，来避免用户直接与数据库的交互。秒杀时说有数据都存储在缓存中，只有当商品抢购完或者时间到期时才将缓存中的数据一次性存入数据库中。 模块需求： （1）商家提交秒杀商品申请，录入秒杀商品数据，主要包括：商品标题、原价、秒杀价、商品图片、介绍等信息 （2）运营商审核秒杀申请 （3）秒杀频道首页列出正在秒杀的商品，用户点击秒杀商品图片跳转到秒杀商品详细页。 （4）商品详细页显示秒杀商品信息，点击立即抢购实现秒杀下单，下单时扣减库存。当库存为 0 或不在活动期范围内时无法秒杀。 （5）秒杀下单成功，直接跳转到支付页面（微信扫码），支付成功，跳转到成功页，填写收货地址、电话、收件人等信息，完成订单。 （6）当用户秒杀下单 5 分钟内未支付，取消预订单，调用微信支付的关闭订单接口，恢复库存。 秒杀频道首页 seckill 模块服务层 12345678910111213141516171819202122232425262728293031/** * 返回当前正在参与秒杀的商品 */@Overridepublic List&lt;TbSeckillGoods&gt; findList() &#123; List&lt;TbSeckillGoods&gt; seckillGoodsList = redisTemplate.boundHashOps("seckillGoods").values(); if (seckillGoodsList==null || seckillGoodsList.size()==0) &#123; // 当前缓存还没有数据 TbSeckillGoodsExample example = new TbSeckillGoodsExample(); Criteria criteria = example.createCriteria(); criteria.andStatusEqualTo("1"); // 已审核状态 criteria.andStockCountGreaterThan(0); // 库存量&gt;0 criteria.andStartTimeLessThanOrEqualTo(new Date()); // 当前时间大于等于开始时间 criteria.andEndTimeGreaterThanOrEqualTo(new Date());// 当前时间晚于结束时间 seckillGoodsList = seckillGoodsMapper.selectByExample(example ); // 从数据库中读取数据 for(TbSeckillGoods seckillGood : seckillGoodsList) &#123; // 将当前时间的秒杀商品按商品ID存入缓存 redisTemplate.boundHashOps("seckillGoods").put(seckillGood.getId(), seckillGood); &#125; System.out.println("从数据库中读取秒杀商品并放入缓存"); &#125;else &#123; System.out.println("从缓存中读取秒杀商品数据"); &#125; return seckillGoodsList;&#125;@Overridepublic TbSeckillGoods findOneFromRedis(Long id) &#123; return (TbSeckillGoods) redisTemplate.boundHashOps("seckillGoods").get(id);&#125; 控制层 12345678910111213/** * 从数据库中查询当前秒杀的商品 * @return */@RequestMapping("/findList")public List&lt;TbSeckillGoods&gt; findList() &#123; return seckillGoodsService.findList();&#125;@RequestMapping("/findOneFromRedis")public TbSeckillGoods findOneFromRedis(Long id) &#123; return seckillGoodsService.findOneFromRedis(id);&#125; 前端服务层 123456789101112131415app.service('seckillGoodsService',function($http)&#123; //读取列表数据绑定到表单中 this.findList=function()&#123; return $http.get('seckillGoods/findList.do'); &#125; this.findOne=function(id)&#123; return $http.get('seckillGoods/findOneFromRedis.do?id='+id); &#125; this.submitOrder=function(seckillId)&#123; return $http.get('seckillOrder/submitOrder.do?seckillId='+seckillId); &#125;&#125;); 前端控制层 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455app.controller('seckillGoodsController', function($scope, $location, $interval, seckillGoodsService)&#123; // 读取列表数据绑定到表单中 $scope.findList=function()&#123; seckillGoodsService.findList().success( function(response)&#123; $scope.list=response; &#125; ); &#125; //查询实体 点击秒杀首页商品的详情页时，跳转到详情页，传递商品的ID信息 $scope.findOne=function()&#123; seckillGoodsService.findOne($location.search()['id']).success( function(response)&#123; $scope.entity = response; totalSecond = Math.floor((new Date($scope.entity.endTime).getTime() - (new Date().getTime()))/1000); time = $interval(function()&#123; // 倒计时的实现 if (totalSecond&gt;0) &#123; $scope.timeString = convertSecondToTime(totalSecond); --totalSecond; &#125;else&#123; alert("秒杀已结束"); $interval.cancel(time); &#125; &#125;, 1000); &#125; ); &#125; convertSecondToTime=function(totalSecond)&#123; var sec = totalSecond%60; totalSecond = Math.floor(totalSecond/60); var min = totalSecond%60; totalSecond = Math.floor(totalSecond/60); var hour = totalSecond%24; totalSecond = Math.floor(totalSecond/24); var day = totalSecond; return day==0? hour+":"+min+":"+sec : day+"天 "+hour+":"+min+":"+sec; &#125; $scope.submitOrder=function()&#123; seckillGoodsService.submitOrder($scope.entity.id).success( function(response)&#123; if (response.success) &#123; alert("抢购成功，请在五分钟内付款"); location.href="pay.html"; &#125;else&#123; alert(response.message); &#125; &#125; ); &#125; &#125;); 秒杀倒计时效果 $interval 服务用来间歇性处理某事务 格式：$interval(执行的函数,间隔的毫秒数,运行次数); 123456789time = $interval(function()&#123; // 倒计时的实现 if (totalSecond&gt;0) &#123; $scope.timeString = convertSecondToTime(totalSecond);// 格式转换 --totalSecond; &#125;else&#123; alert("秒杀已结束"); $interval.cancel(time); // 退出定时任务 &#125;&#125;, 1000); 秒杀提交订单 服务层逻辑 1234567891011121314151617181920212223242526272829303132@Overridepublic void submitOrder(Long seckillId, String userId) &#123; // 从缓存中查询商品 TbSeckillGoods seckillGoods = (TbSeckillGoods) redisTemplate.boundHashOps("seckillGoods").get(seckillId); // 判断商品状态 if (seckillGoods == null) &#123; throw new RuntimeException("商品不存在"); &#125;else if(seckillGoods.getStockCount()&lt;=0)&#123; throw new RuntimeException("商品已抢购一空"); &#125; // 商品库存 -1 seckillGoods.setStockCount(seckillGoods.getStockCount()-1); if (seckillGoods.getStockCount() == 0) &#123; // 商品被抢空 redisTemplate.boundHashOps("seckillGoods").delete(seckillId); // 删除缓存中该商品 seckillGoodsMapper.updateByPrimaryKey(seckillGoods); // 同步到数据库 &#125;else &#123; // 更新秒杀商品中数据 redisTemplate.boundHashOps("seckillGoods").put(seckillId, seckillGoods); &#125; // 生成订单信息 TbSeckillOrder order = new TbSeckillOrder(); order.setId(idWorker.nextId()); // 生成订单ID order.setSeckillId(seckillId); // 秒杀商品ID order.setMoney(seckillGoods.getCostPrice()); // 秒杀价格 order.setUserId(userId); order.setSellerId(seckillGoods.getSellerId()); // 商家ID order.setCreateTime(new Date()); order.setStatus("0"); // 状态 redisTemplate.boundHashOps("seckillOrder").put(userId, order);&#125; 控制层 123456789101112131415161718@RequestMapping("/submitOrder")public Result submitOrder(Long seckillId) &#123; String username = SecurityContextHolder.getContext().getAuthentication().getName(); if ("anonymousUser".equals(username)) &#123; // 如果未登录 return new Result(false, "用户未登录"); &#125; try &#123; seckillOrderService.submitOrder(seckillId, username); return new Result(true, "订单提交成功"); &#125; catch (RuntimeException e) &#123; e.printStackTrace(); return new Result(false, e.getMessage()); &#125; catch (Exception e) &#123; e.printStackTrace(); return new Result(false, "订单提交失败"); &#125;&#125; 秒杀支付 用户抢购成功之后跳转到支付页面。调用微信二维码支付接口，生成二维码，用户支付完成之后跳转到收获人地址信息填写页面。超过五分钟未付款就取消订单，恢复redis中的库存量，同时关闭微信订单，防止用户支付无效的订单。由于微信支付接口无法测试该功能预留。 SpringTask 任务调度实现上述秒杀功能之后，我想你一定也有和我一样的疑惑，那就是秒杀的商品什么时候从数据库中实时更新了，先前实现的逻辑只有在第一次访问秒杀系统时，即判断 redis 缓存中是否存在对应的商品信息，如果不存在就从数据库中取出数据同时还需要全量添加到缓存中。但是之后就一直从缓存中取数据。 此时就可以使用 SpringTask 任务调度来实现计划任务，即在某个时间点执行某件事。实现每秒钟去增量更新redis数据库中的秒杀商品信息。 Cron 表达式格式 Cron 表达式是一个字符串，字符串以 5 或 6 个空格隔开，分为 6 或 7 个域，每一个域代表一个含义，Cron 有如下两种语法格式：（1）Seconds Minutes Hours DayofMonth Month DayofWeek Year（2）Seconds Minutes Hours DayofMonth Month DayofWeek 每一个域可出现的字符如下： Seconds: 可出现”, - * /“四个字符，有效范围为 0-59 的整数 Minutes: 可出现”, - * /“四个字符，有效范围为 0-59 的整数 Hours: 可出现”, - * /“四个字符，有效范围为 0-23 的整数 DayofMonth: 可出现”, - * / ? L W C”八个字符，有效范围为 1-31 的整数 Month: 可出现”, - * /“四个字符，有效范围为 1-12 的整数或 JAN-DEC(英文单词的前三个字母) DayofWeek: 可出现”, - * / ? L C #”四个字符，有效范围为 1-7 的整数或 SUN-SAT 两个范围。1表示星期天，2 表示星期一， 依次类推 Year: 可出现”, - * /“四个字符，有效范围为 1970-2099 年 每一个域都使用数字，但还可以出现如下特殊字符，它们的含义是： 1234567891011121314151617181920212223242526272829303132333435363738(1)*: 表示匹配该域的任意值，假如在 Minutes 域使用, 即表示每分钟都会触发事件。(2)?: 只能用在 DayofMonth 和 DayofWeek 两个域。它也匹配域的任意值，但实际不会。因为DayofMonth 和 DayofWeek 会相互影响。例如想在每月的 20 日触发调度，不管 20 日到底是星期几，则只能使用如下写法： 13 13 15 20 * ?, 其中最后一位只能用？，而不能使用，如果使用表示不管星期几都会触发，实际上并不是这样。(3)-: 表示范围，例如在 Minutes 域使用 5-20，表示从 5 分到 20 分钟每分钟触发一次(4)/: 表示起始时间开始触发，然后每隔固定时间触发一次，例如在 Minutes 域使用 5/20,则意味着 5 分钟触发一次，而 25，45 等分别触发一次.(5),: 表示列出枚举值值。例如：在 Minutes 域使用 5,20，则意味着在 5 和 20 分每分钟触发一次。(6)L: 表示最后，只能出现在 DayofWeek 和 DayofMonth 域，如果在 DayofWeek 域使用 5L,意味着在最后的一个星期四触发。(7)W: 表示有效工作日(周一到周五),只能出现在 DayofMonth 域，系统将在离指定日期的最近的有效工作日触发事件。例如：在 DayofMonth 使用 5W，如果 5 号是星期六，则将在最近的工作日：星期五，即 4 号触发。如果 5 号是星期天，则在 6 号(周一)触发；如果 5 号在星期一到星期五中的一天，则就在 5 号触发。另外一点，W 的最近寻找不会跨过月份。(8)LW: 这两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五。(9)#: 用于确定每个月第几个星期几，只能出现在 DayofMonth 域。例如在 4#2，表示某月的第二个星期三。Cron 表达式例子：0 0 10,14,16 * * ? 每天上午 10 点，下午 2 点，4 点0 0/30 9-17 * * ? 每天上午九点到下午五点每半小时0 0 12 ? * WED 表示每个星期三中午 12 点&quot;0 0 12 * * ?&quot; 每天中午 12 点触发&quot;0 15 10 ? * *&quot; 每天上午 10:15 触发&quot;0 15 10 * * ?&quot; 每天上午 10:15 触发&quot;0 15 10 * * ? *&quot; 每天上午 10:15 触发&quot;0 15 10 * * ? 2005&quot; 2005 年的每天上午 10:15 触发&quot;0 * 14 * * ?&quot; 在每天下午 2 点到下午 2:59 期间的每 1 分钟触发&quot;0 0/5 14 * * ?&quot; 在每天下午 2 点到下午 2:55 期间的每 5 分钟触发&quot;0 0/5 14,18 * * ?&quot; 在每天下午 2 点到 2:55 期间和下午 6 点到 6:55 期间的每 5 分钟触发&quot;0 0-5 14 * * ?&quot; 在每天下午 2 点到下午 2:05 期间的每 1 分钟触发&quot;0 10,44 14 ? 3 WED&quot; 每年三月的星期三的下午 2:10 和 2:44 触发&quot;0 15 10 ? * MON-FRI&quot; 周一至周五的上午 10:15 触发&quot;0 15 10 15 * ?&quot; 每月 15 日上午 10:15 触发&quot;0 15 10 L * ?&quot; 每月最后一日的上午 10:15 触发&quot;0 15 10 ? * 6L&quot; 每月的最后一个星期五上午 10:15 触发&quot;0 15 10 ? * 6L 2002-2005&quot; 2002 年至 2005 年的每月的最后一个星期五上午 10:15 触发&quot;0 15 10 ? * 6#3&quot; 每月的第三个星期五上午 10:15 触发 表达式 表示含义 0 0 10,14,16 ? 每天上午 10 点，下午 2 点，4 点 0 0/30 9-17 ? 每天上午九点到下午五点每半小时 0 0 12 ? * WED 每个星期三中午 12 点 0 0 12 ? 每天中午 12 点触发 0 15 10 ? 每天上午 10:15 触发 0 15 10 ? 每天上午 10:15 触发 0 15 10 ? * 每天上午 10:15 触发 0 15 10 ? 2018 2018 年的每天上午 10:15 触发 0 14 * ? 在每天下午 2 点到下午 2:59 期间的每 1 分钟触发 0 0/5 14 ? 在每天下午 2 点到下午 2:55 期间的每 5 分钟触发 0 0-5 14 ? 每天下午 2 点到下午 2:05 期间的每 1 分钟触发 0 10,44 14 ? 3 WED 每年三月的星期三的下午 2:10 和 2:44 触发 0 15 10 ? * MON-FRI 周一至周五的上午 10:15 触发 0 15 10 ? * 6L 每月的最后一个星期五上午 10:15 触发 0 15 10 ? * 6L 2002-2005 2002 年至 2005 年的每月的最后一个星期五上午 10:15 触发 0 15 10 ? * 6#3 每月的第三个星期五上午 10:15 触发 秒杀商品的增量更新和过期删除 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@Componentpublic class SeckillTask &#123; @Autowired private RedisTemplate redisTemplate; @Autowired private TbSeckillGoodsMapper seckillGoodsMapper; /** * 定时刷新秒杀商品 */ @Scheduled(cron="0/5 * * * * ?") // 每分钟执行一次 public void refreshSeckillGoods()&#123; System.out.println("执行了增量更新任务调度"+new Date()); // 查询 Redis 中所有商品键集合 List ids = new ArrayList&lt;&gt;(redisTemplate.boundHashOps("seckillGoods").keys()); // 第一次执行为 [] // 查询正在秒杀的商品列表 TbSeckillGoodsExample example = new TbSeckillGoodsExample(); Criteria criteria = example.createCriteria(); criteria.andStatusEqualTo("1"); // 已审核状态 criteria.andStockCountGreaterThan(0); // 库存量&gt;0 criteria.andStartTimeLessThanOrEqualTo(new Date()); // 当前时间大于等于开始时间 criteria.andEndTimeGreaterThanOrEqualTo(new Date());// 当前时间晚于结束时间 if(ids.size()&gt;0) criteria.andIdNotIn(ids); // 排除已存在的商品，实现增量更新 List&lt;TbSeckillGoods&gt; seckillGoodsList = seckillGoodsMapper.selectByExample(example ); // 从数据库中读取数据 // 装入缓存 for( TbSeckillGoods seckill:seckillGoodsList )&#123; redisTemplate.boundHashOps("seckillGoods").put(seckill.getId(), seckill); System.out.println("添加商品：" + seckill.getId()); &#125; System.out.println("将"+seckillGoodsList.size()+"条商品装入缓存"); &#125; // 每秒钟在缓存中查询已过期的商品，发现过期的秒杀商品后同步到数据库，并在缓存中移除该秒杀商品 @Scheduled(cron="* * * * * ?") // 每秒钟执行一次 public void removeSeckillGoods() &#123; System.out.println("执行了删除过期商品任务调度"+new Date()); List&lt;TbSeckillGoods&gt; seckillGoodsList = redisTemplate.boundHashOps("seckillGoods").values(); for( TbSeckillGoods seckillGood : seckillGoodsList) &#123; if (seckillGood.getEndTime().getTime()&lt;new Date().getTime()) &#123; redisTemplate.boundHashOps("seckillGoods").delete(seckillGood.getId()); // 删除缓存数据 seckillGoodsMapper.updateByPrimaryKey(seckillGood); // 向数据库保存记录 System.out.println("移除秒杀商品："+seckillGood.getId()); &#125; &#125; &#125;&#125; Maven Profile 项目开发中会用到很多配置文件，比如 mysql 、redis 以及其他很多的 properties 配置文件。而在我们开发和部署的时候（开发环境、测试环境、生产环境），这些配置文件往往是不同的。而如果需要我们每次去切换也是非常麻烦的。而 Maven Profile 就可以帮我们完成动态选择配置文件的工作。profile 可以让我们定义一系列的配置信息，然后指定其激活条件。 动态切换模块的端口号，比如对于 page-web 模块来说，默认端口号为9105. 123456789101112131415161718192021222324252627282930313233343536373839&lt;!-- 配置默认属性 方式一 &lt;properties&gt; &lt;port&gt;9105&lt;/port&gt; &lt;/properties&gt; --&gt; &lt;profiles&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;properties&gt; &lt;port&gt;9105&lt;/port&gt; &lt;/properties&gt; &lt;activation&gt; &lt;!-- 配置默认属性 方式二 --&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;pro&lt;/id&gt; &lt;properties&gt; &lt;port&gt;9205&lt;/port&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;!-- 指定端口 --&gt; &lt;port&gt;$&#123;port&#125;&lt;/port&gt; &lt;!-- 请求路径 --&gt; &lt;path&gt;/&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 当我们执行命令 tomcat7:run -P pro 发现以 9205 端口启动，执行命令 tomcat7:run -P dev 发现以 9105 端口启动。 （-P 后边为 profile 的 id）而当我们不指定环境时，默认环境为开发环境。上述代码提供两种配置方式。 切换数据库连接配置 对于数据库操作模块（dao）在 src/main/resources/properties/目录下有 db.properties 配置文件。其中配置了连接数据库的相关配置，数据库驱动、url、用户名、密码等。 (1) 首先编写不同的环境配置文件，在资源文件夹目录下创建 filter 文件夹，添加多个不同环境下配置文件。 12345# 生成环境下的配置文件env.jdbc.driver=com.mysql.jdbc.Driverenv.jdbc.url=jdbc:mysql://localhost:3306/pinyougoudb?characterEncoding=utf-8env.jdbc.username=rootenv.jdbc.password=123456 将原来的 db.properties 文件修改为： 1234jdbc.driver=$&#123;env.jdbc.driver&#125;jdbc.url=$&#123;env.jdbc.url&#125;jdbc.username=$&#123;env.jdbc.username&#125;jdbc.password=$&#123;env.jdbc.password&#125; (2) 定义 Profile 1234567891011121314151617&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;properties&gt; &lt;env&gt;dev&lt;/env&gt; &lt;/properties&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;pro&lt;/id&gt; &lt;properties&gt; &lt;env&gt;pro&lt;/env&gt; &lt;/properties&gt; &lt;/profile&gt;&lt;/profiles&gt; (3) 资源过滤与变量替换 123456789101112&lt;build&gt; &lt;!-- 资源过滤与变量替换 --&gt; &lt;filters&gt; &lt;filter&gt;src/main/resources/filters/db_$&#123;env&#125;.properties&lt;/filter&gt; &lt;/filters&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; maven filter可利用指定的xxx.properties文件中对应的key=value对资源文件中的${key}进行替换，最终把你的资源文件中的 username=${key}替换成 username=value 即可完成对配置文件的动态选择。打包：对 dao 工程执行 package -P pro打包为jar文件。解压 jar 文件后可以发现 db.properties 配置中被替换为生产环境。测试运行时通过 install -P pro 执令，将生产环境添加到本地仓库中。 切换注册中心连接配置 在每一个项目中都存在对注册中心的配置，而这个 IP 地址信息在生产环境下肯定是需要进行修改的。 首先集中配置注册中心地址。 (1) 在 common 模块下的src/main/resources/properties目录中创建 dubbox.properties 配置文件并配置全局dubbox的地址：address=192.168.25.130:2181 (2) Spring 目录下创建 spring 配置文件 applicationContext-dubbox.xml 配置如下： 1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:dubbo="http://code.alibabatech.com/schema/dubbo" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;context:property-placeholder location="classpath*:properties/*.properties" /&gt; &lt;dubbo:registry protocol="zookeeper" address="$&#123;address&#125;"/&gt;&lt;/beans&gt; (3) 所有的服务工程与 web 工程都要依赖 pinyougou-common 。 并删除每个工程中关于注册中心地址的配置 (4) 安装 pinyougou-common 到本地仓库，然后测试运行。 MavenProfile 配置 (1) 创建 filters 文件夹，建立多个不同环境的 dubbox 配置。env.address=192.168.25.130:2181 (2) 修改 properties/dubbox.properties 文件。address=${env.address} (3) 定义 profile 1234567891011121314151617&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;properties&gt; &lt;env&gt;dev&lt;/env&gt; &lt;/properties&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;pro&lt;/id&gt; &lt;properties&gt; &lt;env&gt;pro&lt;/env&gt; &lt;/properties&gt; &lt;/profile&gt;&lt;/profiles&gt; (4) 资源配置与变量替换 1234567891011&lt;build&gt; &lt;filters&gt; &lt;filter&gt;src/main/resources/filters/dubbox_$&#123;env&#125;.properties&lt;/filter&gt; &lt;/filters&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 遇到的问题： 所有的 web 工程在依赖 common 工程的情况下，如果不配置 &lt;dubbo:registry &gt; 的话会报错。 原因是 web 工程中无法依赖的 common 公共模块中的 applicationContext-dubbox.xml文件中的配置。存在两种问题: 1.该web工程为依赖 common 模块 2. 加载 spring 容器时，未添加 common 中applicationContext-dubbox.xml文件地址 1234567&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/spring-security.xml,classpath*:spring/applicationContext*.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; param-value 标签中如果有配置，则用逗号分隔即可。classpath*：不仅包含class路径，还包括jar文件中(class路径)进行查找。有时候会用模糊匹配的方式去配置多个配置文件。 但是如果配置文件是在jar包里，模糊匹配就找不到了。可以用逗号隔开的方式配置多个配置文件。 MongoDB 一个跨平台的，面向文档的数据库。它介于关系数据库和非关系数据库之间，是非关系数据库当中功能最丰富，最像关系数据库的产品。它支持的数据结构非常松散，是类似 JSON 的 BSON 格式，因此可以存储比较复杂的数据类型。 特性： 面向集合存储、易于存储对象类型的数据 模式自由，对象的字段没有固定的限制 支持动态查询，查询语言强大 支持完全索引 支持复制和故障恢复 使用高效的二进制数据存储，可存放图片、视频等大文件 支持多种语言 结构层次： 使用场景： 数据量较大时，数据价值不高时。比如评论系统、商品足迹信息。 其他业务功能分析 用户中心 订单中心：订单信息、商品收获、商品评价、物流信息跟踪 秒杀订单中心：同用户中心 我的收藏：商品收藏信息的管理 我的足迹：足迹信息管理 个人信息管理：信息完善、收货地址信息、密码管理、手机认证 商家后台 订单管理： 查询、发货、退货 秒杀订单管理：秒杀中的商品在redis中、已完成的秒杀商品在数据库中 运营商后台 订单管理：所有商家订单的信息管理 秒杀订单管理：查询 评价系统 数据访问层：对 mongodb 数据库的操作 服务层：逻辑实现 评价系统在工程中的调用：（1）在商品详细页显示该商品的所有评论信息（CORS 跨域）（2）用户中心 web 工程引用评价服务 可以对已收货的订单追加评价。（3）商家后台 web 工程引用评价服务 可以查看订单的评价（4）运营商后台 web 工程引用评价服务 可以查看订单的评价（5）任务服务 pinyougou-task-service 引用评价服务和搜索服务，统计每个商品的评价更新到 solr 索引库中。 商家首页 商家商品信息的显示、用户也可以直接进入商家的首页选择该商家的商品 资金结算 平台作为第三方，用户付款到平台，然后平台定时给商家结算。存在佣金的问题，平台可能按照不同商品类型收取不同比例的销售提成。]]></content>
      <categories>
        <category>项目学习</category>
      </categories>
      <tags>
        <tag>品优购</tag>
        <tag>电商系统</tag>
        <tag>项目实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[品优购项目笔记（中）]]></title>
    <url>%2F2018%2F12%2F20%2F%E5%93%81%E4%BC%98%E8%B4%AD%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[网页静态化技术网页静态化技术和缓存技术的共同点都是为了减轻数据库的访问压力，但是具体的应用场景不同，缓存比较适合小规模的数据，而网页静态化比较适合大规模且相对变化不太频繁的数据。另外网页静态化还有利于 SEO（搜索引擎优化）。静态界面通过 Nginx 服务器部署可以达到5万的并发，而Tomcat只有几百。 Freemarker 模板引擎，基于模板来生成文本输出。与web容器无关。 模板文件的元素 文本，直接输出的部分 注释，&lt;#– 该内容不会输出 –&gt; 插值，${…} 将使用数据模型中的部分来替代输出 FTL 指令，实现逻辑 生成文件 12345678910111213141516171819202122public static void main(String[] args) throws IOException, TemplateException &#123; // 1. 创建一个配置对象 Configuration configuration = new Configuration(Configuration.getVersion()); // 2. 设置模板所在的目录 configuration.setDirectoryForTemplateLoading(new File("E:\\eclipse-workspace\\freemarkerDemo\\src\\main\\resources\\")); // 3. 设置默认字符编码 configuration.setDefaultEncoding("utf-8"); // 4. 加载模板，创建一个模板对象 Template template = configuration.getTemplate("test.ftl"); // 5. 模板的数据集模型 Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put("name", "Mindyu"); map.put("message", "this is a freemarker demo!"); // 6. 模板输出流对象 Writer out = new FileWriter("d:\\src\\test.html"); // 7. 输出文件 template.process(map, out); // 8. 关闭输出流对象 out.close(); &#125; FTL 指令 assgin 用于在页面上定义一个变量：&lt;#assign info={“mobile”:”aa”,’address’:’11’} &gt; include 用于模板文件的嵌套：&lt;#include “head.ftl”&gt; if 指令 条件判断语句 list 指令 对集合的遍历 (goods_index 获得索引) 123&lt;#list goodsList as goods&gt; $&#123;goods_index+1&#125; 商品名称： $&#123;goods.name&#125; 价格：$&#123;goods.price&#125;&lt;br&gt;&lt;/#list&gt; 内建函数 （语法格式：变量+?+函数名称） ${goodsList?size} 获取集合的大小 &lt;#assign object=text?eval&gt; 转换 JSON 字符串为对象 ${today?date} 当前日期 （dataModel.put(“today”, new Date());） ${today?time} 当前时间 ${today?datetime} 当前日期+时间 ${today?string(“yyyy年MM月”)} 日期格式化 ${number} 数字会以每三位一个分隔符显示 123,456,789 ${number?c} 将数字转换为字符串 空值处理运算符 variable?? 判断变量是否存在，存在则返回true ${aaa!’-‘} 缺失变脸默认值,若aaa为空值则使用默认值‘-’ 运算符 算数运算符 +、-、*、/ 逻辑运算符 &amp;&amp; || ! 比较运算符 = 、==、!=、&gt;(gt)、&lt;(lt)、&gt;=(gte)、&lt;=(lte) 商品详情页的数据显示 ​ 创建 pinyougou-page-interface 工程，创建 com.pinyougou.page.service 包,包下创建接口 ItemPageService。然后再创建服务层，来实现接口方法。pom 文件中添加 freemarker 依赖。Spring 配置文件中添加 freemarker 的bean. 1234&lt;bean id="freemarkerConfig" class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer"&gt; &lt;property name="templateLoaderPath" value="/WEB-INF/ftl/" /&gt; &lt;property name="defaultEncoding" value="UTF-8" /&gt;&lt;/bean&gt; 服务层生成静态页面的方法： 123456789101112131415161718192021222324252627282930313233343536373839404142@Overridepublic boolean genItemHtml(Long goodsId) &#123; try &#123; Configuration configuration = freeMarkerConfig.getConfiguration(); Template template = configuration.getTemplate("item.ftl"); // 创建数据模型 Map&lt;Object, Object&gt; dataModel = new HashMap&lt;&gt;(); // 1.商品主表信息 TbGoods goods = goodsMapper.selectByPrimaryKey(goodsId); dataModel.put("goods", goods); // 2.商品详细信息 TbGoodsDesc goodsDesc = goodsDescMapper.selectByPrimaryKey(goodsId); dataModel.put("goodsDesc", goodsDesc); // 3.读取商品分类 String itemCat1 = itemCatMapper.selectByPrimaryKey(goods.getCategory1Id()).getName(); String itemCat2 = itemCatMapper.selectByPrimaryKey(goods.getCategory2Id()).getName(); String itemCat3 = itemCatMapper.selectByPrimaryKey(goods.getCategory3Id()).getName(); dataModel.put("itemCat1", itemCat1); dataModel.put("itemCat2", itemCat2); dataModel.put("itemCat3", itemCat3); // 4.读取SKU列表信息 TbItemExample example = new TbItemExample(); Criteria criteria = example.createCriteria(); criteria.andGoodsIdEqualTo(goodsId); // 设置SPU信息 criteria.andStatusEqualTo("1"); // 存在状态 example.setOrderByClause("is_default desc"); // 按是否默认降序排序,目的是为了方便前端可以直接取出默认选项 List&lt;TbItem&gt; itemList = itemMapper.selectByExample(example); dataModel.put("itemList", itemList); Writer out = new FileWriter("D:\\src\\item\\"+goodsId+".html"); template.process(dataModel, out); out.close(); return true; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (TemplateException e) &#123; e.printStackTrace(); &#125; return false;&#125; 在运营商管理后台引入依赖，因为需要在运营商审核之后生成静态页面。 freemarker 图片列表的生成（扩展属性、规格列表类似） ​ 通过 assign指令，将字符串转换为对象格式&lt;#assign imageList=goodsDesc.itemImages?eval /&gt;，然后在图片显示区遍历图片对象。 12345678910111213141516171819&lt;!--默认第一个预览--&gt;&lt;div id="preview" class="spec-preview"&gt; &lt;#if (imageList?size&gt;0)&gt; &lt;span class="jqzoom"&gt;&lt;img jqimg="$&#123;imageList[0].url&#125;" src="$&#123;imageList[0].url&#125;" width="400px" height="400px"/&gt;&lt;/span&gt; &lt;/#if&gt;&lt;/div&gt;&lt;!--下方的缩略图--&gt;&lt;div class="spec-scroll"&gt; &lt;a class="prev"&gt;&amp;lt;&lt;/a&gt; &lt;!--左右按钮--&gt; &lt;div class="items"&gt; &lt;ul&gt; &lt;#list imageList as item&gt; &lt;li&gt;&lt;img src="$&#123;item.url&#125;" bimg="$&#123;item.url&#125;" onmousemove="preview(this)" /&gt;&lt;/li&gt; &lt;/#list&gt; &lt;/ul&gt; &lt;/div&gt; &lt;a class="next"&gt;&amp;gt;&lt;/a&gt;&lt;/div&gt; 商品详情页-前端逻辑 ​ 静态页面的动态效果，就需要 angularjs 来实现。比如商品购买数量的点击事件对应到angularjs的变量中、规格的选择。都已变量的形式与页面进行绑定。 ​ 不同规格的标题、价格等信息都不相同（SKU信息），为了实现静态页面的效果可以在将SKU信息生成到静态页面。以变量的形式保存在前端。然后用户点击不同规格时，去匹配对应的SKU列表中的某一条数据。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 //控制层 app.controller('itemController' ,function($scope)&#123; $scope.specificationItems=&#123;&#125;; // 存储用户选择的规格 // 数量加减 $scope.addNum=function(x)&#123; $scope.num+=x; if ($scope.num&lt;1) $scope.num=1; &#125; // 选择规格 $scope.selectSpecification=function(key,value)&#123; $scope.specificationItems[key]=value; searchSku(); // 查询sku &#125; // 判断规格是否被选中 $scope.isSelected=function(key,value)&#123; if($scope.specificationItems[key]==value)&#123; return true; &#125;return false; &#125; $scope.sku=&#123;&#125;; // 加载默认的sku信息 $scope.loadSku=function()&#123; $scope.sku=skuList[0]; $scope.specificationItems=JSON.parse(JSON.stringify($scope.sku.spec)); // 深克隆 &#125; // 判断两个对象是否匹配 isEqual=function(map1,map2)&#123; for(var k in map1)&#123; if(map1[k]!=map2[k])&#123; return false; &#125; &#125; for(var k in map2)&#123; if(map2[k]!=map1[k])&#123; return false; &#125; &#125; return true; &#125; // 根据规格查询sku信息 searchSku=function()&#123; for(var i=0;i&lt;skuList.length;i++)&#123; if( isEqual($scope.specificationItems, skuList[i].spec) )&#123; $scope.sku=skuList[i]; return; &#125; &#125; $scope.sku=&#123;id:0,title:'--------',price:0&#125;; &#125; // 添加到购物车 $scope.addToCart=function()&#123; alert('sku_id:'+ $scope.sku.id); &#125; &#125;); 系统模块的对接 ​ 运营商管理后台在审核之后进行静态页面的生成。创建 page-web 工程，用于存储生成页面。实现前端 angular 动态逻辑和静态模板的实现。 ​ 修改搜索系统模块中的search.html。点击搜索页面的图片跳转到静态页面。 消息中间件解决方案 JMS消息中间件 ​ 消息中间件利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息排队模型，它可以在分布式环境下扩展进程间的通信。对于消息中间件，常见的角色大致也就有 Producer（生产者）、Consumer（消费者）。 常见产品: ActiveMQ Apache 出品，最流行的，能力强劲的开源消息总线。 RabbitMQ AMQP 协议的领导实现，支持多种场景。 ZeroMQ 史上最快的消息队列系统 Kafka 高吞吐，在一台普通的服务器上就可以达到 10W/s的吞吐速率；完全的分布式系统。适合处理海量数据。 JMS（Java 消息服务） ​ Java 平台上有关面向消息中间件的技术规范，它便于消息系统中的 Java 应用程序进行消息交换，并且通过提供标准的产生、发送、接收消息的接口简化企业应用的开发。是一系列接口规范。 ​ 消息是 JMS 中的一种类型对象，由两部分组成：报头和消息主体。报头由路由信息以及有关该消息的元数据组成。消息主体则携带着应用程序的数据或有效负载。消息正文格式： TextMessage–一个字符串对象 MapMessage–一套名称-值对 ObjectMessage–一个序列化的 Java 对象 BytesMessage–一个字节的数据流 StreamMessage – Java 原始值的数据流 JMS 消息传递类型 点对点模式：一个生产者一个消费者，存在多个消费者时，只有一个消费者可以获取消息。（未消费的消息会存储在队列中直到被消费） 发布订阅模式：一个生产者产生消息并进行发送后，可以由多个消费者进行接收。（如果消息发送时没有消费者，那么这个消息无效，不会再被消费） 安装 ​ 下载、解压、赋权、启动服务（./activemq start）。ActiveMQ 管理页面端口8161。（用户：admin 密码：admin） 点对点模式案例 ​ 引入依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-client&lt;/artifactId&gt; &lt;version&gt;5.13.4&lt;/version&gt;&lt;/dependency&gt; ​ 消息生产者: 12345678910111213141516171819202122public static void main(String[] args) throws JMSException &#123; // 1. 创建连接工厂 ConnectionFactory connectionFactory = new ActiveMQConnectionFactory("tcp://192.168.25.130:61616"); // 2. 创建连接对象 Connection connection = connectionFactory.createConnection(); // 3. 启动连接 connection.start(); // 4. 获取session（会话对象） 参数1：是否启动事务 参数2：消息确认方式 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 5. 创建队列对象 Queue queue = session.createQueue("test-queue"); // 6. 创建消息生产者对象 MessageProducer producer = session.createProducer(queue); // 7. 创建消息对象（TextMessage） TextMessage message = session.createTextMessage("这是一条text消息"); // 8. 发送消息 producer.send(message); // 9. 关闭资源 producer.close(); session.close(); connection.close();&#125; 注：创建session的第二个参数为消息确认模式：AUTO_ACKNOWLEDGE = 1 自动确认、CLIENT_ACKNOWLEDGE = 2 客户端手动确认、DUPS_OK_ACKNOWLEDGE = 3 自动批量确认、SESSION_TRANSACTED = 0 事务提交并确认。 ​ 消息消费者： 1234567891011121314151617181920212223242526272829303132public static void main(String[] args) throws JMSException, IOException &#123; // 1. 创建连接工厂 ConnectionFactory connectionFactory = new ActiveMQConnectionFactory("tcp://192.168.25.130:61616"); // 2. 创建连接对象 Connection connection = connectionFactory.createConnection(); // 3. 启动连接 connection.start(); // 4. 获取session（会话对象） 参数1：是否启动事务 参数2：消息确认方式 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 5. 创建队列对象 Queue queue = session.createQueue("test-queue"); // 6. 创建消息的消费者对象 MessageConsumer consumer = session.createConsumer(queue); // 7. 设置监听 consumer.setMessageListener(new MessageListener() &#123; @Override public void onMessage(Message message) &#123; TextMessage textMessage = (TextMessage) message; try &#123; System.out.println(""+ textMessage.getText()); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); // 8. 等待键盘输入 System.in.read(); // 9. 关闭资源 consumer.close(); session.close(); connection.close();&#125; 发布订阅模式 ​ 只需要修改上述第五步中，创建对应的主题对象即可Topic topic = session.createTopic(&quot;test-topic&quot;); JMS 应用 ​ 运营商后台管理模块中，商品审核之后需要导入 solr 索引库和生成静态页面。对于这种同步调用的情况存在耦合度高、后期不易维护、同步执行、导致审核过程缓慢、用户体验性不好等多种问题。我们可以采用消息中间件来进行解耦，实现运营商后端与搜索服务的零耦合。运营商执行审核后，向activeMQ 发送消息（SKU列表），搜索服务从activeMQ接收到消息执行导入操作。 ​ 然后搜索模块采用 solr 系统实现，那么我们可以采用点对点的方式实现消息服务，而静态页面生成服务，由于静态页面存储于多个服务器，并且各个服务器数据相同，需要实现服务器之间同步更新的效果，所以需要采用发布订阅的方式实现。 导入搜索系统的消息生产者实现： 解除耦合（移除itemService服务依赖） 引入activeMQ客户端依赖、spring-jms依赖。 创建jms生产者配置文件 123456789101112131415161718192021222324252627282930313233&lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供--&gt; &lt;bean id="targetConnectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory"&gt; &lt;property name="brokerURL" value="tcp://192.168.25.130:61616"/&gt; &lt;/bean&gt; &lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt; &lt;bean id="connectionFactory" class="org.springframework.jms.connection.SingleConnectionFactory"&gt; &lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt; &lt;property name="targetConnectionFactory" ref="targetConnectionFactory"/&gt; &lt;/bean&gt; &lt;!-- Spring提供的JMS工具类，它可以进行消息发送、接收等 --&gt; &lt;bean id="jmsTemplate" class="org.springframework.jms.core.JmsTemplate"&gt; &lt;!-- 这个connectionFactory对应的是我们定义的Spring提供的那个ConnectionFactory对象 --&gt; &lt;property name="connectionFactory" ref="connectionFactory"/&gt; &lt;/bean&gt; &lt;!--这个是队列目的地，点对点的 文本信息--&gt; &lt;bean id="queueSolrDestination" class="org.apache.activemq.command.ActiveMQQueue"&gt; &lt;constructor-arg value="pinyougou_queue_solr"/&gt; &lt;/bean&gt; &lt;!--这个是队列目的地，点对点的 文本信息，删除操作--&gt; &lt;bean id="queueSolrDeleteDestination" class="org.apache.activemq.command.ActiveMQQueue"&gt; &lt;constructor-arg value="pinyougou_queue_solr_delete"/&gt; &lt;/bean&gt; &lt;!--这个是订阅模式 生成页面--&gt; &lt;bean id="topicPageDestination" class="org.apache.activemq.command.ActiveMQTopic"&gt; &lt;constructor-arg value="pinyougou_topic_page"/&gt; &lt;/bean&gt; &lt;!--这个是订阅模式 删除页面--&gt; &lt;bean id="topicPageDeleteDestination" class="org.apache.activemq.command.ActiveMQTopic"&gt; &lt;constructor-arg value="pinyougou_topic_page_delete"/&gt; &lt;/bean&gt; web.xml文件中引入该配置文件(contextConfigLocation) 代码实现，注入所用的对象服务(jmsTemplate、queueSolrDestination、queueSolrDeleteDestination) 123456789101112131415161718192021222324/********导入到索引库**********/// 得到需要的SKU列表List&lt;TbItem&gt; itemList = goodsService.findItemListByGoodsIdAndStatus(ids, status);// 导入到solr // itemSearchService.importItemList(itemList);final String jsonString = JSON.toJSONString(itemList); // 转换为json字符串jmsTemplate.send(queueSolrDestination, new MessageCreator() &#123; @Override public Message createMessage(Session session) throws JMSException &#123; return session.createTextMessage(jsonString); &#125;&#125;);/********生成静态页面**********//*for (final Long id : ids) &#123; itemPageService.genItemHtml(id);&#125;*/jmsTemplate.send(topicPageDestination, new MessageCreator() &#123; @Override public Message createMessage(Session session) throws JMSException &#123; return session.createObjectMessage(ids); &#125;&#125;); 消息消费者（搜索服务） 添加 activeMQ 依赖 添加spring配置文件 applicationContext-jms-consumer.xml 12345678910111213141516171819202122232425262728293031323334&lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供--&gt; &lt;bean id="targetConnectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory"&gt; &lt;property name="brokerURL" value="tcp://192.168.25.130:61616"/&gt; &lt;/bean&gt;&lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt; &lt;bean id="connectionFactory" class="org.springframework.jms.connection.SingleConnectionFactory"&gt; &lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt; &lt;property name="targetConnectionFactory" ref="targetConnectionFactory"/&gt; &lt;/bean&gt; &lt;!--这个是队列目的地，导入到索引库--&gt; &lt;bean id="queueSolrDestination" class="org.apache.activemq.command.ActiveMQQueue"&gt; &lt;constructor-arg value="pinyougou_queue_solr"/&gt; &lt;/bean&gt; &lt;!-- 消息监听容器 --&gt;&lt;bean class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt; &lt;property name="connectionFactory" ref="connectionFactory" /&gt; &lt;property name="destination" ref="queueSolrDestination" /&gt; &lt;property name="messageListener" ref="itemSearchListener" /&gt;&lt;/bean&gt;&lt;!--这个是队列目的地，删除索引库--&gt; &lt;bean id="queueSolrDeleteDestination" class="org.apache.activemq.command.ActiveMQQueue"&gt; &lt;constructor-arg value="pinyougou_queue_solr_delete"/&gt; &lt;/bean&gt; &lt;!-- 消息监听容器 --&gt;&lt;bean class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt; &lt;property name="connectionFactory" ref="connectionFactory" /&gt; &lt;property name="destination" ref="queueSolrDeleteDestination" /&gt; &lt;property name="messageListener" ref="itemDeleteListener" /&gt;&lt;/bean&gt; 消息监听类： 12345678910111213141516171819202122@Componentpublic class ItemSearchListener implements MessageListener &#123; @Autowired private ItemSearchService itemSearchService; @Override public void onMessage(Message message) &#123; TextMessage textMessage = (javax.jms.TextMessage) message; try &#123; String text = textMessage.getText(); System.out.println("监听到消息："+text); List&lt;TbItem&gt; itemlist = JSON.parseArray(text,TbItem.class); itemSearchService.importItemList(itemlist); System.out.println("导入到solr索引库"); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 商品删除（移除solr索引库记录）类似。以及网页静态化，主要是消息模式为发布订阅模式。运营商执行商品审核后，向 activeMQ 发送消息（商品 ID集合），网页生成服务从 activeMQ 接收到消息后执行网页生成操作。 系统模块依赖关系图 存在的问题 1Exception sending context initialized event to listener instance of class org.springframework.web.context.ContextLoaderListener org.springframework.beans.factory.BeanDefinitionStoreException: Invalid bean definition with name 'dataSource' defined in URL [jar:file:/D:/Program%20Files/Maven/repository/com/pinyougou/pinyougou-dao/0.0.1-SNAPSHOT/pinyougou-dao-0.0.1-SNAPSHOT.jar!/spring/applicationContext-dao.xml]: Could not resolve placeholder 'jdbc.url' in string value "&#123;jdbc.url&#125;"; nested exception is java.lang.IllegalArgumentException: Could not resolve placeholder 'jdbc.url' in string value "&#123;jdbc.url&#125;" 提示找不到配置文件中的jdbc.url配置。是因为在page-service中，在生成静态页面时会用到一个页面生成路径的配置信息。然后在spring中的配置文件中设置&lt;context:property-placeholder location=&quot;classpath:config/page.properties&quot; /&gt; 。但是该服务依赖dao模块，这个模块中的数据库连接池的配置信息存放在 properties/db.properties 中，然后在 dao 模块中配置了 &lt;context:property-placeholder location=&quot;classpath*:properties/*.properties&quot; /&gt; 。此时 page-service 模块中的配置会覆盖该配置，就导致了无法访问 properties/db.properties 中数据库连接池的配置信息。解决方法就是使 &lt;context:property-placeholder location=&quot;classpath*:*/*.properties&quot; /&gt; 包含 dao 模块中的加载配置即可。 SpringBoot 框架与短信解决方案Spring Boot入门 Spring 为企业级 Java 开发提供了一种相对简单的方法，通过依赖注入和面向切面编程，用简单的 Java 对象（Plain Old Java Object，POJO）实现了 EJB 的功能。 虽然 Spring 的组件代码是轻量级的，但它的配置却是重量级的。开始的基于XML配置，Spring2.5引入基于注解的组件扫描，3.0引入基于java的配置。主要是希望简化繁琐的配置。另外项目依赖管理也是一个难题，依赖的版本库会不会起冲突。 而Spring Boot解决了上述问题，它致力于帮助开发者更容易的创建基于 Spring 的应用程序和服务，让更多人的人更快的对 Spring 进行入门体验，为 Spring生态系统提供了一种固定的、约定优于配置风格的框架。 Spring Boot 具有的特性： 提供更快的入门体验 开箱即用，没有代码生成，也无需XML配置。也可以实现修改默认值。 提供大型项目中常见的非功能特性，如嵌入式服务器、安全、指标。 并不是Spring功能的增强，而是提供一种快速使用Spring的方式。 Spring Boot Demo 添加依赖 123456789101112&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.4.0.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;!-- web的启动器， 通过依赖传递引入web项目所需的jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 定义引导类 Application 1234567891011121314/*@SpringBootApplication 其实就是以下三个注解的总和@Configuration： 用于定义一个配置类@EnableAutoConfiguration ：Spring Boot 会自动根据你 jar包的依赖来自动配置项目。@ComponentScan： 告诉 Spring 哪个 packages 的用注解标识的类会被 spring 自动扫描并且装入 bean容器。*/@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125; &#125; Spring MVC 实现 hello world输出 123456789101112@RestControllerpublic class HelloWorldController &#123; @Autowired private Environment env; // 用于获取 application.properties 配置中的属性 @RequestMapping(&quot;/info&quot;) public String info() &#123; return &quot;hello world. url:&quot;+env.getProperty(&quot;url&quot;); &#125; &#125; 启动引导类即可， http://localhost:8080/info 常用配置： 端口号修改（只需要在 application.properties 文件中配置 server.port） 读取配置文件信息（注入 Environment 对象，使用getProperty方法） 热部署（pom文件中添加 spring-boot-devtools 依赖即可） Spring Boot与ActiveMQ整合 使用内嵌服务 spring-boot-starter-activemq 创建消息生产者 123456789101112@RestControllerpublic class QueueController &#123; @Autowired private JmsMessagingTemplate jmsMessagingTemplate; @RequestMapping(&quot;/send&quot;) public void sendMessage(String text) &#123; jmsMessagingTemplate.convertAndSend(&quot;spring_boot_text&quot;, text); &#125; &#125; 创建消息消费者 123456789@Componentpublic class Consumer &#123; @JmsListener(destination=&quot;spring_boot_text&quot;) // destination和消息生产者相同 public void readMessage(String text) &#123; System.out.println(&quot;接收到消息：&quot;+text); &#125; &#125; 启动服务即可。http://localhost:8088/send.do?text=aaaaaa Spring Boot内置了ActiveMQ服务。 常用配置： 注：引入外部的ActiveMQ服务spring.activemq.broker-url=tcp://192.168.25.130:61616 短信解决方案 项目需求 构建一个通用的短信发送服务（独立于品优购的单独工程），接收 activeMQ 的消息（MAP类型） 消息包括手机号（mobile）、短信模板号（template_code）、签名（sign_name）、参数字符串（param ）。该微服务通过短信验证码平台的API，实现验证码的发送功能。 验证码发送平台 ​ 由于阿里大于注册需要认证，比较繁琐，所以此处先不实现验证码发送模块。腾讯云的短信服务可以个人认证，但是需要域名备案，这个功能先预留，后期继续完成。 用户注册模块 工程搭建 用户服务接口层 user-interface 用户服务实现层 user-service 用户中心控制层 user-web 添加web.xml 引入依赖 user接口、spring依赖 添加 Spring 配置文件 静态原型页面 注册判断短信验证码 ​ 输入手机号，用户点击“获取验证码”，向后端传递手机号。后端随机生成六位数字作为验证码，同时将其保存在redis中（手机号作为key、验证码作为value）, 同时向 ActiveMQ 发送消息。然后短信监听服务接受消息然后向验证码平台发送消息。 ​ 用户点击完成注册时，后端根据手机号查询用户输入的验证码与redis中的验证码是否匹配，如果匹配那么就执行注册，向数据库添加一条用户记录，否则提示不能完成注册。 服务层： 123456789101112131415161718192021@Overridepublic void createSmsCode(String phone) &#123; // 1.生成六位随机码 String smsCode = (long)(Math.random()*1000000)+""; System.out.println("验证码："+smsCode); // 2.将验证码存入redis redisTemplate.boundHashOps("smscode").put(phone, smsCode); // 3.发送相应的消息给ActiveMQ // 待完成..... 将消息发送给ActiveMQ即可&#125;@Overridepublic boolean checkSmsCode(String phone, String smsCode) &#123; // 获取redis中的验证码 String systemCode = (String) redisTemplate.boundHashOps("smscode").get(phone); if (systemCode == null || !systemCode.equals(smsCode)) &#123; return false; &#125; return true;&#125; 控制层： 12345678910111213141516171819202122232425262728293031/** * 注册用户 * @param user * @return */@RequestMapping("/add")public Result add(@RequestBody TbUser user,String smsCode)&#123; // 用户注册前进行校验（用户输入的验证码和redis中的验证码进行比较） if (!userService.checkSmsCode(user.getPhone(), smsCode)) &#123; return new Result(false, "验证码有误"); &#125; try &#123; userService.add(user); return new Result(true, "注册成功"); &#125; catch (Exception e) &#123; e.printStackTrace(); return new Result(false, "注册失败"); &#125;&#125; /** * 生成验证码 * @param phone */@RequestMapping("/createSmsCode")public Result createSmsCode(String phone) &#123; if (PhoneFormatCheckUtils.isPhoneLegal(phone)) &#123; userService.createSmsCode(phone); return new Result(true, "验证码发送成功"); &#125; return new Result(false, "验证码发送失败");&#125; 前端控制层： 1234567891011121314151617181920212223242526272829 //控制层 app.controller(&apos;userController&apos; ,function($scope,$controller,userService)&#123; // 注册 $scope.register=function()&#123; // 判断两次输入密码是否一致 if ($scope.entity.password!=$scope.password) &#123; alert(&quot;两次输入的密码不一致，请重新输入&quot;); $scope.entity.password = &quot;&quot;; $scope.password = &quot;&quot;; return ; &#125; // 新增 userService.add($scope.entity,$scope.smsCode).success( function(response)&#123; alert(response.message); &#125; ); &#125; // 生成验证码 $scope.createSmsCode=function()&#123; userService.createSmsCode($scope.entity.phone).success( function(response)&#123; alert(response.message); &#125; ); &#125;&#125;); 单点登录解决方案 ​ 单点登录（Single Sign On），是目前比较流行的企业业务整合的解决方案之一。SSO 的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。对于分布式的项目，多个子系统分别部署在不同的服务器中，此时采用传统的 session 来记录用户信息是无法实现的。 CAS ​ CAS 为 Web 应用系统提供一种可靠的单点登录方法。CAS 包含两个部分： CAS Server 和 CAS Client。CAS Server 需要独立部署，主要负责对用户的认证工作；CAS Client 负责处理对客户端受保护资源的访问请求，需要登录时，重定向到 CAS Server。 原理图 访问流程： 访问服务：用户发送请求访问应用系统提供的服务资源（也是cas client） 定向认证：cas client 会重定向(浏览器url会变化)用户请求到 cas server 用户认证：和用户进行身份认证 发送票据：cas server生成一个ticket ，先给浏览器用户，然后浏览器将其带入到cas client端 验证票据：cas client 向 cas server 请求验证 ticket 的合法性 传输用户信息：验证通过，cas server 会将用户的信息传输给cas client cas 服务端部署 ​ cas 服务端就是一个 war 包，解压对应的压缩包，将cas-server-webapp-4.0.0.war放入tomcat的webapps下，启动tomcat完成解压。 常用配置修改 默认用户和密码为 casuser、Mellon。可以在 cas 的 WEB-INF-&gt;deployerConfigContext.xml 12345678&lt;bean id="primaryAuthenticationHandler" class="org.jasig.cas.authentication.AcceptUsersAuthenticationHandler"&gt; &lt;property name="users"&gt; &lt;map&gt; &lt;entry key="casuser" value="Mellon"/&gt; &lt;entry key="admin" value="admin"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; 端口号修改：修改tomcat的默认端口（conf/server.xml），然后 cas 的 WEB-INF/cas.properties 修改server.name=http://localhost:9100 单点退出然后跳转到目标页面 cas 的 WEB-INF/cas-servlet.xml 123&lt;bean id="logoutAction" class="org.jasig.cas.web.flow.LogoutAction"p:servicesManager-ref="servicesManager"p:followServiceRedirects="$&#123;cas.logout.followServiceRedirects:true&#125;"/&gt; 去除https认证，cas 默认使用的是 https 协议，该协议需要申请 SSL 证书。一般在开发测试阶段可以使用http协议即可。 修改 cas 的 WEB-INF/deployerConfigContext.xml，增加 p:requireSecure=”false” 123&lt;!-- Required for proxy ticket mechanism. --&gt;&lt;bean id="proxyAuthenticationHandler" class="org.jasig.cas.authentication.handler.support.HttpBasedServiceCredentialsAuthenticationHandler" p:httpClient-ref="httpClient" p:requireSecure="false"/&gt; 修改 cas 的/WEB-INF/spring-configuration/ticketGrantingTicketCookieGenerator.xml 12345&lt;bean id="ticketGrantingTicketCookieGenerator" class="org.jasig.cas.web.support.CookieRetrievingCookieGenerator" p:cookieSecure="false" p:cookieMaxAge="3600" p:cookieName="CASTGC" p:cookiePath="/cas" /&gt; 修改 cas 的 WEB-INF/spring-configuration/warnCookieGenerator.xml 12345&lt;bean id="warnCookieGenerator" class="org.jasig.cas.web.support.CookieRetrievingCookieGenerator" p:cookieSecure="false" p:cookieMaxAge="3600" p:cookieName="CASPRIVACY" p:cookiePath="/cas" /&gt; 注：参数 p:cookieSecure=”true”，TRUE 为采用 HTTPS 验证，FALSE 为不采用 https 验证。参数 p:cookieMaxAge=”-1”，是 COOKIE 的最大生命周期，-1 为无生命周期，即只在当前打开的窗口有效，关闭或重新打开其它窗口，仍会要求验证。可以根据需要修改为大于 0 的数字，比如 3600 等，意思是在 3600 秒内，打开任意窗口，都不需要验证。 CAS 客户端Demo 创建 casclient_demo1 工程(war) 引入cas client依赖。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;dependencies&gt; &lt;!-- cas --&gt; &lt;dependency&gt; &lt;groupId&gt;org.jasig.cas.client&lt;/groupId&gt; &lt;artifactId&gt;cas-client-core&lt;/artifactId&gt; &lt;version&gt;3.3.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.7&lt;/source&gt; &lt;target&gt;1.7&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;configuration&gt; &lt;webResources&gt; &lt;resource&gt; &lt;directory&gt;src/main/webapp/WEB-INF&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;targetPath&gt;WEB-INF&lt;/targetPath&gt; &lt;/resource&gt; &lt;/webResources&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!-- 指定端口 --&gt; &lt;port&gt;9001&lt;/port&gt; &lt;!-- 请求路径 --&gt; &lt;path&gt;/&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 添加 web.xml 配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;!-- 用于单点退出，该过滤器用于实现单点登出功能，可选配置 --&gt;&lt;listener&gt; &lt;listener-class&gt;org.jasig.cas.client.session.SingleSignOutHttpSessionListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;!-- 该过滤器用于实现单点登出功能，可选配置。 --&gt;&lt;filter&gt; &lt;filter-name&gt;CAS Single Sign Out Filter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.session.SingleSignOutFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CAS Single Sign Out Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;!-- 该过滤器负责用户的认证工作，必须启用它 --&gt;&lt;filter&gt; &lt;filter-name&gt;CASFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.authentication.AuthenticationFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;casServerLoginUrl&lt;/param-name&gt; &lt;param-value&gt;http://localhost:9100/cas/login&lt;/param-value&gt; &lt;!--这里的 server 是服务端的 IP --&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;serverName&lt;/param-name&gt; &lt;param-value&gt;http://localhost:9001&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CASFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;!-- 该过滤器负责对 Ticket 的校验工作，必须启用它 --&gt;&lt;filter&gt; &lt;filter-name&gt;CAS Validation Filter&lt;/filter-name&gt; &lt;filter-class&gt; org.jasig.cas.client.validation.Cas20ProxyReceivingTicketValidationFilter &lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;casServerUrlPrefix&lt;/param-name&gt; &lt;param-value&gt;http://localhost:9100/cas&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;serverName&lt;/param-name&gt; &lt;param-value&gt;http://localhost:9001&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CAS Validation Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;!-- 该过滤器负责实现 HttpServletRequest 请求的包裹， 比如允许开发者通过 HttpServletRequest 的 getRemoteUser() 方法获得 SSO 登录用户的登录名，可选配置。 --&gt;&lt;filter&gt; &lt;filter-name&gt;CAS HttpServletRequest Wrapper Filter&lt;/filter-name&gt; &lt;filter-class&gt; org.jasig.cas.client.util.HttpServletRequestWrapperFilter &lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CAS HttpServletRequest Wrapper Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;!-- 该过滤器使得开发者可以通过 org.jasig.cas.client.util.AssertionHolder 来获取用户的登录名。 比如 AssertionHolder.getAssertion().getPrincipal().getName()。 --&gt;&lt;filter&gt; &lt;filter-name&gt;CAS Assertion Thread Local Filter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.util.AssertionThreadLocalFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CAS Assertion Thread Local Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 主页面 index.jsp &lt;%=request.getRemoteUser()%&gt; 获取远程登录用户名 然后再创建客户端工程2。启动cas服务端和cas客户端，然后http://localhost:9001 和9002端口，都会跳转到cas的登录页面。实现单点登录。单点退出只需访问 http://localhost:9100/cas/logout即可。 CAS 服务端数据源设置 ​ 使用项目中 user 表中的用户信息来实现登录验证。 修改 cas 服务端的 WEB-INF/deployerConfigContext.xml 123456789101112131415161718192021222324&lt;!-- 数据源 --&gt;&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource" p:driverClass="com.mysql.jdbc.Driver" p:jdbcUrl="jdbc:mysql://127.0.0.1:3306/pinyougoudb?characterEncoding=utf8" p:user="root" p:password="123456" /&gt;&lt;!-- 默认密码解码方式 --&gt;&lt;bean id="passwordEncoder" class="org.jasig.cas.authentication.handler.DefaultPasswordEncoder" c:encodingAlgorithm="MD5" p:characterEncoding="UTF-8" /&gt;&lt;bean id="dbAuthHandler" class="org.jasig.cas.adaptors.jdbc.QueryDatabaseAuthenticationHandler" p:dataSource-ref="dataSource" p:sql="select password from tb_user where username = ?" p:passwordEncoder-ref="passwordEncoder"/&gt;&lt;!----------------------另外配置认证管理器-------------------&gt;&lt;constructor-arg&gt; &lt;map&gt; &lt;entry key-ref="proxyAuthenticationHandler" value-ref="proxyPrincipalResolver" /&gt; &lt;!-- 默认的认证处理方式 &lt;entry key-ref="primaryAuthenticationHandler" value-ref="primaryPrincipalResolver" /&gt; --&gt; &lt;entry key-ref="dbAuthHandler" value-ref="primaryPrincipalResolver" /&gt; &lt;/map&gt; &lt;/constructor-arg&gt; 配置了数据库连接池相关信息，那么就需要把数据库相应的jar包引入 CAS 服务端界面改造 ​ cas server 服务端提供了默认的登录界面，那我们如何修改为我们自己需要的登录页面了。步骤如下： 将 login.html 拷贝到 cas 系统下的 WEB-INF\view\jsp\default\ui 目录下 将 css、js、img 等静态资源文件夹拷贝到 cas 目录下。web 工程的根目录 将原来的 casLoginView.jsp 改名（以做参照模板），将 login.html 改名为 casLoginView.jsp 添加 jsp 指令 修改 form 标签，保留原页面样式 修改用户名输入框，保留原页面样式 修改密码框，保留源页面样式 修改登录按钮，保留原页面的样式 错误提示&lt;form:errors path=&quot;*&quot; id=&quot;msg&quot; cssClass=&quot;errors&quot; element=&quot;div&quot; htmlEscape=&quot;false&quot; /&gt; 注：错误提示信息默认为英文，使用了国际化标准。在 cas 的 WEB-INF\classes 中的 messages_zh_CN.properties 文件中添加配置。 12authenticationFailure.AccountNotFoundException=用户名或密码错误authenticationFailure.FailedLoginException=用户名或密码错误 第一个是用户名不存在时的错误提示 第二个是密码错误的提示 修改 cas-servlet.xml，设置国际化为 zn_CN（默认为 en ） 。 12&lt;bean id="localeResolver" class="org.springframework.web.servlet.i18n.CookieLocaleResolver"p:defaultLocale="zh_CN" /&gt; 国际化：i18n。英文为：internationalization 。18表示中间的字符数。 用户中心实现单点登录（cas client与Spring Security集成） 引入 springSecurity、cas 客户端和 springSecurity Cas 整合包依赖 123456789101112131415161718192021222324&lt;!-- spring-security配置 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- spring-security-cas --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-cas&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.jasig.cas.client&lt;/groupId&gt; &lt;artifactId&gt;cas-client-core&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; web.xml 添加 spring-security 过滤器，设置首页 1234567891011121314151617181920&lt;welcome-file-list&gt; &lt;welcome-file&gt;home-index.html&lt;/welcome-file&gt;&lt;/welcome-file-list&gt;&lt;!-- 省略post乱码过滤器 --&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/spring-security.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;filter&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 构建 UserDetailsServiceImpl 认证类，实现UserDetailsService接口 123456789101112public class UserDetailServiceImpl implements UserDetailsService &#123; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; System.out.println("经过认证类："+username); Collection&lt;GrantedAuthority&gt; authorities = new ArrayList&lt;&gt;(); // 角色固定了，如果存在多种角色的话，那么此处可能会去数据库中查找来实现动态设置用户角色 authorities.add(new SimpleGrantedAuthority("ROLE_USER")); return new User(username, "", authorities); &#125;&#125; 添加 spring-security.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans:beans xmlns="http://www.springframework.org/schema/security" xmlns:beans="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security.xsd"&gt; &lt;!-- 匿名访问资源 --&gt; &lt;http pattern="/css/**" security="none"&gt;&lt;/http&gt; &lt;http pattern="/js/**" security="none"&gt;&lt;/http&gt; &lt;http pattern="/img/**" security="none"&gt;&lt;/http&gt; &lt;http pattern="/plugins/**" security="none"&gt;&lt;/http&gt; &lt;!-- 注册登陆 --&gt; &lt;http pattern="/register.html" security="none"&gt;&lt;/http&gt; &lt;http pattern="/user/add.do" security="none"&gt;&lt;/http&gt; &lt;http pattern="/user/createSmsCode.do" security="none"&gt;&lt;/http&gt; &lt;!-- entry-point-ref 入口点引用 --&gt; &lt;http use-expressions="false" entry-point-ref="casProcessingFilterEntryPoint"&gt; &lt;intercept-url pattern="/**" access="ROLE_USER"/&gt; &lt;csrf disabled="true"/&gt; &lt;!-- custom-filter为过滤器， position 表示将过滤器放在指定的位置上，before表示放在指定位置之前 ，after表示放在指定的位置之后 --&gt; &lt;custom-filter ref="casAuthenticationFilter" position="CAS_FILTER" /&gt; &lt;custom-filter ref="requestSingleLogoutFilter" before="LOGOUT_FILTER"/&gt; &lt;custom-filter ref="singleLogoutFilter" before="CAS_FILTER"/&gt; &lt;/http&gt; &lt;!-- CAS入口点 开始 --&gt; &lt;beans:bean id="casProcessingFilterEntryPoint" class="org.springframework.security.cas.web.CasAuthenticationEntryPoint"&gt; &lt;!-- 单点登录服务器登录URL --&gt; &lt;beans:property name="loginUrl" value="http://localhost:9100/cas/login"/&gt; &lt;beans:property name="serviceProperties" ref="serviceProperties"/&gt; &lt;/beans:bean&gt; &lt;beans:bean id="serviceProperties" class="org.springframework.security.cas.ServiceProperties"&gt; &lt;!--service 配置自身工程的根地址+/login/cas --&gt; &lt;beans:property name="service" value="http://localhost:9106/login/cas"/&gt; &lt;/beans:bean&gt; &lt;!-- CAS入口点 结束 --&gt; &lt;!-- 认证过滤器 开始 --&gt; &lt;beans:bean id="casAuthenticationFilter" class="org.springframework.security.cas.web.CasAuthenticationFilter"&gt; &lt;beans:property name="authenticationManager" ref="authenticationManager"/&gt; &lt;/beans:bean&gt; &lt;!-- 认证管理器 --&gt; &lt;authentication-manager alias="authenticationManager"&gt; &lt;authentication-provider ref="casAuthenticationProvider"&gt; &lt;/authentication-provider&gt; &lt;/authentication-manager&gt; &lt;!-- 认证提供者 --&gt; &lt;beans:bean id="casAuthenticationProvider" class="org.springframework.security.cas.authentication.CasAuthenticationProvider"&gt; &lt;beans:property name="authenticationUserDetailsService"&gt; &lt;beans:bean class="org.springframework.security.core.userdetails.UserDetailsByNameServiceWrapper"&gt; &lt;beans:constructor-arg ref="userDetailsService" /&gt; &lt;/beans:bean&gt; &lt;/beans:property&gt; &lt;beans:property name="serviceProperties" ref="serviceProperties"/&gt; &lt;!-- ticketValidator 为票据验证器 --&gt; &lt;beans:property name="ticketValidator"&gt; &lt;beans:bean class="org.jasig.cas.client.validation.Cas20ServiceTicketValidator"&gt; &lt;beans:constructor-arg index="0" value="http://localhost:9100/cas"/&gt; &lt;/beans:bean&gt; &lt;/beans:property&gt; &lt;beans:property name="key" value="an_id_for_this_auth_provider_only"/&gt; &lt;/beans:bean&gt; &lt;!-- 认证类 --&gt; &lt;beans:bean id="userDetailsService" class="com.pinyougou.user.service.UserDetailServiceImpl"/&gt; &lt;!-- 认证过滤器 结束 --&gt; &lt;!-- 单点登出 开始 --&gt; &lt;beans:bean id="singleLogoutFilter" class="org.jasig.cas.client.session.SingleSignOutFilter"/&gt; &lt;beans:bean id="requestSingleLogoutFilter" class="org.springframework.security.web.authentication.logout.LogoutFilter"&gt; &lt;beans:constructor-arg value="http://localhost:9100/cas/logout?service=http://localhost:9103"/&gt; &lt;!-- 退出登陆并跳转到首页 --&gt; &lt;beans:constructor-arg&gt; &lt;beans:bean class="org.springframework.security.web.authentication.logout.SecurityContextLogoutHandler"/&gt; &lt;/beans:constructor-arg&gt; &lt;beans:property name="filterProcessesUrl" value="/logout/cas"/&gt; &lt;!-- 此时直接请求 logout/cas 即可实现单点退出，相当于上面链接的一个别名 --&gt; &lt;/beans:bean&gt; &lt;!-- 单点登出 结束 --&gt; &lt;/beans:beans&gt; 获取当前登录用户名，借助Spring Security的方法。SecurityContextHolder.getContext().getAuthentication().getName();即可得到用户名信息。]]></content>
      <categories>
        <category>项目学习</category>
      </categories>
      <tags>
        <tag>品优购</tag>
        <tag>电商系统</tag>
        <tag>项目实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[品优购项目笔记（上）]]></title>
    <url>%2F2018%2F12%2F19%2F%E5%93%81%E4%BC%98%E8%B4%AD%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[品牌管理模块功能实现 运用AngularJS前端框架的常用指令 完成品牌管理的列表功能 完成品牌管理的分页列表功能 完成品牌管理的增加功能 完成品牌管理的修改功能 完成品牌管理的删除功能 完成品牌管理的条件查询功能 前端框架 AngularJS四大特征 MVC 模式 Model: 数据,其实就是angular变量($scope.XX); View: 数据的呈现,Html+Directive(指令); Controller: 操作数据,就是function,数据的增删改查; 双向绑定框架采用并扩展了传统HTML，通过双向的数据绑定来适应动态内容，双向的数据绑定允许模型和视图之间的自动同步。遵循声明式编程应该用于构建用户界面以及编写软件构建，而指令式编程非常适合来表示业务逻辑的理念。 依赖注入对象在创建的时候，其依赖对象由框架来自动创建并注入进来。即最少知道法则。 模块化设计 高内聚低耦合法则1)官方提供的模块 ng、ngRoute、ngAnimate2)用户自定义的模块 angular.module(‘模块名’,[ ]) 常见指令 ng-app 定义 AngularJS 应用程序的根元素，表示以下的指令 angularJS 都会识别，且在页面加载完时会自动初始化。 ng-model 指令用于绑定变量,将用户在文本框输入的内容绑定到变量上，而表达式可以实时地输出变量。 ng-init 对变量初始化或调用某方法。 ng-controller 用于指定所使用的控制器，在控制器中定义函数和变量，通过scope 对象来访问。 ng-click 单击事件指令，点击时触发控制器的某个方法。 ng-if 判断语句，条件不存在就不执行。 ng-repeat 指令用于循环集合变量。 $index 用于获取 ng-repeat 指令循环中的索引。 $http 内置服务，用于访问后端数据。 $location 服务，用于获取链接地址中的参数值。$location.search()[&#39;id&#39;]id对应的值。(注：地址中 ? 前需要添加 # ) eg: http://localhost:9102/admin/goods_edit.html#?id=149187842867969 ng-bind-html 指令用于显示 html 内容 app.filter 过滤器，通过 | 来调用过滤器 $sce 服务 严格控制上下文访问，为防止 跨站XSS。该服务可以实现安全控制，比如允许html标签的插入转换。 复选框的使用 ​ 定义一个用于存储选中 ID 的数组，当我们点击复选框后判断是选择还是取消选择，如果是选择就加到数组中，如果是取消选择就从数组中移除。在后续点击删除按钮时需要用到这个存储了 ID 的数组。 12345678910// 存储当前选中复选框的id集合$scope.selectIds = [];$scope.updateSelection = function($event, id)&#123; if ($event.target.checked) &#123; // 当前为勾选状态 $scope.selectIds.push(id); // 向selectIds集合中添加元素 &#125; else &#123; var index = $scope.selectIds.indexOf(id); $scope.selectIds.splice(index, 1); // 参数1：移除的下标位置，参数2：需要移除的元素个数 &#125;&#125; 规格及模板管理前端分层开发 ​ 运用 MVC 的思想，将 js 和 html 代码分离，提高程序的可维护性。 ​ 实现方式：自定义服务，同后端的 service 层，封装一些操作，比如请求后端数据。在不同控制器通过依赖注入相关服务，即可调用服务的方法。将代码分为前端页面、前端服务层、前端控制层。 主键回填 ​ 修改 Mapper.xml 文件 123&lt;selectKey resultType="java.lang.Long" order="AFTER" keyProperty="id"&gt; SELECT LAST_INSERT_ID() AS id&lt;/selectKey&gt; ​ 对于规格与具体规格选项，可以创建一个组合实体类，包括 规格 和 规格选项的集合。在插入规格之后，通过主键回填，获取规格 ID ，然后将 ID 作为外键添加到规格选项中去。 select2 组件-多选下拉列表 引入 select 2 相关的 js 和 css。 设置数据源 1$scope.brandList=&#123;data:[&#123;id:1,text:'联想'&#125;,&#123;id:2,text:'华为'&#125;,&#123;id:3,text:'小米'&#125;]&#125;; // 品牌列表 实现多选下拉框 1&lt;input select2 select2-model="entity.brandIds" config="brandList" multiple placeholder=" 选择品牌（可多选）" class="form-control" type="text"/&gt; multiple 表示可多选 Config 用于配置数据来源 select2-model 用于指定用户选择后提交的变量![select2多选下拉列表](https://hexoblog-1253306922.cos.ap-guangzhou.myqcloud.com/photo2018/%E5%93%81%E4%BC%98%E8%B4%AD/%E5%A4%9A%E9%80%89%E4%B8%8B%E6%8B%89%E6%A1%86.png) 模板列表显示 ​ 将从后台获取的 json 字符串中的某个属性的值提取出来，用逗号分隔，更直观的显示。 12345678910// 提取 json 字符串数据中某个属性，返回拼接字符串逗号分隔$scope.jsonToString = function(jsonString,key)&#123; var json=JSON.parse(jsonString); // 将 json 字符串转换为 json 对象 var value=""; for(var i=0;i&lt;json.length;i++)&#123; if(i&gt;0) value += ","； value += json[i][key]; &#125; return value;&#125; Spring Security 安全框架​ 为基于 Spring 的企业应用系统提供声明式的安全访问控制的解决方案。提供一组可以在 Spring 应用上下文中配置的 Bean。 使用步骤 引入 jar 包 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-web&lt;/artifactId&gt; &lt;version&gt;4.1.0.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt; &lt;version&gt;4.1.0.RELEASE&lt;/version&gt;&lt;/dependency&gt; web.xml 文件中引入 spring-security.xml 配置文件 123456789101112131415161718&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/spring-security.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt; &lt;/listener&gt; &lt;filter&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; spring-security.xml 配置文件设置页面拦截规则、认证管理器以及不拦截的资源（静态资源、登陆页面） 1234567891011121314151617181920212223242526272829&lt;!-- 设置页面不登陆也可以访问 --&gt;&lt;http pattern="/*.html" security="none"&gt;&lt;/http&gt;&lt;http pattern="/css/**" security="none"&gt;&lt;/http&gt;&lt;http pattern="/img/**" security="none"&gt;&lt;/http&gt;&lt;http pattern="/js/**" security="none"&gt;&lt;/http&gt;&lt;http pattern="/plugins/**" security="none"&gt;&lt;/http&gt;&lt;!-- 页面的拦截规则 use-expressions:是否启动SPEL表达式 默认是true --&gt;&lt;http use-expressions="false"&gt; &lt;!-- 当前用户必须有ROLE_USER的角色 才可以访问根目录及所属子目录的资源 --&gt; &lt;intercept-url pattern="/**" access="ROLE_ADMIN"/&gt; &lt;!-- 开启表单登陆功能 --&gt; &lt;form-login login-page="/login.html" default-target-url="/admin/index.html" authentication-failure-url="/login.html" always-use-default-target="true"/&gt; &lt;csrf disabled="true"/&gt; &lt;headers&gt; &lt;frame-options policy="SAMEORIGIN"/&gt; &lt;/headers&gt; &lt;logout/&gt; &lt;!-- 退出登录 --&gt;&lt;/http&gt;&lt;!-- 认证管理器 --&gt;&lt;authentication-manager&gt; &lt;authentication-provider&gt; &lt;user-service&gt; &lt;user name="admin" password="123456" authorities="ROLE_ADMIN"/&gt; &lt;user name="yang" password="123456" authorities="ROLE_ADMIN"/&gt; &lt;/user-service&gt; &lt;/authentication-provider&gt; &lt;/authentication-manager&gt; ​ CSRF（Cross-site request forgery）跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。 ​ XSS(跨站脚本攻击)利用站点内的信任用户，往Web页面里插入恶意Script代码 。 ​ CSRF通过伪装来自受信任用户的请求来利用受信任的网站。 商家系统登录安全控制安全控制 自定义认证类，创建类 UserDetailsServiceImpl.java 实现 UserDetailsService 接口 实现类中添加 SellerService 属性、和 setter 注入方法，修改 loadUserByUserName 方法。 配置 spring-security.xml。认证管理器中 authentication-provider 引用userDetailService 的bean，同时通过 dobbo 去依赖一个 sellerService 对象。 BCrypt 加密算法 ​ 用户表的密码通常使用 MD5 等不可逆算法加密后存储，为防止彩虹表破解更会先使用一个特定的字符串（如域名）加密，然后再使用一个随机的 salt（盐值）加密。 特定字符串是程序代码中固定的，salt 是每个密码单独随机，一般给用户表加一个字段单独存储，比较麻烦。 BCrypt 算法将 salt 随机并混入最终加密后的密码，验证时也无需单独提供之前的 salt，从而无需单独处理 salt 问题。 123456789101112131415161718192021222324252627282930/** * 认证类 * @author YCQ * */public class UserDetailsServiceImpl implements UserDetailsService&#123; private SellerService sellerService; public void setSellerService(SellerService sellerService) &#123; // 通过配置的方式添加 this.sellerService = sellerService; &#125; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;// System.out.println("执行 UserDetailsServiceImpl 认证"); // 构建角色列表 List&lt;GrantedAuthority&gt; grantAuths = new ArrayList&lt;&gt;(); grantAuths.add(new SimpleGrantedAuthority("ROLE_SELLER")); TbSeller seller = sellerService.findOne(username); if (seller!=null &amp;&amp; "1".equals(seller.getStatus())) &#123; return new User(username, seller.getPassword(), grantAuths); &#125;else &#123; return null; &#125; &#125;&#125; spring-security 配置 123456789101112131415161718&lt;!-- 认证管理器 --&gt;&lt;authentication-manager&gt; &lt;authentication-provider user-service-ref="userDetailService"&gt; &lt;password-encoder ref="bcryptEncoder"&gt;&lt;/password-encoder&gt; &lt;/authentication-provider&gt; &lt;/authentication-manager&gt;&lt;!-- 认证类 --&gt;&lt;beans:bean id="userDetailService" class="com.pinyougou.service.UserDetailsServiceImpl"&gt; &lt;beans:property name="sellerService" ref="mSellerService"&gt;&lt;/beans:property&gt;&lt;/beans:bean&gt;&lt;!-- 引用dubbo 服务 --&gt;&lt;dubbo:application name="pinyougou-shop-web" /&gt;&lt;dubbo:registry address="zookeeper://107.191.52.91:2181"/&gt;&lt;dubbo:reference id="mSellerService" interface="com.pinyougou.sellergoods.service.SellerService"&gt;&lt;/dubbo:reference&gt;&lt;beans:bean id="bcryptEncoder" class="org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder"&gt;&lt;/beans:bean&gt; 注：浏览器控制台提示 [DOM] Input elements should have autocomplete attributes (suggested: “current-password”) 为浏览器表单默认的记忆功能，可以在 input 标签中添加 autocomplete=”off|on” 即可。 商品分类管理多级分类列表 ​ 将商品分类分为三级，进入页面首先显示所有一级分类（主分类），点击查询下级，可查看当前主分类下的次分类，再次点击进入三级分类。三级分类为最后一级，列表中不显示查询下级按钮，同时更新面包屑导航。直接点击面包屑导航，可以实现直接层级跳转。 面包屑导航 123456789101112131415161718// 当前面包屑等级$scope.grade = 1;$scope.setGrade=function(value)&#123; $scope.grade = value;&#125;$scope.selectList=function(p_entity)&#123; if ($scope.grade == 1) &#123; $scope.entity_1 = null; $scope.entity_2 = null; &#125; else if ($scope.grade == 2)&#123; $scope.entity_1 = p_entity; $scope.entity_2 = null; &#125; else &#123; $scope.entity_2 = p_entity; &#125; $scope.findByParentId(p_entity.id);&#125; 页面配置 123&lt;li&gt;&lt;a href="#" ng-click="grade=1;selectList(&#123;id:0&#125;)"&gt;顶级分类列表&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#" ng-click="grade=2;selectList(entity_1)"&gt;&#123;&#123;entity_1.name&#125;&#125;&lt;/a&gt;&lt;/li&gt;&lt;li ng-if="entity_2!=null"&gt;&lt;a href="#" ng-click="grade=3;selectList(entity_2)"&gt;&#123;&#123;entity_2.name&#125;&#125;&lt;/a&gt;&lt;/li&gt; 修改商品分类 ​ 实现类型模板的下拉框，采用 select2 组件实现。 123&lt;td&gt;类型模板&lt;/td&gt;&lt;td&gt;&lt;input select2 ng-model="entity.typeId" config="itemList" placeholder="商品类型模板" class="form-control" type="text"/&gt;&lt;/td&gt; ​ config 为数据来源 ​ ng-model 绑定类型对象数据 ​ itemList 的来源：itemCatController 中 findItemList() 方法 -&gt; typeTemplateService 的 selectOptionList() 方法 -&gt; 请求后端 /typeTemplate/selectOptionList -&gt; TypeTemplateService 服务层 -&gt; TypeTemplateMapper 层方法 删除商品分类 ​ 判断所选分类下是否存在子分类，存在则不能删除。 123456789101112131415161718192021222324/** * 批量删除 * @param ids * @return */@RequestMapping("/delete")public Result delete(Long[] ids)&#123; try &#123; // 判断当前所有分类是否存在子分类 boolean flag = false; // 不存在 for (Long id : ids) &#123; if(itemCatService.findByParentId(id)!=null &amp;&amp; itemCatService.findByParentId(id).size()!=0)&#123; flag = true;break; &#125; &#125; if (flag) return new Result(false, "当前所选分类存在子分类，切勿删除"); itemCatService.delete(ids); return new Result(true, "删除成功"); &#125; catch (Exception e) &#123; e.printStackTrace(); return new Result(false, "删除失败"); &#125;&#125; SPU 与 SKU ​ SPU （标准产品单位）为商品信息聚合的最小单位是一组可复用、易检索的标准化信息的集合,该集合描述了一个产品的特性。属性相同、特性相同的商品为一个SPU。 ​ SKU （库存量单位） 为物理上不可分割的最小存货单元。不同的规格、颜色、款式为不同的SKU。 分布式文件服务器 FastDFS ​ FastDFS 是用 c 语言编写的一款开源的分布式文件系统。FastDFS 为互联网量身定制,充分考虑了冗余备份、负载均衡、线性扩容等机制,并注重高可用、高性能等指标,使用FastDFS 很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。 FastDFS 架构包括 Tracker server 和 Storage server。 Tracker server （追踪服务器、调度服务器）作用为负载均衡和调度。 Storage server （存储服务器）作用为文件存储。 客户端请求 Tracker server 进行文件上传、下载,通过 Tracker server 调度最终由 Storage server 完成文件上传和下载。 服务端角色： Tracker : 管理集群，tracker也可以实现集群，每一个节点地位平等，一种备份的机制。tracker负责收集 storage 集群的存储状态。 Stroage ：实际保存文件。分为多个组，组内文件相同，起到备份作用。组间文件不同，起到分布式存储。 商品分类级联刷新 ​ 通过 Angular JS 变量监控方法，实现选择一级分类之后，初始化二级分类的列表信息。 123456789101112// angularjs变量监控方法,查询二级分类信息$scope.$watch('entity.goods.category1Id',function(newValue, oldValue)&#123; if (newValue != undefined &amp;&amp; newValue != "") &#123; // alert("category1Id"+newValue); itemCatService.findByParentId(newValue).success( function(response)&#123; $scope.itemCat2List = response; $scope.entity.goods.category2Id = ""; &#125; ); &#125;&#125;); 商品录入【SKU商品信息】 对于同一个产品分为多种不同的规格组合。根据选择的规格录入商品的 SKU 信息，当用户选择相应的规格，下面的 SKU 列表就会自动生成。 实现思路：（1）我们先定义一个初始的不带规格名称的集合，只有一条记录。（2）循环用选择的规格，根据规格名称和已选择的规格选项对原集合进行扩充，添加规格名称和值，新增的记录数与选择的规格选项个数相同 12345678910111213141516171819202122232425262728293031323334// 创建SKU列表$scope.creatItemList=function()&#123; // 列表初始化，规格对象、价格、库存量、状态、是否默认 $scope.entity.itemList = [ &#123;spec:&#123;&#125;,price:0,num:9999,status:'0',isDefault:'0'&#125; ]; var items = $scope.entity.goodsDesc.specificationItems; for (var i = 0; i &lt; items.length; i++) &#123; $scope.entity.itemList = addColumn($scope.entity.itemList, items[i].attributeName, items[i].attributeValue); &#125;&#125;/** * $scope.entity.itemList: * [&#123;"spec":&#123;"网络":"移动3G","机身内存":"16G"&#125;,"price":0,"num":9999,"status":"0","isDefault":"0"&#125;, * &#123;"spec":&#123;"网络":"移动3G","机身内存":"32G"&#125;,"price":0,"num":9999,"status":"0","isDefault":"0"&#125;, * &#123;"spec":&#123;"网络":"联通3G","机身内存":"16G"&#125;,"price":0,"num":9999,"status":"0","isDefault":"0"&#125;, * &#123;"spec":&#123;"网络":"联通3G","机身内存":"32G"&#125;,"price":0,"num":9999,"status":"0","isDefault":"0"&#125;] */// 深克隆方法 原集合、列名、列值addColumn=function(list, columnName, columnValues)&#123; var newList = []; for (var i = 0; i &lt; list.length; i++) &#123; var oldRow = list[i]; for (var j = 0; j &lt; columnValues.length; j++) &#123; var newRow = JSON.parse( JSON.stringify(oldRow) ); newRow.spec[columnName] = columnValues[j]; newList.push(newRow); &#125; &#125; return newList;&#125; 商家后台列表显示 状态显示： ​ 商品信息表（goods）中状态子段为 audit_status 。存储的为数字，0表示未审核、1表示已审核、2表示审核未通过、3为已关闭。从后台获取的状态值，直接在前端进行修改。通过一个status数组存储： ​ $scope.status=[‘未审核’,’已审核’,’审核未通过’,’关闭’];//商品状态 ​ 然后列表中显示为 。 分类信息显示： ​ 商品分为三级分类。存储于 tb_item_cat 表中。包括 id、父级id、分类名称、对应绑定的类型id。但是为了避免商品查询时重复的关联查询，可以采用现将所有分类信息读取到本地，然后在前端进行分类id到分类名称的转换操作。 1234567891011$scope.itemCatList = [];// 全部商品分类查询，存储在itemList数组中，然后再前端页面通过数组下标直接将商品分类ID转换为商品分类名称，避免后端连接查询。$scope.findItemList = function()&#123; itemCatService.findAll().success( function(response)&#123; for (var i = 0; i &lt; response.length; i++) &#123; $scope.itemCatList[response[i].id] = response[i].name; &#125; &#125; );&#125; ​ 将分类结果 response 对象封装为数组类型，数组下标为商品分类id，数组值为商品分类的名称。然后在列表项中通过 将id转换为名称。 存在的问题 ​ pinyougou-shop-web 模块中分页插件提示 ClassNotFoundException。但是页面可以访问。 12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;$&#123;pagehelper.version&#125;&lt;/version&gt;&lt;/dependency&gt; ​ 如上配置之后，又出现下图错误，导致商品列表无法显示。（但是 manager-web 模块中也没有引入pagehelper,但是没有出现问题） 商品删除 ​ 逻辑删除，通过修改数据库表中的 is_delete 字段为1，然后过滤掉商品。然后查询时，在 findPage() 方法中添加 criteria.andIsDeleteIsNull() 条件。 注解式事务配置 ​ 创建 applicationContext-tx.xml 配置文件 1234567&lt;!-- 事务管理器 --&gt;&lt;bean id="transactionManager"class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt;&lt;/bean&gt;&lt;!-- 开启事务控制的注解支持 --&gt;&lt;tx:annotation-driven transaction-manager="transactionManager"/&gt; ​ 然后在方法或服务实现类上添加 @Transactional 注解。 网站前台广告服务 ​ 设计为广告分类表（id、name）与广告内容表（id、categoryId、title、url、pic、status、order）。广告有首页轮播广告、今日推荐、各品类楼层广告等分类。 ​ Redis 缓存数据库用于解决高访问量对后端数据库造成的很大的访问压力。（另一种解决方案为网页静态化） ​ Spring Data Redis 提供了在 srping 应用中通过简单的配置访问 redis 服务，对 reids 底层开发包(Jedis, JRedis, and RJC)进行了高度封装，RedisTemplate 提供了 redis 各种操作、异常处理及序列化，支持发布订阅，并对 spring 3.1 cache 进行了实现。 spring-data-redis 针对 jedis 提供了如下功能： 1.连接池自动管理，提供了一个高度封装的“RedisTemplate”类。 2.针对 jedis 客户端中大量 api 进行了归类封装,将同一类型操作封装为 operation 接口 操作样例： key-value 键值对操作 ​ 插入：redisTemplate.boundValueOps(“name”).set(“mindyu”); ​ 读取：redisTemplate.boundValueOps(“name”).get(); ​ 删除：redisTemplate.delete(“name”); Set 类型操作（无序集合） ​ 插入：redisTemplate.boundSetOps(“nameset”).add(“曹操”); ​ 读取：redisTemplate.boundSetOps(“nameset”).members(); ​ 删除：redisTemplate.boundSetOps(“nameset”).remove(“曹操”); // 单一元素 redisTemplate.delete(“name”); // 整个集合 List 集合 （有序） ​ rightPush() 、leftPush()、读取：range(0,10)、index(1)、remove(1, “value”) // 1 表示删除数据的个数 Hash 类型 ​ put(“key”,”value”)、读取所有键：keys()、读取所有值：values()、get(“key”)、delete(“key”) ​ 使用 Redis 缓存时，需要注意，当数据修改时需要清除缓存数据，使其达到一致性约束。必须修改广告时，如果修改了该广告所属的分类，那么需要同时清除原分类以及新分类的缓存信息。 出现的问题： ​ 首页在加载广告模块时，出现 “Failed to load resource: net::ERR_BLOCKED_BY_CLIENT” 错误，是因为谷歌浏览器的广告插件，导致无法加载该图片。 搜索解决方案简介 ​ Solr 是一个开源搜索平台，用于构建搜索应用程序。 它建立在 Lucene(全文搜索引擎)之上。 Solr 是企业级的，快速的和高度可扩展的。 使用 Solr 构建的应用程序非常复杂，可提供高性能。Solr 是一个可扩展的，可部署，搜索/存储引擎，优化搜索大量以文本为中心的数据。 安装及配置 安装 Tomcat，解压缩。 解压 solr。 把 solr 下的 dist 目录 solr-4.10.3.war 部署到 webapps 下(去掉版本号，方便访问)。 启动 Tomcat 解压缩 war 包 把solr下 example/lib/ext 目录下的所有的扩展 jar 包，添加到 solr 的工程中(\WEB-INF\lib目录下)。 创建一个 solrhome 。solr 下的 /example/solr 目录就是一个 solrhome。复制此目录到 D 盘改名为 solrhome 关联 solr 及 solrhome。需要修改 solr 工程的 web.xml 文件。 12345&lt;env-entry&gt; &lt;env-entry-name&gt;solr/home&lt;/env-entry-name&gt; &lt;env-entry-value&gt;d:\solrhome&lt;/env-entry-value&gt; &lt;env-entry-type&gt;java.lang.String&lt;/env-entry-type&gt;&lt;/env-entry&gt; 启动 Tomcat 。访问 http://localhost:8080/solr 即可 中文分析器 IK Analyzer ​ IK Analyzer 是一个开源的，基于 java 语言开发的轻量级的中文分词工具包。 配置 把 IKAnalyzer2012FF_u1.jar 添加到 solr 工程的 lib 目录下 solr 工程下创建 WEB-INF/classes 文件夹，用于存放扩展词典、停用词词典、配置文件。 修改 Solrhome 中的 schema.xml 文件，配置一个 FieldType，使用 IKAnalyzer 123&lt;fieldType name="text_ik" class="solr.TextField"&gt; &lt;analyzer class="org.wltea.analyzer.lucene.IKAnalyzer"/&gt;&lt;/fieldType&gt; 配置域 ​ 域相当于数据库的表字段，用户存放数据，用户可根据业务需要去定义相关的 Field（域），一般来说，每一种域对应着一种数据，用户对同一种数据进行相同的操作。域的常用属性： name 域的名称 type 域的类型 indexed 是否索引 stored 是否存储 required 是否必须 multiValued 是否多值 复制域： ​ 将某一个域中的数据复制到另一个域中。比如商品查询时，同样一个关键字可能是品牌、商品标题、商品分类、商家名称等多种可能。此时就需要复制域。 动态域： ​ 对于字段名称不固定的情况下，用于动态扩充字段。比如商品的规格的值不是固定的（不同商品可能存在不同的规格项）。 出现的错误 前端可以从后台获取数据（ itemsearch/search.do正常获取数据 ），但是控制台显示” TypeError: Cannot read property ‘success’ of undefined “错误。 原因是因为： 12345app.service('searchService', function($http)&#123; this.search=function(searchMap)&#123; return $http.post('itemsearch/search.do',searchMap); &#125;&#125;); angularjs 服务层的search方法并未 return。 12. 服务启动超时：com.alibaba.dubbo.remoting.TimeoutException: Waiting server-side response timeout. start time: 2018-12-02 08:35:41.093, end time: 2018-12-02 08:35:46.094, client elapsed: 0 ms, server elapsed: 5001 ms, timeout: 5000 ms。 网站前台 portal-web 模块出现的原因是因为没有启动 redis 服务器。然后前台广告数据获取不到。 搜索模块 search-web ：就很奇怪，dubbox 服务正常、solr 服务正常。昨天晚上还是正常的，上午纠结了半天，然后不知道为啥突然又好了。。。 烦躁 批量数据导入 solr 系统 ​ 将商品数据导入到 solr 系统。 创建 solr-util (jar)，引入 dao 模块以及 spring 相关依赖。 创建spring 的配置文件，添加包扫描。 &lt;context:component-scan base-package=”com.pinyougou.solrutil”&gt;&lt;/context:component-scan&gt; 依赖 pojo 模块，为实体类添加 @Field 注解。 pojo 中引入 spring-data-solr 依赖（会自动引入其所依赖solr包）动态域中@Dynamic 注解是该包提供的 添加 solr.xml 配置文件与 spring 目录中。 123456&lt;!-- solr 服务器地址 --&gt;&lt;solr:solr-server id="solrServer" url="http://127.0.0.1:8080/solr" /&gt;&lt;!-- solr 模板，使用 solr 模板可对索引库进行 CRUD 的操作 --&gt;&lt;bean id="solrTemplate" class="org.springframework.data.solr.core.SolrTemplate"&gt; &lt;constructor-arg ref="solrServer" /&gt;&lt;bean&gt; 通过 spring 注入 SolrTemplate 模板类对象。 使用 SolrTemplate 对象执行相应的方法。 关键字搜索模块 ​ 通过注入 SolrTemplate 对象，使用该对象实现关键字搜索。 123456789101112131415161718192021@Service(timeout=5000) // 超时5S，默认是1Spublic class ItemSearchServiceImpl implements ItemSearchService&#123; @Autowired private SolrTemplate solrTemplate; @Override public Map search(Map searchMap) &#123; Map map = new HashMap(); Query query = new SimpleQuery("*:*"); Criteria criteria = new Criteria("item_keywords").is(searchMap.get("keywords")); query.addCriteria(criteria); ScoredPage&lt;TbItem&gt; page = solrTemplate.queryForPage(query, TbItem.class); map.put("rows", page.getContent()); // page.getContent() 返回一个 List 集合 return map; &#125;&#125; 搜索结果高亮显示 ​ 将搜索关键字在搜索结果中，高亮显示出来。实现原理也就是在关键字前后添加html标签：关键字 ​ 后端实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Overridepublic Map search(Map searchMap) &#123; Map map = new HashMap(); /* Query query = new SimpleQuery("*:*"); Criteria criteria = new Criteria("item_keywords").is(searchMap.get("keywords")); query.addCriteria(criteria); ScoredPage&lt;TbItem&gt; page = solrTemplate.queryForPage(query, TbItem.class); map.put("rows", page.getContent()); // page.getContent() 返回一个 List 集合 */ // 高亮显示 HighlightQuery query = new SimpleHighlightQuery(); // 构建高亮选项 HighlightOptions highlightOptions = new HighlightOptions().addField("item_title"); // 高亮域（可以为多个） highlightOptions.setSimplePrefix("&lt;em style='color:red'&gt;"); // 前缀 highlightOptions.setSimplePostfix("&lt;/em&gt;"); // 后缀 query.setHighlightOptions(highlightOptions); // 为查询设置高亮查询 Criteria criteria = new Criteria("item_keywords").is(searchMap.get("keywords")); query.addCriteria(criteria); HighlightPage&lt;TbItem&gt; page = solrTemplate.queryForHighlightPage(query, TbItem.class); // 高亮入口集合（每条高亮结果的入口） List&lt;HighlightEntry&lt;TbItem&gt;&gt; entryList = page.getHighlighted(); for (HighlightEntry&lt;TbItem&gt; entry : entryList) &#123; // 获取高亮列表（高亮域的个数） List&lt;Highlight&gt; hightLightList = entry.getHighlights(); /* for (Highlight highLight : hightLightList) &#123; // 每个域可能存在多值（复制域） List&lt;String&gt; sns = highLight.getSnipplets(); System.out.println(sns); &#125;*/ if (entry.getHighlights().size()&gt;0 &amp;&amp; entry.getHighlights().get(0).getSnipplets().size()&gt;0) &#123; TbItem item = entry.getEntity(); item.setTitle(entry.getHighlights().get(0).getSnipplets().get(0)); // 用高亮标签结果替换 &#125; &#125; map.put("rows", page.getContent()); return map;&#125; ​ 前端实现： angularJS 会将后端插入的html标签原样输出，而不会去解析。这是防止html攻击采取的一种安全策略。可以使用 $sce 服务的 trustAsHtml 方法来实现转换。 12345678// 定义过滤器app.filter('trustHtml', ['$sce', function($sce)&#123; return function(data)&#123; // 传入参数时，被过滤的内容 return $sce.trustAsHtml(data); // 返回的是过滤后的内容（信任html的转换） &#125; &#125; ]); 然后在页面通过 &lt;div class=&quot;attr&quot; ng-bind-html=&quot;item.title | trustHtml&quot;&gt;&lt;/div&gt;来调用转换方法。 搜索业务规则搜索模块 用户输入搜索关键字，显示列表结果和商品分类信息。因为一个关键字可能对应多种商品分类 根据第一个商品分类，默认查询该分类的模板ID，然后根据模板ID查询品牌列表和规格列表 当用户点击某一个商品分类时，则显示该分类对应商品结果，同时根据该分类的模板ID查询对应的品牌列表和规格列表 当用户点击商品品牌列表时，筛选出当前所选的品牌商品信息 当用户点击商品规格列表时，筛选出当前所选的规格所对应的商品信息 用户点击价格区间时，商品信息根据价格进行过滤 用户点击搜索面板上的条件时，隐藏该条件 系统搜索量很大，所以需要将搜索信息放置到 Redis 缓存数据库中。 缓存商品分类信息 12345678private void saveToRedis() &#123; // 将模板ID放入缓存 分类名称作为key,模板ID作为value List&lt;TbItemCat&gt; itemCatList = findAll(); for (TbItemCat itemCat : itemCatList) &#123; redisTemplate.boundHashOps("itemCat").put(itemCat.getName(), itemCat.getTypeId()); &#125; System.out.println("将模板ID放入缓存");&#125; 缓存所有的品牌信息和规格信息 12345678910111213141516private void saveToRedis() &#123; List&lt;TbTypeTemplate&gt; typeTempList = findAll(); for(TbTypeTemplate template : typeTempList) &#123; Long id = template.getId(); // 将模板ID作为key 品牌列表作为value List brandList = JSON.parseArray(template.getBrandIds(), Map.class); // &#123;id:1,text:联想&#125; redisTemplate.boundHashOps("brandList").put(id, brandList); // 将模板ID作为key 规格列表作为value List&lt;Map&gt; specList = findSpecList(id); redisTemplate.boundHashOps("specList").put(id, specList); &#125; System.out.println("完成品牌列表、规格列表缓存");&#125; 分类列表查询（spring data solr 条件查询） 12345678910111213141516171819202122232425private List&lt;String&gt; searchCategoryList(Map searchMap) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); Query query = new SimpleQuery("*:*"); // 根据关键字查询 Criteria criteria = new Criteria("item_keywords").is(searchMap.get("keywords")); // where ... query.addCriteria(criteria); // 设置分组选项 GroupOptions groupOptions = new GroupOptions().addGroupByField("item_category"); // group by ....（可以有多个分组域） query.setGroupOptions(groupOptions); // 获取分组页 GroupPage&lt;TbItem&gt; queryForGroupPage = solrTemplate.queryForGroupPage(query, TbItem.class); // 获取分组结果对象 GroupResult&lt;TbItem&gt; groupResult = queryForGroupPage.getGroupResult("item_category"); // 获取分组入口页 Page&lt;GroupEntry&lt;TbItem&gt;&gt; groupEntries = groupResult.getGroupEntries(); // 遍历获取每个对象的值 for(GroupEntry&lt;TbItem&gt; entry : groupEntries) &#123; list.add(entry.getGroupValue()); &#125; return list;&#125; 过滤条件的构建 ​ 当点击搜索面板的分类、品牌和规格时，实现查询条件的构建。查询 条件以面包屑的形式显示。当面包屑显示分类、品牌和规格时，要同时隐藏搜索面板对应的区域。点击面包屑查询条件的撤销链接时，重新显示搜索面板相应的区域。 ​ 面包屑其实就是显示搜索对象。可将搜索对象定义为$scope.searchMap={&#39;keywords&#39;:&#39;&#39;,&#39;category&#39;:&#39;&#39;,&#39;brand&#39;:&#39;&#39;,spec:{}};。然后实现添加查询条件和取消查询条件。 1234567891011121314151617181920212223242526// 搜索$scope.search = function() &#123; searchService.search($scope.searchMap).success(function(response) &#123; $scope.resultMap = response; // 搜索返回的结果 &#125;);&#125;// 添加查询搜索项$scope.addSearchItem=function(key,value)&#123; if (key == 'brand' || key == 'category') &#123; // 如果点击品牌和分类 $scope.searchMap[key] = value; &#125;else&#123; $scope.searchMap.spec[key]=value; &#125; $scope.search();&#125;// 取消查询条件$scope.removeSearchItem=function(key)&#123; if (key == 'brand' || key == 'category') &#123; // 如果点击品牌和分类 $scope.searchMap[key] = ""; &#125;else&#123; delete $scope.searchMap.spec[key]; &#125; $scope.search();&#125; 价格区间筛选 ​ 点击搜索面板的价格区间，实现按价格筛选相应的商品。和上述的过滤条件类似，前端依然将价格区间以字符串的形式放入到 searchMap 集合中（如 ‘price’:’500-1000’）。然后后端通过字符串的截取获得相应的价格区间，然后进而筛选。 自定义搜索结果分页 ​ 前端将当前页数和页大小通过 searchMap 传给后端，然后后端通过构建 solr 的 query 对象实现分页效果。然后返回当前页数据和总页数以及总记录数。$scope.searchMap={&#39;keywords&#39;:&#39;&#39;,&#39;category&#39;:&#39;&#39;,&#39;brand&#39;:&#39;&#39;,&#39;spec&#39;:{},&#39;price&#39;:&#39;&#39;,&#39;pageNo&#39;:1,&#39;pageSize&#39;:40 };//搜索条件封装对象 通过当前页数、总页数然后构建分页标签。 12345678910111213141516171819202122232425262728// 构建分页标签buildPageLable=function()&#123; $scope.pageLable=[]; var firstPage = 1; // 开始页码 var lastPage = $scope.resultMap.totalPages; // 截止页码 $scope.firstDot = true; $scope.lastDot = true; if (lastPage &gt; 5)&#123; if ($scope.searchMap.pageNo&lt;=3)&#123; // 当前页码小于3，显示前五页 lastPage = 5; $scope.firstDot = false; &#125;else if ($scope.searchMap.pageNo&gt;=lastPage-2) &#123; // 当前页码大于总页数-2，则显示后5页 firstPage = lastPage - 4; $scope.lastDot = false; &#125;else &#123; firstPage = $scope.searchMap.pageNo - 2; lastPage = $scope.searchMap.pageNo + 2; &#125; &#125;else&#123; $scope.firstDot = false; $scope.lastDot = false; &#125; for (var i = firstPage; i &lt;= lastPage; i++) &#123; $scope.pageLable.push(i); &#125;&#125; 多关键字搜索 ​ 在搜索时，分词器首先会将我们输入的关键字进行分词，然后对每个分词都会去搜索对应的结果，然后求得并集。比如搜索“三星手机”时，会将“三星”的搜索集合和“手机”搜索结构都返回给我们。这样做可以显示更多数据，让用户有更多的选择。同时会根据搜索的关键字匹配度进行排序。 ​ 此时注意：当搜索关键字有空格时，中文分词无法进行分词，那么就会导致搜索出来的结果较少或者没有。然后可以采用在后端去掉关键字中所有的空格。原来如此，我平时搜索的时候经常喜欢敲空格，以为这样多个条件就能更精准的搜索我想要的额，套路套路。 搜索数据排序 ​ 根据综合、价格升降序、新品的来实现排序。前端传递两个参数，分别为待排序的字段名称和排序方式（升序or降序）。 123456789101112// 1.7 排序String sortValue = (String) searchMap.get("sort"); // 升序 or 降序String sortFiled = (String) searchMap.get("sortFiled"); // 升序字段if (!"".equals(sortValue) &amp;&amp; !"".equals(sortFiled)) &#123; if (sortValue.equals("ASC")) &#123; // 升序 Sort sort = new Sort(Sort.Direction.ASC, "item_"+sortFiled); query.addSort(sort); &#125;else if(sortValue.equals("DESC")) &#123; Sort sort = new Sort(Sort.Direction.DESC, "item_"+sortFiled); query.addSort(sort); &#125;&#125; ​ 销量和评价的排序(待完成)： 增加域 item_salecount 用于存储每一个 SKU 的销量信息，然后定时更新每一个 SKU 的销量数据（固定时间，比如一个月，否则会导致新上架的商品无法排在前列），同时每天定时更新一次销量数据。 隐藏品牌列表 ​ 当用户搜索的关键字包含品牌时隐藏品牌列表。也就是判断搜索关键字中是否存在返回的品牌列表中的信息。这个过程中发现，搜索关键字 searchMap.keywords 和输入框进行了绑定。那么当我们修改输入框的时候，可能就会影响品牌列表的显示。 此处将 search 重载，添加一个带 keywords的方法。然后搜索框就不和搜索关键字进行绑定，而是以传递参数的形式赋值给 searchMap。 首页和搜索页对接 ​ 在首页输入框中输入关键字，然后跳转到搜索页面，查询对应关键字的数据。 首页通过 链接的形式传递参数location.href=&quot;http://localhost:9104/search.html#?keywords=&quot;+$scope.keywords; 然后搜索模块使用 $location 服务接受参数。 123456// 引入 $location 服务// 接受首页跳转$scope.loadKeywords=function()&#123; $scope.searchMap.keywords = $location.search()['keywords']; $scope.search();&#125; 索引库的增量更新 ​ 实现在商品审核之后将数据更新到 solr 索引库，在商品删除的时候删除 solr 索引库中相应的记录。(增量更新) ​ 商品审核是对商品表（SPU信息）进行操作，但是索引库中存储的是SKU信息，所以首先需要通过商品的 SPU 信息查询该商品对应的 SKU 信息，然后将查询到的集合提交给 solrTemplate。删除可以直接根据 goodsId 集合进行条件删除。]]></content>
      <categories>
        <category>项目学习</category>
      </categories>
      <tags>
        <tag>品优购</tag>
        <tag>电商系统</tag>
        <tag>项目实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[品优购项目学习笔记]]></title>
    <url>%2F2018%2F12%2F18%2F%E5%93%81%E4%BC%98%E8%B4%AD%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一个综合性的 B2B2C 的电商网站系统。网站采用商家入驻的模式，商家入驻平台提交申请，有平台进行资质审核，审核通过后，商家拥有独立的管理后台录入商品信息。商品经过平台审核后即可发布。 Github地址 项目简介系统模块 网站前台 运营商平台 商家管理平台 框架组合 ​ 前端 angularJS + Bootstrap ​ 后端 Spring + SpringMVC + mybatis + Dubbox 系统架构​ 面向服务的架构（SOA架构）。控制层与服务层分离，通过网络调用。 Dubbox框架 致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。远程服务调用的分布式框架。 原理图 节点角色说明： Provider: 暴露服务的服务提供方。 Consumer: 调用远程服务的服务消费方。 Registry: 服务注册与发现的注册中心。 Monitor: 统计服务的调用次调和调用时间的监控中心。 Container: 服务运行容器。 Dubbox 本地 jar 包部署与安装 ： Dubbox 并不在 maven 中央仓库，需安装到本地仓库。将 dubbo-2.8.4.jar 包放到 d:\setup, 然后输入命令 mvn install:install-file -Dfile=d:\setup\dubbo-2.8.4.jar -DgroupId=com.alibaba -DartifactId=dubbo -Dversion=2.8.4 -Dpackaging=jar 即可。 管理中心的部署 ： 开发过程中需要知道注册了哪些服务以便测试与管理。通过部署一个管理中心来实现。其实管理中心就是一个web应用，部署到tomcat即可。 编译 dubbox 源码，dubbox-master.zip 文件中的 dubbox-master 目录下，执行 mvn package -Dmaven.skip.test=true 。即可在 target 目录下看到 dubbo-admin-2.8.4.war 。将 war 包放置到服务器的 webapps 下。 如果你部署在zookeeper同一台主机并且端口是默认的2181，则无需修改任何配置。如果不是在一台主机上或端口被修改，需要修改 WEB-INF 下的 dubbo.properties ，修改如下配置：dubbo.registry.address=&lt;zookeeper://127.0.0.1:2181&gt; 修改后重新启动tomcat。 http://虚拟机ip:8080/dubbo-admin 用户名 root 密码 注册中心 Zookeeper : 上传 zookeeper 包，解压缩，创建 data 目录，修改 zoo.cfg 配置文件的 dataDir 配置 启动命令 安装目录 /root/zookeeper-3.4.6/ 模块关联关系图：]]></content>
      <categories>
        <category>项目学习</category>
      </categories>
      <tags>
        <tag>品优购</tag>
        <tag>电商系统</tag>
        <tag>项目实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04 常用命令集合]]></title>
    <url>%2F2018%2F04%2F28%2FUbuntu16-04-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[软件安装方法一： 1234sudo apt-get install 软件名 //最常用方法sudo apt-get remove 软件名 //卸载软件sudo apt-get update //更新软件列表，会访问源列表里的每个网址，并读取软件列表，然后保存在本地电脑sudo apt-get upgrade //更新软件，把本地已安装的软件，与刚update软件进行对比，如果发现已安装的软件版本太低，就会提示你更新。 方法二： deb软件包可直接安装 1sudo dpkg -i package.deb //deb包安装方法 deb详解： 123456789dpkg -r package 删除包 dpkg -P package 删除包（包括配置文件）dpkg -L package 列出与该包关联的文件 dpkg -l packag 显示该包的版本edpkg –unpack package.deb 解开 deb 包的内容 dpkg -S keyword 搜索所属的包内容 dpkg -l 列出当前已安装的包dpkg -c package.deb 列出 deb 包的内容 dpkg –configure package 配置包 方法三: rpm软件包安装Ubuntu的软件包格式是deb，如果要安装rpm的包，则要先用alien把rpm转换成deb。 12345sudo apt-get install alien //安装alien工具alien -d *.rpm //转换rpm包为deb包，然后再按方法二安装alien -i *.rpm //直接对rpm包进行安装 文件管理 常用命令： 123456789101112~ //当前用户主目录 cd ~ //home目录（/开头是绝对路径；.开头是相对路径）pwd //获取当前路径mkdir mydir //新建目录mydircp test(此处可为路径) /opt/test //将当前目录下的test复制到test中rm //删除文件mv oldname newname //重命名remove 'y/a-z/A-Z/' *.c //删文件cat test //查看文件test;-n显示行号file test //查看文件类型ls //查看当前目录下的文件ls -l 文件名称 //查看详细信息（文件夹将-l改为-ld） 文件权限说明：12// 文件属性 连接数 文件拥有者 所属群组 文件大小 文件修改时间 文件名drwxrwxr-x 9 mindyu mindyu 4096 4月 29 01:15 Blog r可读，w可写，x 可执行，-不可读/写/执行文件属性占10个位置例如：d rwx rwx r-x第一个字符指定了文件类型：‘- ’ 代表非目录的文件‘d’ 代表一个目录。第二段是文件拥有者User的属性，第三段是文件所属群组Group的属性，第四段是对于其它用户Other的属性。 权限修改方法一： 12//chmod [-R] 模式 文件chmod abc file 其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。r=4，w=2，x=1 例子：若要rwx属性则4+2+1=7；若要rw-属性则4+2=6；若要r-x属性则4+1=5。 123sudo chmod 600 ××× （只有所有者有读和写的权限）sudo chmod 644 ××× （所有者有读和写的权限，组用户和其他用户只有读的权限）sudo chmod 777 ××× （每个人都有读和写以及执行的权限） 方法二： 1chmod [ugoa] &#123;+|-|=&#125; [rwxst] 文件 用户参数：u 文件主 g 同组用户 o 其他用户 a 所有用户操作方法：+ 增加后列权限 - 取消后列权限 = 置成后列权限操作参数：r 可读 w 可写 x 可执行 s 运行时可置UID t 运行时可置GID 123chmod u+rw abc.txt //给用户增加读写权限chmod o-rwx abc.txt //不允许其他用户读写执行chmod g=rx abc.txt //只允许群组读取和执行 apt-get常用命令 update - 取回更新的软件包列表信息 upgrade - 进行一次升级 install - 安装新的软件包(注：软件包名称是 libc6 而非 libc6.deb) remove - 卸载软件包 purge - 卸载并清除软件包的配置 autoremove - 卸载所有自动安装且不再使用的软件包 dist-upgrade - 发布版升级，见 apt-get(8) dselect-upgrade - 根据 dselect 的选择来进行升级 build-dep - 为源码包配置所需的编译依赖关系 clean - 删除所有已下载的包文件 autoclean - 删除已下载的旧包文件 check - 核对以确认系统的依赖关系的完整性 source - 下载源码包文件 download - 下载指定的二进制包到当前目录 changelog - 下载指定软件包，并显示其changelog 解压缩命令.tar解包：tar xvf FileName.tar打包：tar cvf FileName.tar DirName 将DirName文件夹打包成一个FileName.tar文件打包：将一大堆文件或目录变成一个总的文件，压缩：将一个大的文件通过一些压缩算法变成一个小文件。 .gz解压1：gunzip FileName.gz解压2：gzip -d FileName.gz压缩：gzip FileName .tar.gz 和 .tgz解压：tar zxvf FileName.tar.gz压缩：tar zcvf FileName.tar.gz DirName .bz2解压1：bzip2 -d FileName.bz2解压2：bunzip2 FileName.bz2压缩： bzip2 -z FileName .tar.bz2解压：tar jxvf FileName.tar.bz2压缩：tar jcvf FileName.tar.bz2 DirName .bz解压1：bzip2 -d FileName.bz解压2：bunzip2 FileName.bz压缩：未知 .tar.bz解压：tar jxvf FileName.tar.bz压缩：未知 .Z解压：uncompress FileName.Z压缩：compress FileName .tar.Z解压：tar Zxvf FileName.tar.Z压缩：tar Zcvf FileName.tar.Z DirName .zip解压：unzip FileName.zip压缩：zip FileName.zip DirName .rar解压：rar x FileName.rar压缩：rar a -r FileName.rar DirName解压需要安装：sudo apt-get install unrar压缩需要安装：sudo apt-get install rar]]></content>
      <categories>
        <category>Ubuntu学习</category>
      </categories>
      <tags>
        <tag>Ubuntu16.04</tag>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04 常用软件安装]]></title>
    <url>%2F2018%2F04%2F26%2FUbuntu%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[Ubuntu系统尝鲜不知何时起，对Linux操作系统充满了好奇心，想去接触一番。 都说学编程搞开发的都离不开Linux操作系统，个人觉得Linux操作系统更适合学习，少了各种弹窗，界面更加清爽，系统任由你自己去操控，系统也更加稳定，许多的服务器也基本上都是Linux操作系统。然后就自己倒腾，在Windows上装了一个Ubuntu16.04LTS的双系统，通过日常是的使用去渐渐熟悉Linux操作系统，以及各种命令的使用～ 常用软件安装 Shadowsocks安装 12345sudo add-apt-repository ppa:hzwhuang/ss-qt5 sudo apt-get update sudo apt-get install shadowsocks-qt5 在Ubuntu系统上使用还需要设置系统代理，在 设置-》网络-》网络代理 中设置代理模式，最好设置为自动代理方式，然后添加一个pac文件，应用到整个系统即可。 小书匠安装一款Markdown编辑器，支持多平台使用。详细的安装及添加桌面快捷方式可见我的另一篇博客。 安装搜狗输入法其实个人感觉系统自带的输入法也还可以。 3.1 在官网下载搜狗输入法安装包 3.2 切换到deb包所在的目录，并执行以下命令：sudo dkpg -i deb包名 3.3 若出现由于缺少相关依赖文件的错误。执行以下命令，安装所缺少的依赖文件，然后再次使用3.2命令完成安装：sudo apt-get -f install 3.4 在“语言支持”面板，添加汉语支持，并将输入法系统设置为fcitx。然后重启 3.5 在Dash中搜索fcitx configuartion，在Input Method中添加和配置sogoupinyin即可 JDK安装 添加ppa 12sudo add-apt-repository ppa:webupd8team/javasudo apt-get update 安装oracle-java-installer 123456JDK8sudo apt-get install oracle-java8-installerJDK7sudo apt-get install oracle-java7-installer 安装时会提示你同意Oracle的服务条款，选择ok，然后选择yes Eclipse安装安装Eclipsesudo apt-get install eclipse启动Eclipseeclipse以及快捷方式制作，可见小书匠安装的详细博客 MyEclipse安装 在官方中文网下载MyEclipse安装包 我现在的是离线版，解压后为.run为后缀名的文件 双击执行，然后就和windows安装过程一样。选择安装目录比如/opt/MyEclipse/，一路Next即可。最后一步取消勾选。不立即打开MyEclipse。 然后下载对应的破解包，解压之后，执行cracker.jar包java -jar cracker.jar 之后的步骤和Windows破解过程一样。如果你一遍成功，那么就恭喜你。 我第一次安装失败了，因为破解包的问题，所以要确保破解包的正确性。 失败之后存在一个卸载不干净的问题。我也没有找到解决办法。 换了一台电脑，另外找了一个破解包，完美破解。 Google浏览器安装 下载 Chrome（Linux 版）https://www.google.cn/intl/zh-CN/chrome/ 终端下输入如下内容来安装.deb文件sudo dpkg -i 软件包名.deb 然后在Dash中搜索Google，打开即可。 使用中可能遇到两个问题： （1）重启之后，Google浏览器就打不开了 （2）设置新标签页打开网页 解决方案： 问题1： 网上的解决办法，大多是删除chrome的配置文件 rm -r~/.config/google-chrome 但是指标不治本，下次打开依然会出现问题 真正的解决方案是： 安装gnome-keyring。因为在登录谷歌账户之后，chrome会使用gnome-keyring来保护你的账户。 sudo apt install gnome-keyring 问题2： 打开google页面，任意搜索一个内容，在搜索结果页面的上面靠中间位置有一个设置，点击设置然后选择 搜索设置 ，即进入如下页面。 然后勾选结果打开方式的 在新的浏览器窗口中打开所选的每条搜索结果即可。 系统监视器实时查看电脑的cpu，内存占用率，更可以查看网速安装：12345sudo add-apt-repository ppa:fossfreedom/indicator-sysmonitor sudo apt-get update sudo apt-get install indicator-sysmonitor WPS 安装 在WPS官网下载alpha版本，我下载的是wps-office_10.1.0.5672~a21_amd64.deb 执行安装命令：sudo dpkg -i wps-office_10.1.0.5672~a21_amd64.deb 安装完成后，在Dash中即可搜索到，打开会发现字体缺失的问题 下载字体包 创建目录：sudo mkdir /usr/share/fonts/wps-office 将下载的字体复制到创建的目录：sudo cp -r wps_symbol_fonts.zip /usr/share/fonts/wps-office 切换到/usr/share/fonts/wps-office目录解压字体包：sudo unzip wps_symbol_fonts.zip 解压后删除字体包：sudo rm -r wps_symbol_fonts.zip再次打开就不会提示缺失字体包了！ 下载工具uget安装 12345sudo add-apt-repository ppa:plushuang-tw/uget-stable sudo apt-get update sudo apt-get install uget 终端和浏览器下载东西比较慢的时候可以试试，下载速度还是比较可观！ 参考博客：https://www.cnblogs.com/wadxy1314/p/6880264.html https://blog.csdn.net/Jesse_Mx/article/details/52816928 https://blog.csdn.net/u011324454/article/details/78497021 https://blog.csdn.net/VectorWWW/article/details/78820156 https://my.oschina.net/renwofei423/blog/635798]]></content>
      <categories>
        <category>Ubuntu学习</category>
      </categories>
      <tags>
        <tag>Ubuntu16.04</tag>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu安装小书匠并创建桌面快捷方式]]></title>
    <url>%2F2018%2F04%2F24%2FUbuntu%E5%AE%89%E8%A3%85%E5%B0%8F%E4%B9%A6%E5%8C%A0%E5%B9%B6%E5%88%9B%E5%BB%BA%E6%A1%8C%E9%9D%A2%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[小书匠简介 小书匠编辑器是一款专为markdown写作而设计的编辑器。 支持多种编辑模式。单栏编辑，双栏编辑，三栏编辑，实时预览，全屏写作，全屏阅读…想怎么切换，就怎么切换，就是这样随心所欲。 多种主题选择、丰富的语法支持、第三方同步等功能特色。原先在windows上习惯了使用小书匠，然后就想着在Ubuntu上也装一个。 小书匠安装小书匠已经托管到github，首先下载对应版本到本地。https://github.com/suziwen/markdownxiaoshujiang 解压下载下来的zip文件到指定文件夹：# unzip Story-writer-linux64.zip.zip -d /opt/Story-Writer/ 切换到解压出来的文件夹根目录，然后启动软件# ./Story-writer即可启动软件 存在的问题但是存在两个问题： 无快捷方式，每次打开过于麻烦 不能设置小书匠为系统默认打开.md文件 创建小书匠桌面快捷方式对于没有快捷方式这个问题，让我很容易想到当初安装Eclipse的时候也没有快捷启动方式。然后在网上找到解决方案。 UBuntu的菜单图标保存在/usr/share/applications目录下，所以先在该目录下建一个eclipse.desktop文件sudo gedit /usr/share/applications/eclipse.desktop 在文件中输入以下内容 12345678910[Desktop Entry]Encoding=UTF-8Name=Eclipse Platfrom //图标名字，可修改Comment=Eclipse IDE //注释，可修改Exec=/opt/eclipse/eclipse //Eclipse文件夹下eclipse的路径Icon=/opt/eclipse/icon.xpm //Eclipse文件夹下图标icon.xpm的路径Terminal=falseStartupNotify=trueType=ApplicationCategories=Application;Development; 3.对该文件进行赋权chmod u+x /usr/share/applications/eclipse.desktop 4.双击eclipse的图标就可以运行，然后复制到桌面就可以了 根据Ecllipse图标的制作，同理，然后试了小书匠是否也可以。 12345678910[Desktop Entry]Encoding=UTF-8Name=Story_Writer Comment=Story_WriterExec=/opt/Story_Writer/Story-writerIcon=/opt/Story_Writer/Story-writer.pngTerminal=falseStartupNotify=trueType=ApplicationCategories=Application;Development; 如图： 然后就出现了一个Story_Writer的快捷方式，双击即可打开小书匠。是不是很简单～ 对于另一个问题目前还没找到解决方案…. 原谅我还只是一个小白。如果有幸你可以看到，请留言我！]]></content>
      <categories>
        <category>Ubuntu学习</category>
      </categories>
      <tags>
        <tag>Ubuntu16.04</tag>
        <tag>小书匠</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析素数环问题]]></title>
    <url>%2F2018%2F03%2F18%2F%E6%B5%85%E6%9E%90%E7%B4%A0%E6%95%B0%E7%8E%AF%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[素数环的实现问题描述 从1到n这n个整数围成一个圆环，若其中任意2个相邻的数字相加，结果均为素数，那么这个环就成为素数环。 现在要求输入一个n，求n个数围成一圈有多少种素数环，规定第一个数字是1。 设计思路 1.数据结构：res数组用于保存最后满足描述的情况，isUsed数组用于标记1-n这些数字是否被使用，已达到不重复的效果。 2.规定第一个数字为1，res[0] = 1; 3.依次后面的值有两个限制 a.不能和前面的数字重复 b.和前一个数字相加为素数。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.util.Scanner;public class Main &#123; final static int max = 20; static int N; static int[] res = new int[max]; static boolean[] isUsed = new boolean[max]; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int k = 1; for (int i = 0; i &lt; isUsed.length; i++) &#123; res[i] = i+1; isUsed[i] = false; &#125; N = sc.nextInt(); while(N!=0)&#123; System.out.println("Case "+ k++ +":"); if (N%2==0) &#123; primeRing(1); &#125;else &#123; System.out.println("No Answer"); &#125; N = sc.nextInt(); &#125; sc.close(); &#125; // 递归实现，输出素数环 public static void primeRing(int cur)&#123; if (cur==N &amp;&amp; isPrime(res[cur-1]+res[0])) &#123; // 执行完成，并且首尾相加也是素数 for (int i = 0; i &lt; N-1; i++) &#123; System.out.print(res[i]+" "); &#125;System.out.print(res[N-1]); System.out.println(); return; &#125;else &#123; for (int i = 2; i &lt;= N; i++) &#123; // 选取一个满足条件的值，继续递归 if (!isUsed[i] &amp;&amp; isPrime(i+res[cur-1])) &#123; res[cur] = i; isUsed[i] = true; primeRing(cur+1); isUsed[i] = false; &#125; &#125; &#125; &#125; // 判断是否为素数 public static boolean isPrime(int x) &#123; if (x&lt;3) &#123; // 两数相加必定大于2，所以小于3的值不用考虑 return false; &#125;else &#123; for (int i = 2; i &lt;= Math.sqrt(x); i++) &#123; if (x%i==0) &#123; return false; &#125; &#125; &#125; return true; &#125;&#125; 运行结果 素数表格问题描述 前两天遇到一个问题和素数有关，从1到n中选择9个数字，填入3*3的表格中，使得相邻的数字相加和为素数。输出所有的情况。 设计思路 在CSDN上面看到过一片关于这个问题的博客。相邻两方格内的两个整数之和为质数-经典算法详解。理解起来可能还要一时半会儿。但是我觉得有了上述素数环的理解以及实现，只需要稍微修改一下上面的代码就可以达到表格的要求。 1.将3*3二维表格转换为一维数组。以下表格的数值代表数组中的位置。 0 1 2 7 8 3 6 5 4 2.问题可以简化为数组0-7下标组成一个素数环。然后数组res[8]同时与res1、res3、res[5]、res[7]分别相加合为素数。 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.util.Scanner;public class Main &#123; final static int max = 20; static int N; static int[] res = new int[max]; static boolean[] isUsed = new boolean[max]; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); for (int i = 0; i &lt; isUsed.length; i++) &#123; res[i] = i+1; isUsed[i] = false; &#125; N = sc.nextInt(); primeRing(1); sc.close(); &#125; // 递归实现，输出素数环 public static void primeRing(int cur)&#123; if (cur==8 &amp;&amp; isPrime(res[cur-1]+res[0])) &#123; // res[0]+res[7]和也为素数 for (int i = 2; i &lt;= N; i++) &#123; // 选取最后一个满足条件的值，填入res[8]位置 if (!isUsed[i] &amp;&amp; isPrime(i+res[1]) &amp;&amp; isPrime(i+res[3]) &amp;&amp; isPrime(i+res[5]) &amp;&amp; isPrime(i+res[7])) &#123; for (int j = 0; j &lt; 3; j++) // 输出第一行 System.out.print(res[j]+" "); System.out.println(); System.out.print(res[7]+" "); // 输出第二行 System.out.print(i+" "); System.out.print(res[3]+" "); System.out.println(); for (int j = 6; j &gt; 3; j--) // 输出第三行 System.out.print(res[j]+" "); System.out.println(); System.out.println(); &#125; &#125; return; &#125;else if(cur&lt;8)&#123; // 数组0-7下标组成一个素数环 for (int i = 2; i &lt;= N; i++) &#123; // 选取一个满足条件的值，继续递归 if (!isUsed[i] &amp;&amp; isPrime(i+res[cur-1])) &#123; res[cur] = i; isUsed[i] = true; primeRing(cur+1); isUsed[i] = false; &#125; &#125; &#125; &#125; // 判断是否为素数 public static boolean isPrime(int x) &#123; if (x&lt;3) &#123; // 两数相加必定大于2，所以小于3的值不用考虑 return false; &#125;else &#123; for (int i = 2; i &lt;= Math.sqrt(x); i++) &#123; if (x%i==0) &#123; return false; &#125; &#125; &#125; return true; &#125;&#125; 运行截图]]></content>
      <categories>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>素数环问题</tag>
        <tag>3*3素数表格</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析n元素出栈序列]]></title>
    <url>%2F2018%2F02%2F24%2F%E6%B5%85%E6%9E%90n%E5%85%83%E7%B4%A0%E5%87%BA%E6%A0%88%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[栈的简介 栈（stack）又名堆栈，它是一种运算受限的线性表。其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。遵循后进先出的原则。 n个元素出栈顺序种数 问题描述有n个元素依次进栈，请问总共有多少种出栈序列？ 算法分析首先列举出简单的情况：当1个元素进栈，有1种出栈顺序；当2个元素进栈，有2种出栈顺序；当3个元素进栈，有5种出栈顺序 ；我们把n个元素的出栈个数的记为f(n), 则对于1，2，3有 123f(1) = 1 //即 1f(2) = 2 //即 12、21f(3) = 5 //即 123、132、213、321、231 对于f(4)，我们假定是a,b,c,d四个元素。任意一个元素在其出栈序列中只有4个位置。取元素a分别讨论其在出栈序列中的位置：1.当a元素在位置1时，只可能是a先入栈，然后出栈。接下来就是其它三个元素b,c,d的出栈序列，也就是子问题f(3)。2.元素a在位置2处，有一个元素比a先出栈可能的序列即f(1)，另外两个元素在位置3，4即f(2)。3.元素a在位置3处，有两个元素比a先出栈可能的序列即f(2)，另外两个元素在位置4即f(1)。4.元素a在位置4处，有三个元素比a先出栈可能的序列即f(3).那么f(4) = f(3) + f(2) f(1) + f(1) f(2) + f(3);然后推广到n，按同理我们可以很容易的得到：f(n) = f(0)f(n-1) + f(1)f(n-2) + … + f(n-1)*f(0) 上式也就是卡特兰数（Catalen）:卡特兰数的通项公式为：变换形式：另类递归式： C(n)=((4n-2)/(n+1))C(n-1); 卡特兰数的应用：1.括号化问题。 矩阵链乘： P=a1×a2×a3×……×an，依据乘法结合律，不改变其顺序，只用括号表示成对的乘积，试问有几种括号化的方案？(C(n-1)种) 2.出栈次序问题。 n个元素依次进栈，请问总共有多少种出栈序列？ 案例：2012腾讯实习招聘笔试题在图书馆一共6个人在排队，3个还《面试宝典》一书，3个在借《面试宝典》一书，图书馆此时没有了面试宝典了，求他们排队的总数？ 解析：还书相当于入栈，借书相当于出栈。只有当栈内元素不为空时才可以借书。C(3) = 5。借书3个人，还书3个人求全排列。 总数为53!3! = 180。 3.将多边行划分为三角形问题。将一个凸N+2多边形区域分成三角形区域的方法数?类似：一位大城市的律师在她住所以北n个街区和以东n个街区处工作。每天她走2n个街区去上班。如果她从不穿越（但可以碰到）从家到办公室的对角线，那么有多少条可能的道路？ 类似：在圆上选择2n个点,将这些点成对连接起来使得所得到的n条线段不相交的方法数? 4.给顶节点组成二叉树的问题。给定N个节点，能构成多少种不同的二叉树？（能构成Cn个）Catalan数的解法:Catalan数的组合公式为 Cn=C(2n,n) / (n+1);此数的递归公式为 C(n ) = C(n-1)(4n-2) / (n+1) 代码实现 123456789101112131415161718192021222324252627282930313233343536373839import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[] arr = new int[n+1]; arr[0] = 1;arr[1] = 1; Catalen_1(arr, n);// Catalen_2(arr, n); for (int i = 1;i&lt;=n;i++)&#123; System.out.println(arr[i]); &#125; sc.close(); &#125; public static void Catalen_1(int[] arr, int n) &#123; // 递推关系式 f(n) = f(0)*f(n-1) + f(1)*f(n-2) + … + f(n-1)*f(0) for (int i=2; i&lt;=n; ++i) &#123; for (int j=0; j&lt;i; ++j) &#123; arr[i] += arr[j] * arr[i-1-j]; &#125; &#125; &#125; public static void Catalen_2(int[] arr, int n) &#123; // 递推关系式 C(n)=((4*n-2)/(n+1))*C(n-1) for (int i=2; i&lt;=n; ++i) &#123; arr[i] = arr[i-1] * (4*i-2) / (i+1); &#125; &#125; &#125; 运行结果 n个元素出栈序列输出1.设计思路所需数据结构，1栈2队列，输入队列从头部取出数据压入栈中，数据出栈进入输出队列。最终输出队列即为出栈序列的情况。采用递归的方式，将大问题分解为小问题。栈存在两种状态：1.输入队列入栈，2.输出队列出栈。 2.代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.util.LinkedList;import java.util.Queue;import java.util.Scanner;import java.util.Stack;public class Main &#123; static int n; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); n = sc.nextInt(); // 元素个数 Stack&lt;Integer&gt; s = new Stack&lt;Integer&gt;(); Queue&lt;Integer&gt; in = new LinkedList&lt;Integer&gt;(); for (int i = 1; i &lt;= n; i++) &#123; in.offer(i); &#125; Queue&lt;Integer&gt; out = new LinkedList&lt;Integer&gt;(); printAllOutStackSeq(in, s, out); sc.close(); &#125; @SuppressWarnings("unchecked") public static void printAllOutStackSeq(Queue&lt;Integer&gt; in, Stack&lt;Integer&gt; s, Queue&lt;Integer&gt; out) &#123; if (out.size()==n) &#123; // 所有元素都出栈了 while( !out.isEmpty() )&#123; System.out.print(out.poll()+"");; &#125; System.out.println(); return; &#125; Queue&lt;Integer&gt; inCopy = new LinkedList&lt;Integer&gt;(in); Stack&lt;Integer&gt; sCopy = (Stack&lt;Integer&gt;) s.clone(); Queue&lt;Integer&gt; outCopy = new LinkedList&lt;Integer&gt;(out); if( !s.empty() ) &#123; // 出栈，将元素出栈，push到结果队列中 out.offer( s.pop() ); printAllOutStackSeq( inCopy, s, out ); &#125; if ( !in.isEmpty() ) &#123; // 入栈，将输入队列出队，进行入栈 sCopy.push(in.poll()); printAllOutStackSeq( in, sCopy, outCopy ); &#125; return; &#125;&#125; 3.运行结果 判断一个序列是否是可能的出栈序列1.设计思路输入一个序列，判断该序列是否可能是正确的出栈序列（反向推理）。代码中A代表着有序的输入队列（1，2，3….，n）代码中B代表着所输入的目标序列的下标，从下标为1的位置开始匹配。代码中S代表栈，进行入栈、出栈操作。A == target[B] 当前输入队列头元素与目标序列B位置元素相同，也就是输入队列元素取头元素进行入栈，然后立即出栈。!s.isEmpty() &amp;&amp; s.peek() == target[B] 当前栈顶元素与目标序列B位置元素相同，也就是栈内元素出栈。A &lt;= n 上述两种情况都不满足时，也就是输入队列的头元素一直进行入栈操作。最后也不入栈也不出栈，也不就意味着目标序列不是出栈序列。 2.代码实现123456789101112131415161718192021222324252627282930313233343536import java.util.Scanner;import java.util.Stack;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while(sc.hasNext())&#123; int n = sc.nextInt(); // 元素个数 if (n==0) break; int[] target = new int[n+1]; Stack&lt;Integer&gt; s = new Stack&lt;Integer&gt;(); for (int i = 1; i &lt;= n; i++) &#123; target[i] = sc.nextInt(); &#125; int A = 1, B = 1, flag = 1; while(B &lt;= n)&#123; if (A == target[B]) &#123; A++;B++; &#125;else if (!s.isEmpty() &amp;&amp; s.peek() == target[B]) &#123; s.pop(); B++; &#125;else if (A &lt;= n ) &#123; s.push(A++); &#125;else &#123; flag = 0; break; &#125; &#125; System.out.println(flag==1?"Yes":"No"); &#125; sc.close(); &#125;&#125; 3.运行结果]]></content>
      <categories>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
        <tag>卡特兰数</tag>
        <tag>Catalen</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统经典算法之银行家算法]]></title>
    <url>%2F2017%2F12%2F13%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E4%B9%8B%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[需求分析1. 银行家算法的实现思想 允许进程动态地申请资源，系统在每次实施资源分配之前，先计算资源分配的安全性，若此次资源分配安全（即资源分配后，系统能按某种顺序来为每个进程分配其所需的资源，直至最大需求，使每个进程都可以顺利地完成），便将资源分配给进程，否则不分配资源，让进程等待。 2. 死锁的概念 死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。 此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。银行家算法是避免死锁的一种重要方法。 操作系统按照银行家制定的规则为进程分配资源，当进程首次申请资源时，要测试该进程对资源的最大需求量，如果系统现存的资源可以满足它的最大需求量则按当前的申请量分配资源，否则就推迟分配。当进程在执行中继续申请资源时，先测试该进程已占用的资源数与本次申请的资源数之和是否超过了该进程对资源的最大需求量。若超过则拒绝分配资源，若没有超过则再测试系统现存的资源能否满足该进程尚需的最大资源量，若能满足则按当前的申请量分配资源，否则也要推迟分配。 3. 产生死锁的必要条件① 互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。② 请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。③ 不可抢占条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。④ 循环等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，•••，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。 4.功能实现 理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁。所以，在系统设计、进程调度等方面注意如何能够不让这四个必要条件同时成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源,在系统运行过程中，对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源，若分配后系统可能发生死锁，则不予分配，否则予以分配 。因此，对资源的分配要给予合理的规划。 概要设计1.数据结构1) 可利用资源向量Available。这是一个含有m个元素的数组，其中的而每一个元素代表一类可利用资源数目，其初始值是系统中所配置的该类全部可用资源的数目，其数值随该类资源的分配和回收而动态的改变。如果Available[j]=K,则表示系统中现有Rj类资源K个。 2) 最大需求矩阵Max。这是一个n * m的矩阵，它定义了系统中n个进程中的每一个进程对m类资源的最大需求。如果Max[i,j]=K；则表示进程i需要Rj类资源的最大数目为K。 3) 分配矩阵Allocation。这也是一个n * m的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。如果Allocation[i,j]=K，则表示进程i当前已分得Rj类资源的数目为K。 4) 需求矩阵Need。这也是一个n * m的矩阵，用以表示每一个进程尚需的各类资源数。如果Need[i,j]=K,则表示进程i还需要Rj类资源K个，方能完成任务。 上述三个矩阵间存在下述关系：Need[i,j]=Max[i,j]-Allocation[i,j] 设计思路第一部分：银行家算法模块1．如果Request&lt;=Need,则转向2;否则,出错2．如果Request&lt;=Available,则转向3,否则等待3．系统试探分配请求的资源给进程4．系统执行安全性算法 第二部分:安全性算法模块 设置两个向量① 工作向量:Work=Available(表示系统可提供给进程继续运行所需要的各类资源数目)② Finish:表示系统是否有足够资源分配给进程(True:有;False:没有).初始化为False 若Finish[i]=False&amp;&amp;Need&lt;=Work,则执行3;否则执行4(i为资源类别) 进程P获得第i类资源,则顺利执行直至完成，并释放资源: Work=Work+Allocation; Finish[i]=true;转2 若所有进程的Finish[i]=true,则表示系统安全;否则,不安全! 详细设计1.银行家算法 设Request i是进程Pi的申请向量，如果Request i[j]=K,则表示进程Pi需要K个Rj类型的资源。当Pi发出资源请求后，系统按下述步骤进行检查：1) 如果Request i[j]&lt;=Need[i,j]，便转向步骤2）；否则认为出错，因为它所需要的资源数已经超过它所宣布的最大值。2) 如果Request i[j]&lt;=Available[i,j]，便转向步骤3）；否则，表示尚无足够资源，Pi需等待。3) 系统试探着把资源分配给进程Pi，并修改下面数据结构中的数值： Available[j]:=Available[j]-Request i[j]; Allocation[i,j]:=Allocation[i,j]+Request i[j]; Need[i,j]:=Need[i,j]-Request i[j];4) 系统执行安全性算法，检查此次资源分配后系统是否处于安全状态。若安全，才正式将资源分配给进程Pi，以完成本次分配；否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程Pi等待。 2.安全性算法系统所执行的安全性算法可描述如下：1) 设置两个向量① 工作向量Work，它表示系统可提供给进程继续运行所需的各类资源数目，它含有m个元素，在执行安全算法开始时，Work：=Available。② Finish，它表示系统是否有足够的资源分配给进程，使之运行完成。开始时先做Finish[i]:=false;当有足够资源分配给进程时，再令Finish[i]:=ture.2) 从进程集合中找到一个满足下述条件的进程：① Finish[i]=false;② Need[i,j]&lt;=Work[j];若找不到，执行步骤3），否则，执行步骤4）。3） 当进程Pi获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行： Work[j]:=Work[j]+Allocation[i,j]; Finish[i]:=true; Go to step 2;4) 如果所有进程的Finish[i]=true都满足，则表示系统处于安全状态；否则，系统处于不安全状态。 代码流程图： 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int Available[10]; //可使用资源向量int Max[10][10]; //最大需求矩阵int Allocation[10][10] = &#123; 0 &#125;; //分配矩阵int Need[10][10] = &#123; 0 &#125;; //需求矩阵int Work[10]; //工作向量bool Finish[10]; //是否有足够的资源分配，状态标志int Request[10][10]; //进程申请资源向量int Pause[10];int arr[] = &#123; 0 &#125;; //各类资源总数int List[10];int i, j;int n; //系统资源种类数int m; //总的进程数int a; //当前申请的进程号int l, e, z = 0; //计数器int b = 0, c = 0, f = 0, g; //显示菜单void menu()&#123; printf("*************************银行家算法**************************\n\n"); printf("\n\n\t1:初始化数据"); printf("\n \t2:设置进程资源申请"); printf("\n \t3:查看资源分配状态"); printf("\n \t4:退出程序"); printf("\n\n\t\t\t 请输入你的选择: ");&#125;//显示资源分配状态void mainshow()&#123; printf("\n\n"); if (n == 3) &#123; printf(" 最大需求量 已分配 尚需要量 \n进程"); &#125; if (n == 2) &#123; printf(" 最大需求 已分配 尚需要量 \n进程"); &#125; for (i = 1; i &lt;= 3; i++) &#123; for (j = 1; j &lt;= n; j++) &#123; printf(" %d类", j); &#125; &#125; for (i = 1; i &lt;= m; i++) &#123; printf("\nP[%d]", i); for (j = 1; j &lt;= n; j++) &#123; printf(" %2d ", Max[i][j]); //最大需求 &#125; for (j = 1; j &lt;= n; j++) &#123; printf(" %2d ", Allocation[i][j]); //分配 &#125; for (j = 1; j &lt;= n; j++) &#123; printf(" %2d ", Need[i][j]); //需求 &#125; &#125; printf("\n\n系统剩余资源量： "); for (i = 1; i &lt;= n; i++) &#123; printf(" %d ", Available[i]); &#125; printf("\n");&#125;//安全性检测int securitycheck()&#123; printf("\n\n"); printf("**************************安全性检测**************************\n\n"); printf(" 工作向量 尚需求量 已分配 工作向量+已分配 Finish \n进程 "); for (c = 1; c &lt;= 4; c++) &#123; for (j = 1; j &lt;= n; j++) &#123; printf(" %d类", j); &#125; &#125; for (j = 1; j &lt;= n; j++) &#123; Pause[j] = Available[j]; //Pause[i]为防止在下面安全性检查时修改到Available[i]而定义的备份 &#125; for (i = 1; i &lt;= m; i++) &#123; Finish[i] = false; &#125; for (i = 1; i &lt;= m; i++) &#123; b = 0; //计数器初始化 if (!Finish[i])&#123; for (j = 1; j &lt;= n; j++) //资源种类数 &#123; if (Need[i][j] &lt;= Pause[j]) //可使用资源向量备份，若3类资源均满足条件 &#123; b = b + 1; &#125; else &#123; break; &#125; if (b == n) &#123; Finish[i] = true; printf("\nP[%d] ", i); //依次输出进程安全序列 for (l = 1; l &lt;= n; l++) &#123; printf(" %2d ", Pause[l]); &#125; for (j = 1; j &lt;= n; j++) &#123; printf(" %2d ", Need[i][j]); &#125; for (j = 1; j &lt;= n; j++) &#123; //Allocation[i][j]=Pause[j]-Need[i][j]; printf(" %2d ", Allocation[i][j]); &#125; for (j = 1; j &lt;= n; j++) &#123; printf(" %2d ", Pause[j] + Allocation[i][j]); &#125; printf(" true"); for (l = 1; l &lt;= n; l++) &#123; Pause[l] = Pause[l] + Allocation[i][l]; //回收该进程资源 &#125; i = 0; break; &#125; &#125; &#125; &#125; printf("\n\n"); for (i = 1; i &lt;= m; i++) &#123; if (Finish[i] == true) f = f + 1; //统计Finish[i]＝＝true的个数 &#125; if (f == m) //全为true &#123; printf("处于安全状态"); printf("\n\n系统剩余资源量： "); for (i = 1; i &lt;= n; i++) &#123; printf(" %d ", Available[i]); &#125; f = 0; //将计数器f重新初始化，为下一次提出新的进程申请做准备 printf("\n\n"); return 1; &#125; else &#123; printf("处于不安全状态"); for (i = 1; i &lt;= n; i++) &#123; Available[i] = Available[i] + Request[a][i]; Allocation[a][i] = Allocation[a][i] - Request[a][i]; Need[a][i] = Need[a][i] + Request[a][i]; &#125; printf("\n\n"); return 0; &#125;&#125;//初始化数据void initialize()&#123; printf("请输入系统的资源种类数："); scanf_s("%d", &amp;n); printf("请输入%d类资源总数(以空格分隔)： ", n); for (i = 1; i &lt;= n; i++) &#123; scanf_s("%d", &amp;arr[i]); &#125; printf("请输入进程总数："); scanf_s("%d", &amp;m); for (i = 1; i &lt;= m; i++) &#123; printf("进程P[%d]对这%d类资源的最大需求量(以空格分隔)： ", i, n); for (j = 1; j &lt;= n; j++) &#123; scanf_s("%d", &amp;Max[i][j]); &#125; &#125; for (i = 1; i &lt;= m; i++) &#123; printf("进程P[%d]对这%d类资源已分配数(以空格分隔)： ", i, n); for (j = 1; j &lt;= n; j++) &#123; scanf_s("%d", &amp;Allocation[i][j]); Need[i][j] = Max[i][j] - Allocation[i][j]; //尚需资源数为 最大-已分配 &#125; &#125; for (i = 1; i &lt;= n; i++) &#123; for (j = 1; j &lt;= m; j++) &#123; arr[i] -= Allocation[j][i]; //各类资源总数-各进程分配的资源数 &#125; &#125; for (i = 1; i &lt;= n; i++) Available[i] = arr[i]; securitycheck();&#125;//进程申请资源void mainrequest()&#123; printf("请输入申请资源的进程："); scanf_s("%d", &amp;a); for (i = 1; i &lt;= n; i++) &#123; printf("请输入进程P[%d]对%d类资源的申请量：", a, i); scanf_s("%d", &amp;Request[a][i]); if (Request[a][i] &gt; Need[a][i]) &#123; printf("\n出错！进程申请的资源数多于它自己申报的最大需求量\n"); return; &#125; if (Request[a][i] &gt; Available[i]) &#123; printf("\nP[%d]请求的资源数大于可用资源数，必须等待\n", a); return; &#125; &#125; for (i = 1; i &lt;= n; i++) &#123; //以下是试探性分配 Available[i] = Available[i] - Request[a][i]; Allocation[a][i] = Allocation[a][i] + Request[a][i]; Need[a][i] = Need[a][i] - Request[a][i]; &#125; int ret = securitycheck(); if (ret == 1) &#123; int key = 0; for (j = 1; j &lt;= n; j++) &#123; if (Need[a][j] == 0) &#123; key++; &#125; &#125; if (key == n) &#123; for (j = 1; j &lt;= n; j++) &#123; Available[j] += Allocation[a][j]; Allocation[a][j] = 0; &#125; &#125; &#125;&#125;int main()&#123; int key = 0; printf("\n\n"); while (1) &#123; menu(); scanf_s("%d", &amp;key); printf("\n\n"); switch (key) &#123; case 1: initialize(); break; case 2: mainrequest(); break; case 3: mainshow(); break; case 4: printf("\n\n\t\t谢谢使用 \n"); printf("\n\t\tMade by 杨陈强!\n\n\n"); system("pause"); return 0; &#125; &#125; system("pause"); return 0;&#125; 结果分析程序菜单界面： 初始化数据：（模拟课本113例子） T0时刻的安全性： 由上图可知，存在安全序列{P2,P4,P1,P3,P5},（存在多种情况，此处只寻找到一种可行的情况）故系统处于安全状态。 P2请求资源：P2发出请求向量Request2（1，0，2），系统按银行家算法进行检查。然后再通过安全性算法检查此时系统是否处于安全状态。上图为安全状态！ 银行家算法测试:当进程1申请的资源大于系统剩余的资源时，提示进程必须等待！ 安全性算法测试：当进程1申请的资源过多时，导致各进程处于请求与保持状态，提示系统处于不安全状态！并且此次资源申请无效 查看资源分配情况：（依然处于第一次P2请求资源结束的状态） 通过这次课程设计，让我对银行家算法（避免死锁）有了更深入的理解，同时借鉴网上一些优秀的实现过程，自己理解并修改而记之！]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Android Canvas绘制折线图]]></title>
    <url>%2F2017%2F12%2F08%2F%E4%BD%BF%E7%94%A8Android-Canvas%E7%BB%98%E5%88%B6%E6%8A%98%E7%BA%BF%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[优化画图方法 原先磁感应力检测仪项目的绘图方法一直是采用的Android AChartEngine方法，简单介绍一下AChartEngine，它是 Android 平台的图表开发库, 能绘制 折线图, 饼图, 气泡图, 柱状图, 散点图, 面积图等统计图表。网上有很多例子，推荐一个Android 图表绘制 achartengine 示例解析。该方法优点：使用简单，只需要将数据传入到数据集，并设置相应渲染器的绘制颜色，线的粗细等等。缺点：当数据量较大时，在移动与缩放时会显得比较卡顿。 接下来就介绍一种新的绘制方法：Android Canvas方法 当我们在自定义 View的时候，我们经常需要绘制一些自己想要的效果。通过Canvas对象我们就可以绘制出我们自己想要的效果。比如折线图、平面图等等。对于一些简单的原理操作网上有很多Demo，推荐一个我在简书上面看到的一篇Android Canvas 方法总结，里面介绍了关于Canvas的平移、缩放、旋转，以及后面使用Canvas对象绘制直线、各种形状以及文字。通过图形的展示，我相信很快就可以看懂啦！ 正式开始我做的内容： 首先贴一张我们所需要最终达到的效果图 1.坐标线的绘制：此时需要注意的是Canvas画布的坐标是以 左上角为坐标原点的，水平向右为X轴的正方向，垂直向下为Y轴的正方向，而为了美观以及需求，我们需要将坐标原点设置在左下角，同时Y轴的正方向为垂直向上。而达到最终效果。坐标原点设置在左下角可以通过简单的平移画布而实现坐标（0，0）位于View的左下角，但是方向岂不是还要通过翻转？ 这里其实并没有翻转这个方法，我指的其实就是通过坐标数据计算它对应的位置。画布的坐标原点并非你所显示的坐标原点。这样会使得画图麻烦很多。此时通过一个巧妙地方法，坐标数据的Y值我给它一个负号，那么如果是（2，5）和（3，7），而我实际将它们绘制在画布上的（2，-5）和（3，-7）；而-7比-5小，正好-7就在-5的上方，从而模拟出正方形为垂直向上。123456789//绘制坐标线@Overridepublic void drawAxis(Canvas canvas) &#123; canvasWidth -= 140f; //留有边距以显示坐标对应的值 canvasHeight -= 140f; canvas.translate(110f, canvasHeight + 40f); // 使画布向 x 轴正向移动 110f，向 y 轴移动 40f canvas.drawLine(0, 0, canvasWidth, 0, paint); // 绘制 x 轴 canvas.drawLine(0, 0, 0,-canvasHeight, paint); // 绘制 y 轴&#125; 2.坐标刻度的绘制坐标主要需要完成动态的适配，当平移和缩放的时候坐标动态显示，并且完成它们之间的间距控制，所显示的画布上坐标轴上只显示2-6个坐标，避免坐标刻度太密而使得刻度值挤在一块无法显示。实现思路是：a.通过float interval = measureInterval(xDistance/xScale); //每组值得间隔计算当前显示区域的相邻坐标的间距。b.通过int n = (int) Math.ceil((xDistance/xScale)/interval); //一组有几个值计算当前显示区域的坐标数量也就对于上述的（2-6）c.通过1int first = (int) Math.floor((xStart-((1-xScale)/2+xTranslate/canvasWidth)*xDistance/xScale)/interval); 计算出所显示的首坐标的位置。d.循环n次，依次显示n个从first+i开始的坐标刻度值。 123456// 所需要的坐标属性： protected float xDistance; // x 方向总距离 protected float yDistance; // y 方向总距离 protected float xStart=0, yStart=0; // 起始点坐标 protected float xTranslate = 0, yTranslate = 0; // 分别控制 x 和 y 方向的平移距离，单位为屏幕像素，达到手指移动多少，坐标平移多少 protected float xScale = 1, yScale = 1; // 分别控制 x 和 y 方向的缩放程度 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 //绘制坐标值及刻度 @Override public void drawCoordinates(Canvas canvas) &#123; String number; DecimalFormat df1 = new DecimalFormat("0.0"); DecimalFormat df2 = new DecimalFormat("0.00"); DecimalFormat df3 = new DecimalFormat("0.000"); // 绘制 x 轴坐标 canvas.save(); // 保存画布状态 canvas.clipRect(0, 0, canvasWidth, 60f); // 切割画布，使坐标显示在一定范围内 canvas.translate((1 - xScale) / 2 * canvasWidth, 0); // 缩放时，平移使得与折线图一致 canvas.translate(xTranslate, 0); // 使坐标跟着图形一起平移 float interval = measureInterval(xDistance/xScale); //每组值得间隔 int n = (int) Math.ceil((xDistance/xScale)/interval); //一组有几个值 int first = (int) Math.floor((xStart-((1-xScale)/2+xTranslate/canvasWidth)*xDistance/xScale)/interval); for (int i = 0; i &lt;= n; i++)&#123; if (interval &lt; 0.01)&#123; number = df3.format((first+i)*interval); &#125;else if (interval &lt;= 0.1)&#123; number = df2.format((first+i)*interval); &#125;else if (interval &lt; 1)&#123; number = df1.format((first+i)*interval); &#125;else &#123; number = String.valueOf((first+i)*(int)interval); &#125; canvas.drawLine((canvasWidth * (first+i) * interval / xDistance * xScale), 0f, (canvasWidth * (first+i) * interval / xDistance * xScale), 10f,paint); canvas.drawText( number, (canvasWidth * (first+i) * interval / xDistance * xScale), 40f, paint); &#125; canvas.restore(); // 使画布返回上一个状态 // 绘制 y 轴坐标 canvas.save(); // 保存画布状态 canvas.clipRect(-110f, -canvasHeight, 0, 0); // 切割画布，使坐标显示在一定范围内 canvas.translate(0, -(1 - yScale) / 2 * canvasHeight); // 缩放时平移使得与折线图一致 canvas.translate(0, (yTranslate/yScale-yStart/yDistance*canvasHeight)*yScale); // 使坐标跟着图形一起平移 interval = measureInterval(yDistance/yScale); //每组值得间隔// Log.d("Chart","interval="+interval); n = (int) Math.ceil((yDistance/yScale)/interval); //一组有几个值// Log.d("Chart","n="+n); first = -(int) Math.floor((yStart+yDistance/yScale/2*(1-yScale)-yTranslate/yScale/canvasHeight*yDistance)/interval);// Log.d("Chart","first="+first); for (int i = 0; i &lt;= n; i++)&#123; if (interval &lt; 0.01)&#123; number = df3.format((first+i)*interval); &#125;else if (interval &lt;= 0.1)&#123; number = df2.format((first+i)*interval); &#125;else if (interval &lt; 1)&#123; number = df1.format((first+i)*interval); &#125;else &#123; number = String.valueOf((first+i)*(int)interval); &#125; canvas.drawLine(-10f, -(canvasHeight * (first+i) * interval / yDistance * yScale), 0f, -(canvasHeight * (first+i) * interval / yDistance * yScale),paint); canvas.drawText( number, -5f, -(canvasHeight * (first+i) * interval / yDistance * yScale)-4, paint); &#125; canvas.restore(); // 使画布返回上一个状态 &#125; 以下为坐标完成动态适配的效果图： 3.折线与图形的绘制由于需要绘制两种不同的图形，去噪图（折线图）和扫描图（平面图），此处将画图方法抽象出来：子类通过重写drawAction方法来完成各自所需绘制的图形。同时后期如果需要绘制其他类型的图，继承此抽象类然后重写自己的drawAction方法即可实现不同类型的图形绘制。以下为折线图的drawAction方法：根据平移与缩放值，将画布进行相应的平移与缩放，同时设置图形的缩放中心，以所显示图形的中心点为缩放中心。然后设置画笔样式及颜色，通过所获取的xList与yList值连接相邻点达到绘制折线的效果。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//绘制曲线 @Override public void drawAction(Canvas canvas) &#123; // 裁切矩形，把画面控制在坐标平面内 canvas.clipRect(0, 0, canvasWidth, -canvasHeight); // 手势缩放移动 canvas.translate(xTranslate/xScale, yTranslate/yScale-yStart/yDistance*canvasHeight); float px = (canvasWidth / 2 - xTranslate/xScale); float py = (canvasHeight / 2 + yTranslate/yScale-yStart/yDistance*canvasHeight); canvas.scale(xScale, yScale, px, -py); //以图的中心点缩放 paint.setDither(true); //设定是否使用图像抖动处理，会使绘制出来的图片颜色更加平滑和饱满，图像更加清晰 paint.setFilterBitmap(true); //如果该项设置为true，则图像在动画进行中会滤掉对Bitmap图像的优化操作，加快显示速度，本设置项依赖于dither和xfermode的设置 paint.setStyle(Paint.Style.FILL_AND_STROKE); //设置画笔的样式，Style.FILL: 实心 STROKE:空心 FILL_OR_STROKE:同时实心与空心 paint.setStrokeJoin(Paint.Join.ROUND); //设置绘制时各图形的结合方式，如平滑效果等 BEVEL斜角 //paint.setStrokeWidth(4/xScale); //当画笔样式为STROKE或FILL_OR_STROKE时，设置笔刷的粗细度 int[] colors = GlobalParameter.getInstance().getColors(); // 绘制图形 for (int i=0; i&lt;showIDs.size(); i++) &#123; //通道数 for (int j=0; j&lt; yList.get(showIDs.get(i)).size()-1; j++) &#123; paint.setColor(colors[showIDs.get(i)]); if ((yList.get(showIDs.get(i)).get(j+1)-yList.get(showIDs.get(i)).get(j))&lt;15&amp;&amp;(yList.get(showIDs.get(i)).get(j+1)-yList.get(showIDs.get(i)).get(j))&gt;-15)&#123; paint.setStrokeWidth(3/yScale); &#125;else &#123; paint.setStrokeWidth(3/xScale); &#125; canvas.drawLine( //xDistance x方向的总距离 xList.get(j) / xDistance * canvasWidth, -yList.get(showIDs.get(i)).get(j) / yDistance * canvasHeight, xList.get(j+1) / xDistance * canvasWidth, -yList.get(showIDs.get(i)).get(j+1) / yDistance * canvasHeight, paint ); &#125; &#125; if (points!=null)&#123; paint.setColor(Color.RED); for (int i=0;i&lt;points.size()-1;i++)&#123; canvas.drawLine( //xDistance x方向的总距离 points.get(i).getX() / xDistance * canvasWidth, -points.get(i).getY() / yDistance * canvasHeight, points.get(i+1).getX() / xDistance * canvasWidth, -points.get(i+1).getY() / yDistance * canvasHeight, paint ); &#125; &#125; initPaints(); //画笔reset &#125; 以下为PopWindow弹出框中横屏显示折线图的效果： 4.Touch手势事件的监听Android Canvas 没有提供有关手势缩放的功能，但我们可以利用onTouchListener 来监测手势，并根据手势的不同对扫描图作不同处理，比如移动和缩放。采用接口回调机制，在所需用到AbstractChartService对象处，进行手势监控，减少抽象类间的耦合性。 通过设置OnTouchListener监听，只要有手指触碰到绘制的图形，就会触发 onTouch 方法，同时通过判断event.getAction() 获取到手势的不同动作，来完成你所重写的响应事件。重写onTouch方法，通过 event.getAction() 获取到的值，自动判断执行哪一个 case 中的代码，即通过监测不同的动作来对图形作出相应处理。我们的处理主要就是移动和缩放，通过event.getX、event.getY方法所获取的手势点击的屏幕坐标，计算图形的平移及缩放值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// 设置折线图的触摸事件，使扫描图保持同步平移和缩放 chartView.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View view, MotionEvent event) &#123; switch (event.getAction()) &#123; // 一根手指按下时 case MotionEvent.ACTION_DOWN: if (!mPopupWindow.isShowing()) &#123; //大图未显示时 // 双击扫描图跳转到大图 if (event.getEventTime() - chartView.getUpTime() &lt; 200) &#123; addToBigchartLayout(chartView); &#125; &#125; chartView.setxDown(event.getX()); chartView.setyDown(event.getY()); break; // 手指抬起时 case MotionEvent.ACTION_UP: chartView.setUpTime(event.getEventTime()); break; // 手指移动时 case MotionEvent.ACTION_MOVE: // 只有一根手指移动时 if (event.getPointerCount() == 1 &amp;&amp; event.getAction() != 261 &amp;&amp; chartView.getxDown() != 0 &amp;&amp; chartView.getyDown() != 0 ) &#123; // 实现图形平移 chartView.setxTranslate(chartView.getxTranslate()+(event.getX() - chartView.getxDown()) ); chartView.setyTranslate(chartView.getyTranslate()+(event.getY() - chartView.getyDown()) ); chartView.setxDown(event.getX()); chartView.setyDown(event.getY()); &#125; // 有两根手指移动时 else if (event.getPointerCount() == 2) &#123; // 实现扫描图缩放 double xLenMove = Math.abs(event.getX(0) - event.getX(1)); double yLenMove = Math.abs(event.getY(0) - event.getY(1)); double lenMove = Math.sqrt(xLenMove * xLenMove + yLenMove * yLenMove); // 动态更新 // 设置最小缩放比例为 0.4 if (chartView.getxScale() + (lenMove / chartView.getLenDown() - 1) &gt; 0.4) &#123; chartView.setxScale((float) (chartView.getxScale() + (lenMove / chartView.getLenDown() - 1))); chartView.setyScale((float) (chartView.getyScale() + (lenMove / chartView.getLenDown() - 1))); chartView.setLenDown(lenMove); &#125; chartView.setxDown(0); chartView.setyDown(0); &#125; break; // 有两根手指按下时 case 261: double xLenDown = Math.abs(event.getX(0) - event.getX(1)); double yLenDown = Math.abs(event.getY(0) - event.getY(1)); chartView.setLenDown(Math.sqrt(xLenDown * xLenDown + yLenDown * yLenDown)); break; // 两根手指中的一根抬起时 case MotionEvent.ACTION_POINTER_UP: chartView.setxDown(0); chartView.setyDown(0); break; default: break; &#125; chartView.postInvalidate(); //手势完成时重绘 scanView.setxTranslate(chartView.getxTranslate()); scanView.setxScale(chartView.getxScale()); scanView.postInvalidate(); // 只有当返回 false 时才会开启手势检测效果，否则折线图将无法移动和缩放 return false; &#125; &#125;); 最后通过计算的平移值以及缩放值，重绘图形。 完成以上步骤就可以在其它Activity中使用自己封装的对象来完成各种不同图形的绘制。如下是适配设备校准的绘图方法： 项目源码可见我的Github仓库漏磁检测系统。]]></content>
      <categories>
        <category>安卓学习</category>
      </categories>
      <tags>
        <tag>安卓</tag>
        <tag>漏磁检测</tag>
        <tag>Andriod</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[校准数据处理篇-漏磁检测]]></title>
    <url>%2F2017%2F12%2F04%2F%E6%A0%A1%E5%87%86%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%AF%87-%E6%BC%8F%E7%A3%81%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[优化校准数据处理问题描述： 校准模块通过正反方向两次校准。每次进行数据处理获取到该次校准四个梯度(20%、40%、60%、80%)的去噪值以及对应步长（X坐标），以便后续的曲线拟合。 处理方法1：（维护极大值间的顺序关系） 所有极大值按Y值（去噪值）排序。 根据最大的两个极大值点，计算x坐标满足的关系（x坐标递增或者递减），通过改关系以剔除错误数据。 选择最大的四个极大值 该方法的处理效果： 去噪值排序后，X轴也满足递增或者递减的顺序。可以排除当20%的缺陷去噪值小于其他区间的误差值。如下图： 上图阴影部分为可去噪的效果。在阴影部分出现的缺陷值都可以过滤掉。 缺点：当某些地方误差值过大时，可能掩盖真实缺陷比处的值。（A、C为真实缺陷百分比对应的值，而B点为错误值。因为B&gt;C而过滤掉C点） 处理方法2：（改进方法，x坐标之间间隔控制，同时维护间距） 所有极大值按Y值（去噪值）排序。 首先获取数据最大为80%缺陷对对应的去噪值，以此寻找第二个值，通过这两个值计算步数间隔。 继续计算下一个点的位置，在第二个点的基础上增加间隔internal，从该X坐标左右寻找存在的去噪值。 更新间隔internal,按此方法计算第四个满足条件的值。 若无满足的条件，依次选取第二大的去噪值为80%对应的缺陷值。重复2-4步骤。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148import com.tomatoLCJC.tools.Parameter.SystemParameter;import java.util.ArrayList;import java.util.Collections;import java.util.HashMap;import java.util.List;import java.util.Map;/** * Created by YCQ on 2017/10/10. */public class InstrumentCalibration &#123; private static double range = 0.1; //左右寻找10%的区域 通过修改这个确定精确度 /******************************************************************************************* * 函数名称：getMaximumValue * 函数介绍：获取曲线的极大值, 原理是:已知输入曲线有4个峰,该算法的思想就是求出这每个峰的起始x坐标和结束x坐标（即求出峰所在的区间） 然后在该区间中搜最大值从而求出极大值。 * 输入参数：order 表示第几次获取极大值 * 输出参数：无 * 返回值 ：无 ********************************************************************************************/ public static List&lt;Point&gt; getMaximumValue(List&lt;Double&gt; yValue) //获取极大值 &#123; List&lt;Point&gt; maxValue=new ArrayList&lt;&gt;(); double key = 10; //设置标记值为10（即认为从某个大于60的点开始到某个小于60的点结束为峰的区间）也可以为其他值，根据需要来定 int end = yValue.size(); List&lt;Integer&gt; xValue=new ArrayList&lt;&gt;(); //记录所有峰的起始坐标和结束坐标（就是记录所有峰的区间） int flag = 0; //信号量 因为算法要求记录峰值的起始和结束坐标，当某一点大于标记值key以后因为峰的单调递增性会有很多点也大于可以 //所以用flag标记当获取了第一个大于标记值key以后让程序不再记录x坐标直到条件再次满足 for (int i = 0; i &lt; end; ++i) //这是搜索峰的区间部分 &#123; if (key &lt; yValue.get(i) &amp;&amp; 0 == flag) &#123; xValue.add(i); flag = 1; &#125; if (key &gt; yValue.get(i) &amp;&amp; 1 == flag) &#123; xValue.add(i); flag = 0; &#125; &#125; xValue.add(end - 1); int length = xValue.size(); for (int i = 0; i &lt; length / 2; ++i) //根据区间搜索极大值 &#123; double temp = yValue.get(xValue.get(2*i)); int k = xValue.get(2*i) + 1; for (int j = k; j &lt; xValue.get(2*i+1); ++j) &#123; if (temp &lt; yValue.get(j)) &#123; temp = yValue.get(j); k = j; &#125; &#125; maxValue.add(new Point(k,Float.valueOf(String.valueOf(temp)))); &#125; Collections.sort(maxValue); //根据Y值 从大到小排序 if (maxValue.size()&lt;4) &#123; return maxValue; //极大值个数小于4，在后续过程会滤掉该情况，直接返回 &#125; else &#123;// return adjustOrder(maxValue); //第一种校准方法 return adjustOrder2(maxValue); //第二种校准方法 &#125; &#125; //第一种调整方法，根据递增和递减顺序 public static List&lt;Point&gt; adjustOrder(List&lt;Point&gt; value )&#123; List&lt;Point&gt; resValue=new ArrayList&lt;&gt;(); resValue.add(value.get(0)); //滤掉可能出现的错误 double flag_x = value.get(0).getX(); int flag_pOm = value.get(1).getX()-value.get(0).getX() &gt; 0 ? 1:-1; //设置正序标记 //剔除x非正序的Point for (int i=1;i&lt;value.size();i++)&#123; if ((value.get(i).getX()-flag_x &gt; 0 ? 1:-1)==flag_pOm)&#123; resValue.add(value.get(i)); flag_x = value.get(i).getX(); &#125; &#125; resValue = new ArrayList&lt;&gt;(resValue.subList(0 , Math.min(4,resValue.size()))); //size&gt;4时仅获取前四个值， return resValue; &#125; //第二种调整方法，根据递增和递减顺序 public static List&lt;Point&gt; adjustOrder2(List&lt;Point&gt; value )&#123; //x为步数，y为去噪值 Map&lt;Integer,Float&gt; map = new HashMap&lt;&gt;(); for (int i= 0;i&lt;value.size();i++)&#123; map.put((int) value.get(i).getX(), value.get(i).getY()); &#125; List&lt;Point&gt; resValue=new ArrayList&lt;&gt;(); for(int i=0;i&lt;4;i++) resValue.add(new Point(0.0f, 0.0f)); //初始化4个point int interval; //间隔 for (int i=0 ; i&lt;value.size()-4 ; i++)&#123; resValue.set(0,value.get(i)); //循环以此向后寻找一个最优的缺陷 80% for(int j=i+1;j&lt;value.size()-3; j++)&#123; resValue.set(1,value.get(j)); //60% interval = (int) (resValue.get(1).getX()-resValue.get(0).getX()); //80与60之间的间距（步数） for (int k=0;k&lt;Math.abs((int)(interval*range));k++)&#123; if (map.containsKey((int)(resValue.get(1).getX()+interval+k)) &amp;&amp; map.get((int)(resValue.get(1).getX()+interval+k)) &lt; resValue.get(1).getY())&#123; resValue.set(2,new Point((resValue.get(1).getX()+interval+k), map.get((int)(resValue.get(1).getX()+interval+k)))); int interval1= (((int) (resValue.get(2).getX()-resValue.get(1).getX()))+interval)/2; for (int m=0;m&lt;Math.abs((int)(interval1*range));m++)&#123; if (map.containsKey((int)(resValue.get(2).getX()+interval1+m)) &amp;&amp; map.get((int)(resValue.get(2).getX()+interval1+m)) &lt; resValue.get(2).getY())&#123; resValue.set(3,new Point((resValue.get(2).getX()+interval1+m), map.get((int)(resValue.get(2).getX()+interval1+m)))); return resValue; &#125; if (map.containsKey((int)(resValue.get(2).getX()+interval1-m)) &amp;&amp; map.get((int)(resValue.get(2).getX()+interval1-m)) &lt; resValue.get(2).getY())&#123; resValue.set(3,new Point((resValue.get(2).getX()+interval1-m), map.get((int)(resValue.get(2).getX()+interval1-m)))); return resValue; &#125; &#125; &#125; if (map.containsKey((int)(resValue.get(1).getX()+interval-k)) &amp;&amp; map.get((int)(resValue.get(1).getX()+interval-k)) &lt; resValue.get(1).getY() )&#123; resValue.set(2,new Point((resValue.get(1).getX()+interval-k), map.get((int)(resValue.get(1).getX()+interval-k)))); int interval1= (((int) (resValue.get(2).getX()-resValue.get(1).getX()))+interval)/2; for (int m=0;m&lt;Math.abs((int)(interval1*range));m++)&#123; if (map.containsKey((int)(resValue.get(2).getX()+interval1+m)) &amp;&amp; map.get((int)(resValue.get(2).getX()+interval1+m)) &lt; resValue.get(2).getY())&#123; resValue.set(3,new Point((resValue.get(2).getX()+interval1+m), map.get((int)(resValue.get(2).getX()+interval1+m)))); return resValue; &#125; if (map.containsKey((int)(resValue.get(2).getX()+interval1-m)) &amp;&amp; map.get((int)(resValue.get(2).getX()+interval1-m)) &lt; resValue.get(2).getY())&#123; resValue.set(3,new Point((resValue.get(2).getX()+interval1-m), map.get((int)(resValue.get(2).getX()+interval1-m)))); return resValue; &#125; &#125; &#125; &#125; &#125; &#125; return new ArrayList&lt;&gt;(); &#125; //list逆序 public static List&lt;Point&gt; invertedOrder(List&lt;Point&gt; value )&#123; List&lt;Point&gt; resValue = new ArrayList&lt;&gt;(); for (int i=1;i &lt;= value.size();i++)&#123; //从小到大排列，逆序填充 resValue.add(new Point( value.get(value.size()-i).getX()*(float) SystemParameter.getInstance().disSensorStepLen/1000 , value.get(value.size()-i).getY() )); &#125; return resValue; &#125;&#125;]]></content>
      <categories>
        <category>安卓学习</category>
      </categories>
      <tags>
        <tag>安卓</tag>
        <tag>漏磁检测</tag>
        <tag>Andriod</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python入门（1）]]></title>
    <url>%2F2017%2F11%2F07%2FPython%E5%85%A5%E9%97%A8%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[自学廖雪峰教程代码笔记通过自己在廖雪峰Python教程的学习，自己也尝试实现里面的一些基本语法，加强自己的理解，是学习一门语言最重要的部分！Python是一种解释型、面向对象、动态数据类型的高级程序设计语言。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355# -*- coding: utf-8 -*-L = [ ['Apple', 'Google', 'Microsoft'], ['Java', 'Python', 'Ruby', 'PHP'], ['Adam', 'Bart', 'Lisa']]# 打印Apple:print(L[0][0])# 打印Python:print(L[1][1])# 打印Lisa:print(L[2][2])print('') # python每次输出默认为一行，print('') 相当于换行# 条件判断height = 1.75weight = 80.5bmi = weight / (height * height)if bmi &lt; 18.5: print('过轻')elif bmi &lt; 25: print('正常')elif bmi &lt; 28: print('过重')elif bmi &lt; 32: print('肥胖')else: print('严重肥胖')print('')# 循环计算高斯公式，range的使用sum = 0# for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:for x in range(11): # 生成0-10的11个整数 sum = sum + xprint(sum)print('')# List的使用L = ['Bart', 'Lisa', 'Adam']for x in L: print('Hello,', x)print('')# 循环n = 1while n &lt;= 20: if n == 5: n = n + 1 # while循环，+1运算在循环尾，此处需要加1，才可保证 continue if n &gt; 10: # 当n = 11时，条件满足，执行break语句 break # break语句会结束当前循环 print(n) n = n + 1print('END')print('')# list的特点：# 1.查找和插入的时间随着元素的增加而增加；# 2.占用空间小，浪费内存很少。# dict（字典-相当于map）的特点：(以空间换时间)# 1.查找和插入的速度极快，不会随着key的增加而变慢；# 2.需要占用大量的内存，内存浪费多d = &#123;'Michael': 95, 'Bob': 75, 'Tracy': 85&#125;print(d['Bob'])print('')# set可以看成数学意义上的无序和无重复元素的集合s = set([1, 1, 2, 2, 3, 3]) # 重复数据自动过滤掉for x in s: print(x)print('')s = set((1, 2, 3)) # 将元组赋给setfor x in s: print(x)print('')# s = set((1,[2,3])) # 不可以将tuple(不可变对象)赋给set# for x in s:# print(x)# print('')# python内置函数n1 = 255n2 = 1000print(hex(n1))print(hex(n2))print('')def my_abs(x): if x &gt;= 0: return x else: return -xx = -20print(my_abs(x))print('')def power(x, n=2): # x为必选参数，n为默认参数 s = 1 while n &gt; 0: n = n - 1 s = s * x return sprint(power(5))print(power(5, 3))print('')def enroll(name, gender, age=6, city='Beijing'): print('name:', name) print('gender:', gender) print('age:', age) print('city:', city)enroll('Yang', 'A', 18)print('-------------')enroll('Chen', 'B', city='wuhan') # 当不按顺序提供部分默认参数时，需要把参数名写上print('')def add_end(L=[]): # 默认参数L也是一个变量，它指向对象[] L.append('END') print(L)add_end([1, 2, 3])add_end() # ['END']add_end() # ['END', 'END']print('')def add_end_1(L=None): # 默认参数必须指向不变对象！ None为不变对象 if L is None: L = [] L.append('END') print(L)add_end_1()add_end_1()print('')# 可变参数 (可变参数在函数调用时自动组装为一个tuple元组)def calc(*numbers): sum = 0 for n in numbers: sum = sum + n * n return sumprint(calc(1, 2, 3, 4))print('')# 关键字参数 （关键字参数在函数内部自动组装为一个dict字典） 作用：可以扩展函数的功能def person(name, age, **kw): print('name:', name, 'age:', age, 'other:', kw)person('Adam', 45, gender='M', job='Engineer')print('')extra = &#123;'city': 'Beijing', 'job': 'Engineer'&#125;person('Jack', 24, **extra) # **kw关键字参数获取到extra字典（dict）的一个拷贝print('')# 必选参数、默认参数、可变参数、关键字参数和命名关键字参数的参数组合def f1(a, b, c=0, *args, **kw): print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw)def f2(a, b, c=0, *, d, **kw): # * 后面的参数被视为命名关键字参数 print('a =', a, 'b =', b, 'c =', c, 'd =', d, 'kw =', kw)f1(1, 2)f1(1, 2, c=3)f1(1, 2, 3, 'a', 'b') # （'a', 'b'）可变参数f1(1, 2, 3, 'a', 'b', x=99)f2(1, 2, d=99, ext=None)print('')# 递归函数 与尾递归（在函数返回的时候，调用自身本身，并且return语句不能包含表达式）# 计算n的阶乘def fact(n): if n == 1: return 1 return n * fact(n - 1)print(fact(100))print('')# 上述递归中，如果调用次数过多就会出现栈溢出。 解决方法就是使用尾递归。def fact_back(n): return fact_iter(n, 1)def fact_iter(num, product): if num == 1: return product return fact_iter(num - 1, num * product) # 每次递归时就把该次结果作为参数传递给下一轮循环print(fact_back(100))print('')# 切片的使用L = list(range(100))print(L)print('')# 切片的三个参数的意义：1.首位置 2.末尾置 3.每n一取 [ )左闭右开区间print(L[:10])print(L[-10:])print(L[10:20])print(L[:10:2])print(L[::5])print('')# 迭代器 可迭代对象有：字符串、list、tuple(元组)、dict、setfor ch in 'ABC': print(ch)print('')for i, value in enumerate(['A', 'B', 'C']): # enumerate把一个list变成索引-元素对 print(i, value)print('')for x, y in [(1, 1), (2, 4), (3, 9)]: # 两个变量的迭代 print(x, y)print('')# 列表生成器print(list(range(1, 11))) # 生成1-10的list，左闭右开print('')print([x * x for x in range(1, 11) if x % 2 == 0]) # 生成1-10之间偶数的平方print('')print([m + n for m in 'ABC' for n in 'XYZ']) # 两层循环生成全排列print('')import os # 导入os模块，模块的概念后面讲到print([d for d in os.listdir('.')]) # [] 生成listprint('')d = &#123;'x': 'A', 'y': 'B', 'z': 'C'&#125; # dictprint([k + '=' + v for k, v in d.items()]) # 使用两个变量来生成listprint('')L1 = ['Hello', 'World', 18, 'Apple', None]print(L1)print('')L2 = [s.lower() for s in L1 if isinstance(s, str)] # 如果s为字符串，则转换为小写生成列表print(L2)print('')# 生成器：generator。 （用于一边循环一边推到下一个值）g = (x * x for x in range(10))print(g) # 输出：&lt;generator object &lt;genexpr&gt; at 0x0000009576A0A4C0&gt;# next(g) 使用生成器生成下一个元素的值print('')for n in g: print(n)print('')def fib(max): # 斐波纳契数列 n, a, b = 0, 0, 1 # 变量初始化，相当于 n=0;a=0;b=1 while n &lt; max: print(b) a, b = b, a + b n = n + 1 return 'done'print(fib(6))print('')def fibonacci(max): n, a, b = 0, 0, 1 while n &lt; max: yield b # 每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行 a, b = b, a + b n = n + 1 return 'done'g = fibonacci(6)print(next(g))print(next(g))print(next(g))print(g)print('')while True: # 必须捕获StopIteration错误，才可以获取到fibonacci（）的返回值 try: x = next(g) print('g:', x) except StopIteration as e: print('Generator return value:', e.value) breakprint('')# 杨辉三角，生成器写法def triangles(): L = [1] while True: yield L L.insert(0, 0) #首尾添加一个0，便于循环计算 L.append(0) L = [L[i] + L[i + 1] for i in range(len(L)-1)]n=0for t in triangles(): print(t) n = n + 1 if n == 10: breakprint('')# 迭代器# 可迭代对象（Iterable） （特点：可直接作用于for循环的）# 1.集合数据类型，如list、tuple、dict、set、str等；# 2.generator，包括生成器和带yield的generator function# 迭代器（Iterator）对象：生成器# list、tuple、dict、set、str可以通过iter()返回Iterator对象from collections import Iterableprint(isinstance([], Iterable))print('')from collections import Iteratorprint(isinstance([], Iterator))print(isinstance(iter([]), Iterator)) 身边有许多人都赶上AI学习的浪潮，我还是想努力做好一件事，在学习之余，自己看了看python，对这门语言很是好奇！很想先接触一下，虽然对python以后的方向并不是很清楚，适当扩展扩展自己的知识面也是灰常重要的！]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[static虽好，可不要滥用]]></title>
    <url>%2F2017%2F10%2F30%2Fstatic%E8%99%BD%E5%A5%BD%EF%BC%8C%E5%8F%AF%E4%B8%8D%E8%A6%81%E6%BB%A5%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Java中static作用详解 在自己的项目中已经两次入了static的坑，正如title所讲，static虽好但是请别滥用。 static表示”静态”、”全局”的意思，可以修饰成员变量、方法，以及静态代码块，一下列举几种常用的static用法： 静态域（静态变量）如果将类中的域定义为static，那么所有该类的对象共享这一个静态域。域分为实例域与静态域。静态域属于类而不属于任何一个独立的对象。 这也是我做项目是出现问题的所在，因为静态域可以更方便的访问，直接使用类名.静态域就可以轻松的访问，而忽略该类所有对象共用这一个域导致初始化出现遗漏。第一次是在图表类ChartService中将通道数设置为了静态变量，因为纵向梯度曲线比原始数据曲线数量少1，而导致原始数据数据集与数据渲染器初始化少了1，无法显示完整的曲线。第二次在读数据线程中，将暂停的flag设置为了静态变量，导致后面继续测量无法获取到数据，而调试了好久。 静态常量（使用比静态变量多）比如Math类中定义到： 12345public class Math&#123; ... public static final double PI = 3.14159265358979323846; ...&#125; 然后就可以通过Math.PI的形式访问。另外我们输出经常会用到System.out，它其实也是一个静态常量 1public static final PrintStream out = ...; 但是Syetem类中却有一个setOut的方法，并且可以将System.out设置为不同的流。原因是setOut是一个本地方法，而不是通过java语言实现，本地方法可以绕过java语言的存取控制机制。 静态方法静态方法是一种不能向对象实施操作的方法。Math.pow(x,a)计算x的a次方。静态方法是没有this参数的方法。静态方法不能访问实例域（静态方法不能操作对象），只能访问自身类中的静态域。 4.静态代码块 123static &#123; ...&#125; 静态代码块在类中独立于类成员，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。执行顺序先于构造函数。]]></content>
      <categories>
        <category>安卓学习</category>
      </categories>
      <tags>
        <tag>安卓</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A New Begining]]></title>
    <url>%2F2017%2F09%2F23%2FA-New-Begining%2F</url>
    <content type="text"><![CDATA[许久没有更新博客了… 开学已经好久，上一次更新还是两个月前，都说坚持一件事情很难，果不其然。总是找各种理由（借口）不想写。大三学期已经开始三周了，除了上课感觉自己还是不知道该做些什么，浑浑噩噩，想学点东西，做点东西，却又不知道从何开始。不想考研，可是自己的能力却又远远不够。想学的东西很多，还是得静下心来，好好完成一件事。一步一个脚印。 坚持一个有规划的大学生活 学好java，从项目中多学习经验与技巧 感觉设计模式是一门很有用的课，对以后项目开发都很有用，学好设计模式 坚持早起，有时间就去去图书馆、实验室。 计算机网络还挺有意思，老师讲的还挺好 上课得提高效率，平时多做做感兴趣的事情 想学算法，期待和大神一样的厉害 想接触人工智能，机器学习，等等。。。 总之，好多好多…… 突然想起一句话，想的太多，做的太少。好像用来描述此时的我，太合适不过了。还不如选定一个小小的方向，努力去做好一件事情，坚持下去。我想收获会更多，你是否也这样觉得？]]></content>
      <categories>
        <category>每日一记</category>
      </categories>
      <tags>
        <tag>心情</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DatePicker与TimePicker的使用]]></title>
    <url>%2F2017%2F07%2F20%2FDatePicker%E4%B8%8ETimePicker%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[安卓系统DatePicker与TimePicker的妙用 其实安卓系统自带的DatePicker和TimePicker的界面都已经很好看啦~可以直接拿过来直接用，当然也可以自定义。 它们可以直接以界面的形式显示，也可以用new DatePickerDialog()的方法以弹框的形式显示，使用特别方便。不信？你看~ main.xml:定义一个需要用到的Datepicker和TimePicker，首先然后先设置visibility为gone，我想通过按钮来实现它们的显示效果，而不会两个同时显示时，无法完全显示在界面上。12345678910111213&lt;DatePicker android:id=&quot;@+id/datePicker&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;0dp&quot; android:visibility=&quot;gone&quot; android:layout_weight=&quot;1&quot; /&gt; &lt;TimePicker android:id=&quot;@+id/timePicker&quot; android:layout_width=&quot;match_parent&quot; android:visibility=&quot;gone&quot; android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;1&quot; /&gt; MainActivity.java类：添加四个按钮，分别实现不同的点击事件（事件的监听，三种方法：1.匿名内部类 2.在MainActivity类中实现 View.OnClickListener接口，3.自定义监听类，实现接口），完成TimePicker、DatePicker以及它们的弹框形式的分别显示。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143package com.example.datetimepicker;import android.app.DatePickerDialog;import android.app.TimePickerDialog;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.DatePicker;import android.widget.TimePicker;import java.util.Calendar;public class MainActivity extends AppCompatActivity implements View.OnClickListener&#123; private TimePicker timePicker; private DatePicker datePicker; private Calendar calendar; private int year; private int month; private int day; private int hour; private int minute; private Button timeBtn; private Button dateBtn; private Button timeBtnDia; private Button dateBtnDia; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); timeBtn= (Button) findViewById(R.id.timePickerBtn); dateBtn= (Button) findViewById(R.id.datePickerBtn); timeBtnDia= (Button) findViewById(R.id.timePickerDia); dateBtnDia= (Button) findViewById(R.id.datePickerDia); //获取日历对象 calendar=Calendar.getInstance(); //获取年月日时分秒的信息 year=calendar.get(Calendar.YEAR); month=calendar.get(Calendar.MONTH)+1; //Calendar.MONTH获取的月份从0开始 day=calendar.get(Calendar.DAY_OF_MONTH); hour=calendar.get(Calendar.HOUR_OF_DAY); minute=calendar.get(Calendar.MINUTE); setTitle(year+&quot;-&quot;+month+&quot;-&quot;+day+&quot; &quot;+hour+&quot;:&quot;+minute); datePicker= (DatePicker) findViewById(R.id.datePicker); timePicker= (TimePicker) findViewById(R.id.timePicker); //datePicker的初始化日期Picker的年月日初始值 datePicker.init(year, month-1, day, new DatePicker.OnDateChangedListener() &#123; @Override public void onDateChanged(DatePicker datePicker, int i, int i1, int i2) &#123; setTitle(i+&quot;-&quot;+(i1+1)+&quot;-&quot;+i2); &#125; &#125;); timePicker.setOnTimeChangedListener(new TimePicker.OnTimeChangedListener() &#123; @Override public void onTimeChanged(TimePicker timePicker, int i, int i1) &#123; setTitle(i+&quot;:&quot;+i1); &#125; &#125;); //添加监听，在MainActivity中，直接添加this timeBtn.setOnClickListener(this); timeBtnDia.setOnClickListener(this); dateBtn.setOnClickListener(this); dateBtnDia.setOnClickListener(this); //使用匿名内部类的方法实现监听 //initEvent(); &#125; public void showDatePickerDialog()&#123; new DatePickerDialog(this, new DatePickerDialog.OnDateSetListener() &#123; @Override public void onDateSet(DatePicker datePicker, int i, int i1, int i2) &#123; setTitle(i+&quot;-&quot;+(i1+1)+&quot;-&quot;+i2); &#125; &#125;,year,month-1,day).show(); &#125; public void showTimePickerDialog()&#123; new TimePickerDialog(this, new TimePickerDialog.OnTimeSetListener() &#123; @Override public void onTimeSet(TimePicker timePicker, int i, int i1) &#123; setTitle(i+&quot;:&quot;+i1); &#125; &#125;,hour,minute,true).show(); &#125; @Override public void onClick(View view) &#123; switch (view.getId())&#123; case R.id.datePickerBtn: datePicker.setVisibility(View.VISIBLE); timePicker.setVisibility(View.GONE); break; case R.id.timePickerBtn: datePicker.setVisibility(View.GONE); timePicker.setVisibility(View.VISIBLE); break; case R.id.timePickerDia: showTimePickerDialog(); break; case R.id.datePickerDia: showDatePickerDialog(); break; &#125; &#125; public void initEvent()&#123; dateBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; datePicker.setVisibility(View.VISIBLE); timePicker.setVisibility(View.GONE); &#125; &#125;); timeBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; datePicker.setVisibility(View.GONE); timePicker.setVisibility(View.VISIBLE); &#125; &#125;); dateBtnDia.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; showDatePickerDialog(); &#125; &#125;); timeBtnDia.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; showTimePickerDialog(); &#125; &#125;); &#125;&#125; 注意事项： 最后的显示效果：]]></content>
      <categories>
        <category>安卓学习</category>
      </categories>
      <tags>
        <tag>andriod</tag>
        <tag>安卓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndriodManifest.xml配置]]></title>
    <url>%2F2017%2F07%2F19%2FAndriodManifest-xml%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[AndriodManifest的配置基础1.全局篇应用的包名以及版本信息，控制安卓的版本信息。 2.组件篇（四大组件） Activity(活动) ：启动一个没有在清单中定义的Activity会抛出异常 Service(服务) ：做为后台运行的一个逻辑代码的处理 Content Provider(内容提供者) ：是用来管理数据库访问以及程序内和程序间共享的 Broadcast Receiver(广播接收者) 其属性可以设置：图标：android:icon标题：android:label主题样式：android:theme注意：只能包含一个application节点 3.权限篇 申请系统权限自定义权限，限制其它应用使用该应用的效果。123456789&lt;permission andriod:name=&quot;com.example.test&quot; andriod:protectionLevel=&quot;normal&quot;&gt;&lt;/permission&gt;&lt;activity andriod:permission=&quot;com.example.test&quot; .... &gt; 然后在其他应用中若希望调用该应用则必须声明权限：1&lt;uses-permission andriod:name=&quot;com.example.test&quot;&gt; ListView的使用数据适配器：纯文字使用ArrayAdapter,有图片有文字又复杂的一系列内容的用SimpleAdapter.1.ArrayAdapter(context, 当前listview加载的每一个列表项所对应的布局文件，数据源)2.SimpleAdapter( context, data , resource , from ,to )：context：上下文data：数据源（List&lt;? extends Map&lt;String,?&gt;&gt; data）一个由Map组成的List合集 每一个Map都对应ListView列表中的一行 每一个Map（键-值对）中的键都必须包含所有在from中所指定的键resource：列表项的布局文件IDfrom：Map中的键名to：绑定数据视图中的ID，与from成对应关系。监听器：]]></content>
      <categories>
        <category>安卓学习</category>
      </categories>
      <tags>
        <tag>andriod</tag>
        <tag>安卓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓自定义控件]]></title>
    <url>%2F2017%2F07%2F17%2F%E5%AE%89%E5%8D%93%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[自定义UI组件 许久没有更新自己的博客了，感觉这些天，并没有做什么额。想想接下来这些时间还是多学习学习安卓的基础，多花时间尝试做一些小Demo。 昨天，跟着网易云课堂自己做了一个自定义UI控件的小例子，分为以下三个步骤： 1.设计需要的属性： 新建一个attrs.xml文件声明以下内容 12345678910111213141516171819202122232425262728 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;declare-styleable name=&quot;Topbar&quot;&gt; &lt;!--自定义属性--&gt; &lt;!--中间的标题--&gt; &lt;attr name=&quot;title&quot; format=&quot;string&quot; /&gt; &lt;attr name=&quot;titleTextSize&quot; format=&quot;dimension&quot; /&gt; &lt;attr name=&quot;titleTextColor&quot; format=&quot;color&quot; /&gt; &lt;!--左边的按钮--&gt; &lt;attr name=&quot;leftTextColor&quot; format=&quot;color&quot;/&gt; &lt;attr name=&quot;leftTextSize&quot; format=&quot;dimension&quot;/&gt; &lt;attr name=&quot;leftText&quot; format=&quot;string&quot;/&gt; &lt;attr name=&quot;leftBackground&quot; format=&quot;color|reference&quot;/&gt; &lt;!--右边的按钮--&gt; &lt;attr name=&quot;rightTextColor&quot; format=&quot;color&quot;/&gt; &lt;attr name=&quot;rightTextSize&quot; format=&quot;dimension&quot;/&gt; &lt;attr name=&quot;rightText&quot; format=&quot;string&quot;/&gt; &lt;attr name=&quot;rightBackground&quot; format=&quot;color|reference&quot;/&gt; &lt;/declare-styleable&gt; &lt;!--&quot;reference&quot; //引用--&gt; &lt;!--&quot;color&quot; //颜色--&gt; &lt;!--&quot;boolean&quot; //布尔值--&gt; &lt;!--&quot;dimension&quot; //尺寸值--&gt; &lt;!--&quot;float&quot; //浮点值--&gt; &lt;!--&quot;integer&quot; //整型值--&gt; &lt;!--&quot;string&quot; //字符串--&gt; &lt;!--&quot;fraction&quot; //百分数,比如20%--&gt;&lt;/resources&gt; 2.实现一个我们的自定义View 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136package com.example.topbardemo;import android.content.Context;import android.content.res.TypedArray;import android.graphics.Color;import android.graphics.drawable.Drawable;import android.support.annotation.Dimension;import android.util.AttributeSet;import android.view.View;import android.view.ViewGroup;import android.widget.Button;import android.widget.RelativeLayout;import android.widget.TextView;public class Topbar extends RelativeLayout&#123; //自定义控件中的组件 private Button leftButton,rightButton; private TextView tvTitle; //各组件的属性 private String title; private float titleTextSize; private int titleTextColor; private int leftButtonColor; private String leftText; private Drawable leftBack; private float leftTextSize; private int rightButtonColor; private String rightText; private Drawable rightBack; private float rightTextSize; private LayoutParams leftParam,rightParam,titleParam; private topbarClickListener listener; public interface topbarClickListener&#123; void leftClick(); void rightClick(); &#125; //接口回调机制，实现组件的事件 public void setTopbarClickListener(topbarClickListener listener)&#123; this.listener=listener; &#125; public Topbar(Context context, AttributeSet attrs) &#123; super(context, attrs); //引用自定义的属性name TypedArray typedArray = context.obtainStyledAttributes(attrs,R.styleable.Topbar); //获取到自定义的各个属性 title=typedArray.getString(R.styleable.Topbar_title); titleTextColor=typedArray.getColor(R.styleable.Topbar_titleTextColor,0); titleTextSize=typedArray.getDimension(R.styleable.Topbar_titleTextSize,1); leftText = typedArray.getString(R.styleable.Topbar_leftText); leftButtonColor = typedArray.getColor(R.styleable.Topbar_leftTextColor,0); leftTextSize = typedArray.getDimension(R.styleable.Topbar_leftTextSize,1); leftBack = typedArray.getDrawable(R.styleable.Topbar_leftBackground); rightText = typedArray.getString(R.styleable.Topbar_rightText); rightButtonColor = typedArray.getColor(R.styleable.Topbar_rightTextColor,0); rightTextSize = typedArray.getDimension(R.styleable.Topbar_rightTextSize,1); rightBack = typedArray.getDrawable(R.styleable.Topbar_rightBackground); //调用结束后务必调用recycle()方法，否则这次的设定会对下次的使用造成影响 typedArray.recycle(); //定义各个组件 leftButton= new Button(context); rightButton = new Button(context); tvTitle =new TextView(context); //为组件添加属性 leftButton.setText(leftText); leftButton.setTextColor(leftButtonColor); leftButton.setTextSize(leftTextSize); leftButton.setBackground(leftBack); rightButton.setText(rightText); rightButton.setTextColor(rightButtonColor); rightButton.setTextSize(rightTextSize); rightButton.setBackground(rightBack); tvTitle.setText(title); tvTitle.setTextColor(titleTextColor); tvTitle.setTextSize(titleTextSize); setBackgroundColor(0xFFF1233); //布局参数样式 leftParam = new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,LayoutParams.WRAP_CONTENT); leftParam.addRule(RelativeLayout.ALIGN_PARENT_LEFT,TRUE); //组件以leftParam样式添加到View中 addView(leftButton,leftParam); rightParam = new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,LayoutParams.WRAP_CONTENT); rightParam.addRule(RelativeLayout.ALIGN_PARENT_RIGHT,TRUE); addView(rightButton,rightParam); titleParam = new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,LayoutParams.WRAP_CONTENT); titleParam.addRule(RelativeLayout.CENTER_IN_PARENT,TRUE); addView(tvTitle,titleParam); //组件的点击事件 leftButton.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View view) &#123; listener.leftClick(); &#125; &#125;); rightButton.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View view) &#123; listener.rightClick(); &#125; &#125;); &#125; //其他事件的完善 public void setLeftButtonVisable(boolean flag)&#123; if (flag)&#123; leftButton.setVisibility(VISIBLE); &#125;else &#123; leftButton.setVisibility(GONE); &#125; &#125;&#125; 3.引用我们的View 在activity_main.xml中引入xmlns:custom=&quot;http://schemas.android.com/apk/res-auto&quot;声明引用的组件并设置属性值 123456789101112131415&lt;com.example.topbardemo.Topbar android:id=&quot;@+id/topbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;50dp&quot; custom:leftText=&quot;Left&quot; custom:leftTextColor=&quot;@color/colorPrimaryDark&quot; custom:leftTextSize=&quot;8sp&quot; custom:rightText=&quot;Right&quot; custom:rightTextColor=&quot;@color/colorPrimaryDark&quot; custom:rightTextSize=&quot;8sp&quot; custom:title=&quot;自定义标题&quot; custom:titleTextColor=&quot;@color/colorAccent&quot; custom:titleTextSize=&quot;10sp&quot; &gt; &lt;/com.example.topbardemo.Topbar&gt; 在Activity中定义各个组件的事件。1234567891011121314151617181920topbar= (Topbar) findViewById(R.id.topbar); topbar.setTopbarClickListener(new Topbar.topbarClickListener() &#123; @Override public void leftClick() &#123; Toast.makeText(getApplicationContext(),&quot;Left&quot;,Toast.LENGTH_SHORT).show(); &#125; @Override public void rightClick() &#123; Toast.makeText(getApplicationContext(),&quot;Right&quot;,Toast.LENGTH_SHORT).show(); &#125; &#125;); button = (Button) findViewById(R.id.button1); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; topbar.setLeftButtonVisable(false); &#125; &#125;); 最后的完成的效果：]]></content>
      <categories>
        <category>安卓学习</category>
      </categories>
      <tags>
        <tag>安卓</tag>
        <tag>自定义控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓学习之2048]]></title>
    <url>%2F2017%2F07%2F07%2F%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0%E4%B9%8B2048%2F</url>
    <content type="text"><![CDATA[一个叫做2048的小游戏 许久未更新我的博客了，只是因为，这几天觉得并没有什么好写的，好记录下来的。有时候只是学习到编码中的一点点小技巧，大多也是自己通过在网上学习，自己敲代码所总结出来的。可能是自己做的不多吧。 这两天重新把自己开始接触安卓时想做的一个小游戏继续完善了一下，两个月之后回头再看看自己当时的代码，还是学的有许多许多需要去改进的地方，这也说明我还是不断的在学习^ - ^。 以前直接将每一种方块看成图片，然后自己做2~2048的图片，以图片的形式填充到每一个ImageView中，现在则是以TextView形式，动态设置每一方块的数字以及背景色。这样使得游戏占得空间小多啦，这也是网上所推荐的方法。 12345678910111213141516171819202122232425262728private LinearLayout layout; private Button mainMenu; private Button btnReset; private Button btnUp; private TextView textScore; private TextView textBestScore; private int[][] oldFlag = new int[4][4]; private static int score = 0; private static int best_score=0; //触摸事件手指按下和松开的两个坐标 private float x1 = 0; private float x2 = 0; private float y1 = 0; private float y2 = 0; //16个方块的id static int[][] btnBlock = &#123; &#123;R.id.btn00, R.id.btn01, R.id.btn02, R.id.btn03&#125;, &#123;R.id.btn10, R.id.btn11, R.id.btn12, R.id.btn13&#125;, &#123;R.id.btn20, R.id.btn21, R.id.btn22, R.id.btn23&#125;, &#123;R.id.btn30, R.id.btn31, R.id.btn32, R.id.btn33&#125; &#125;; //16个方块的对应的值 static int[][] flag = &#123; &#123;0, 0, 0, 0&#125;, &#123;0, 0, 0, 0&#125;, &#123;0, 0, 0, 0&#125;, &#123;0, 0, 0, 0&#125; &#125;; 以二维数组的形式存储每一个方块对应的值，然后根据方块中的值，来动态绘制每一个方块的数字以及背景色。123456789101112131415161718192021222324252627282930//手势滑动 @TargetApi(Build.VERSION_CODES.M) @Override public boolean onTouch(View v, MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: x1 = event.getX(); y1 = event.getY(); break; case MotionEvent.ACTION_MOVE: x2 = event.getX(); y2 = event.getY(); break; case MotionEvent.ACTION_UP: if (x2 - x1 &gt; 50 &amp;&amp; Math.abs(x2 - x1) &gt; Math.abs(y2 - y1)) &#123;// Toast.makeText(this,&quot;向右滑动&quot;,Toast.LENGTH_SHORT).show(); moveToRight(); &#125; else if (x1 - x2 &gt; 50 &amp;&amp; Math.abs(x2 - x1) &gt; Math.abs(y2 - y1)) &#123;// Toast.makeText(this,&quot;向左滑动&quot;,Toast.LENGTH_SHORT).show(); moveToLeft(); &#125; else if (y2 - y1 &gt; 50 &amp;&amp; Math.abs(x2 - x1) &lt; Math.abs(y2 - y1)) &#123;// Toast.makeText(this,&quot;向下滑动&quot;,Toast.LENGTH_SHORT).show(); moveToBottom(); &#125; else if (y1 - y2 &gt; 50 &amp;&amp; Math.abs(x2 - x1) &lt; Math.abs(y2 - y1)) &#123;// Toast.makeText(this,&quot;向上滑动&quot;,Toast.LENGTH_SHORT).show(); moveToUp(); &#125; &#125; return true; &#125; 重写触摸事件，按下的时候记录当前的坐标，手指滑动时记录手指所在坐标。滑动结束时（也就是手指放开时），计算坐标之间的变化来判断手势的滑动方向以进行方块的滑动。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//向右滑动 public void moveToRight() &#123; for (int i = 0; i &lt; 16; i++) &#123; oldFlag[i / 4][i % 4] = flag[i / 4][i % 4]; &#125; for (int j = 0; j &lt; 4; j++) &#123; ArrayList&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 4; i++) &#123; if (flag[j][3 - i] != 0) &#123; list1.add(flag[j][3 - i]); &#125; &#125; ArrayList&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); int i = 0; for (i = 0; i &lt; list1.size() - 1; i++) &#123; if (list1.get(i) == 2048)&#123; &#125;else if (list1.get(i) == list1.get(i + 1)) &#123; temp.add(list1.get(i) * 2); score += list1.get(i) * 2; i++; &#125; else &#123; temp.add(list1.get(i)); &#125; &#125; if (i == list1.size() - 1) &#123; temp.add(list1.get(i)); &#125; if (list1.size() &gt; 1) &#123; list1 = temp; &#125; for (i = 0; i &lt; list1.size(); i++) &#123; flag[j][3 - i] = list1.get(i); fillBlock(list1.get(i), j, 3 - i); &#125; for (i = list1.size(); i &lt; 4; i++) &#123; flag[j][3 - i] = 0; fillBlock(0, j, 3 - i); &#125; &#125; //判断是否变化 boolean isNext = false; for (int i = 0; i &lt; 16; i++) &#123; if (oldFlag[i / 4][i % 4] != flag[i / 4][i % 4]) &#123; isNext = true; break; &#125; &#125; if (isNext) &#123; nextBlock(); &#125; else if (isGameOver()) &#123; Toast.makeText(MainActivity.this, &quot;GAME OVER&quot;, Toast.LENGTH_SHORT); reset(); //重新开始 &#125; &#125; 首先记录滑动之前的二维数组（1.判断此次滑动时候有方块变化，2.便于返回上一步），然后根据手势滑动所得的方向，将方块中的值依次添加到四个List，接下来遍历一遍，如果当前list.get(i)与list.get(i+1)相等，则两个数据合并，保存到一个temp的List中。最后将temp中的值一次填到二维数组的对应位置中去。 最后将方块显示出来，通过设置每一个方块的数字以及背景色。（这里还是差一个动画的效果，就更完美了！） 还有最高的记录，是用的安卓的SharedPreferences存储，以XML标签的形式将数据保存与本地手机上。每次打开游戏的时候，初始化界面的时候从score_data.xml文件中读取到对应的最高分。 12345678//保存数据 public void saveBest_score(Score score)&#123; SharedPreferences.Editor editor =getApplicationContext().getSharedPreferences(&quot;score_data&quot;, Context.MODE_PRIVATE).edit(); editor.putString(&quot;name&quot;,score.getName()); editor.putInt(&quot;score&quot;,score.getScore()); editor.putString(&quot;time&quot;,score.getTime()); editor.commit(); &#125; 我的2048游戏源码]]></content>
      <categories>
        <category>安卓学习</category>
      </categories>
      <tags>
        <tag>andriod</tag>
        <tag>安卓</tag>
        <tag>2048</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JNI（java 本地接口）开发]]></title>
    <url>%2F2017%2F07%2F02%2FJNI%EF%BC%88java-%E6%9C%AC%E5%9C%B0%E6%8E%A5%E5%8F%A3%EF%BC%89%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[JNI开发之NDK环境搭建 首先得先说说JNI是什么，Java Native Interface(java本地接口)的缩写，主要是实现Java与其他语言的通信（主要是C，C++）。当实际项目中一些接口并不支持java安卓的时候，就得靠自己进行封装，来达到目的。缺点是java与本地以编译好的代码交互，可能会丧失平台可移植性，另外程序安全性降低使用不当可能是整个程序崩溃，使用时尽量降低语言之间的耦合性。开发JNI项目前提是需要有NDK（Native Development Kit）的支持。因此，在开发前需要先安装和配置NDK。推荐一个NDK安装教程 对于windows系统依然适用。 1.项目配置文件gradle.properties中添加 1android.useDeprecatedNdk=true 2.local.properties文件添加：（如果是在AS-&gt;SDK Manager-&gt;Appearance&amp;Behavior-&gt;System Settings-&gt;Andriod SDK-&gt;SDK Tools安装，会自动配置） ndk.dir=NDK的路径3.打开模块的build.gradle文件，在android/defaultConfig下面添加ndk节点，如下所示：12345ndk &#123; moduleName &quot;JNIDemo&quot; stl &quot;stlport_static&quot; ldLibs &quot;log&quot; &#125; 4.创建JNIUtil类，声明本地方法。编译后在Terminal终端面板中定位到cd app/build/intermediates/classes/debug/ 执行javah 包名.JNIUtil（JNIUtil是刚刚定义的类名）执行成功之后会在刚刚的debug目录下生成一个.h的头文件（文件名为:Java.类名.包名.h(‘.’换成’_‘)）。5.在app目录下新建JNI目录，拷贝第四步生成的.h文件，再创建一个.cpp文件实现头文件中的方法。6.ok~ 编译运行。完美~]]></content>
      <categories>
        <category>安卓学习</category>
      </categories>
      <tags>
        <tag>安卓</tag>
        <tag>NDK</tag>
        <tag>JNI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[又见周末...]]></title>
    <url>%2F2017%2F07%2F02%2F%E5%8F%88%E8%A7%81%E5%91%A8%E6%9C%AB%2F</url>
    <content type="text"><![CDATA[一周过去了… 回想起这周做的事情，感觉并不是很满意。差不多也花了两天时间，各种找如何用github+hexo搭建博客，一步一步尝试，最后达到了现在的效果，感觉还是挺不错的效果。很喜欢这个网页！希望自己可以坚持做好这件事情，尽量把每天每周做的事情都写下来，一是总结自己所做的事情，规划自己的时间，二是也可以记录一些学习中遇到的问题，解决技巧等等。 下一周，多看看安卓的基础，感觉很多事还是得从基础做起。另外学习学习JNI（java 本地接口）的开发。 下图为如何上传本地项目到github的步骤： 这个评论好尴尬呀，发个链接就提示请文明发言。我也是很无奈。就只好加在这里。Github上传项目步骤及常见问题的分享]]></content>
      <categories>
        <category>每日一记</category>
      </categories>
      <tags>
        <tag>心情</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[磁感应力检测Bug修复]]></title>
    <url>%2F2017%2F06%2F30%2F%E7%A3%81%E6%84%9F%E5%BA%94%E5%8A%9B%E6%A3%80%E6%B5%8BBug%E4%BF%AE%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[又是忙碌的一天…&nbsp;&nbsp;&nbsp;&nbsp;又是一天过去，昨天的生成报告的插图始终还是没有头绪，一直停留在原地。&nbsp;&nbsp;&nbsp;&nbsp;今天测试的时候发现原来做的通道选择的弹框和地磁场校准的位置有两个小小的bug，通道选择，点击全部通道之后，再点击其它的通道，取消该通道时，全部通道的选择并没取消。在点击每个通道时，如果该通道已被选则判断全部通道是否被选，若被选则取消全部通道的选择。 修改后的效果： (function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","loop":true,"video":{"url":"http://hexoblog-1253306922.cosgz.myqcloud.com/video2017/%E9%80%9A%E9%81%93%E9%80%89%E6%8B%A9.mp4"},"danmaku":{"id":"9E2E3368B56CDBB4","api":"http://dplayer.daoapp.io","token":"tokendemo"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() &nbsp;&nbsp;&nbsp;&nbsp;另外通道校准画图时，ChartService是以系统参数的通道数初始化的，导致校准非全部通道时，未被选择的通道也绘制了折线。 &nbsp;&nbsp;&nbsp;&nbsp;项目差不多接近尾声了，但是实际调试的过程中，依然会遇到许多许多的Bug，而这些是你在开始设计时、编码时未注意到的小细节。事情往往都是看起来挺简单，但是想要做好，可并不容易哦~ &nbsp;&nbsp;&nbsp;&nbsp;暑假这两个月，得好好规划一下自己的时间。 学好安卓，看看web。另外算法的能力也得提高，学会如何把代码写的优雅~]]></content>
      <categories>
        <category>安卓学习</category>
      </categories>
      <tags>
        <tag>安卓</tag>
        <tag>Andriod</tag>
        <tag>磁感应力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我想吐个槽~]]></title>
    <url>%2F2017%2F06%2F29%2F%E6%88%91%E6%83%B3%E5%90%90%E4%B8%AA%E6%A7%BD%2F</url>
    <content type="text"><![CDATA[贴图贴图你真烦~&nbsp;&nbsp;&nbsp;&nbsp;短学期已经开始了好几天，我的任务就是继续完成实验室的安卓磁感应力检测仪的功能完善，实验室大佬去实习了，留下我跟刘昊东两个人并肩作战，先是画图过程比较卡，特别是后退的时候，很是难理解，后来修改了主线程的数据添加过程，将数据添加放在数据处理的线程中，然后通过Handler消息机制通知UI线程重绘。 因为安卓改变UI必须放在主线程中，主线程也被称之为UI线程，所以无法做到多线程绘制界面的效果。另外后退过程避免了多余数据的传递与处理，使得最后过程更加流畅。 &nbsp;&nbsp;&nbsp;&nbsp;另外修复了一个bug，安卓6.0及以上系统版本，对软件权限的管理更加严格，分为普通权限和危险权限，危险权限在软件安装时并不会获取权限，只能在使用过程中动态获取权限，因为生成报告中必须使用存储权限（危险权限），如果没有权限，会导致文件生成失败，显示无效的问价，所以得增加一个动态权限申请的功能，体现用户的交互性。 &nbsp;&nbsp;&nbsp;&nbsp;最后就是一个最难的问题，word文档中插入图片，找了许多资料，安卓上并没有很好的解决方案，Apache POI主要是对Excel操作，对word的操作显得有点尴尬，只想吐槽网上的博客方法都似乎是一个人写的，都一样…很是无奈， 今天想到了一个点子，可是可行性并不是很好，实现起来也并不简单，将doc转成xml文件 然后进行操作，添加图片，最后改成doc的格式，网上也看见过这样的想法，帖子下面还想并没想法，就很尴尬。1234567891011121314151617181920212223242526272829303132public byte[] bitmap2Byte(Bitmap bm) &#123; Bitmap outBitmap = Bitmap.createScaledBitmap(bm, 150, bm.getHeight() * 150 / bm.getWidth(), true); if (bm != outBitmap) &#123; bm.recycle(); bm = null; &#125; byte[] compressData = null; ByteArrayOutputStream baos = new ByteArrayOutputStream(); try &#123; try &#123; outBitmap.compress(Bitmap.CompressFormat.PNG, 100, baos); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; compressData = baos.toByteArray(); baos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return compressData; &#125; public String getBase64(byte[] image) &#123; String string = &quot;&quot;; try &#123; BASE64Encoder encoder = new BASE64Encoder(); string = encoder.encodeBuffer(image).trim(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return string; &#125; 这是将图片（Bitmap格式）转成二进制数组再转成Base64编码，而这种编码正好是xml文件中图片的编码方式，在电脑上试着用暴力更改文件后缀的方式测试，还真行的通，想法归想法， 实现起来 似乎也并不简单… 哎~ 心累~ 睡觉~ 明天继续………]]></content>
      <categories>
        <category>每日一记</category>
      </categories>
      <tags>
        <tag>安卓</tag>
        <tag>心情</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客完善]]></title>
    <url>%2F2017%2F06%2F28%2FHexo%E5%8D%9A%E5%AE%A2%E5%AE%8C%E5%96%84%2F</url>
    <content type="text"><![CDATA[你的Blog得优化~&nbsp;&nbsp;&nbsp;&nbsp;至此，我的博客已经建成，但是总觉得不够完美，还差一点，于是今天花了半天的时间在博客的优化上面，遇到了很多问题，自己一个一个去百度，按照其他博客的步骤来做，当然无法避免有些博客写的并不是很好，有些问题并没有很好的解决。&nbsp;&nbsp;&nbsp;&nbsp;今天下午主要完成了三件事： 博客分类的完善，添加了博客分类，博客标签以及关于我。目的是为了后期更好的管理这些博客，对了还有搜索的功能，可以检索博客中的关键字词。在博客目录下右键Git Bash执行命令:$ hexo new pages tags,在对应blog/source/下新建tags文件夹，用于标签的显示界面，此时你可能会问，为什么不自己直接建一个文件夹呀？ 当然你也可以自己建，只不过用命令的方式会默认在tags文件夹下建立一个index.md文件，改一个自己喜欢的title，并添加一行 type: &quot;tags&quot;即可。如下图所示： &nbsp;&nbsp;&nbsp;&nbsp;博客分类亦是如此，对应类型为type: &quot;cateagories&quot;。关于我并没有添加类型。&nbsp;&nbsp;&nbsp;&nbsp;站点内容搜索功能： 安装hexo-generator-searchdb对应博客目录下git bash执行：$ npm install hexo-generator-searchdb --save站点配置文件_config.yml中添加search字段，如下： 12345search: path: search.xml field: post format: html limit: 10000 第二是添加评论的功能：注册一个友言账号，友言官网，注册成功后进入后台管理获取uid，然后在站点配置文件_config.yml中找到youyan_uid:，附上刚刚的uid，最后部署一下网页即可。 最后就是添加站点阅读量，这个也是我最花时间的一件事情，开始尝试了百度统计，代码也安装成功，只不过访问数据得在百度统计上查看，需求是想在自己的网页footer位置添加一条网页阅读量的消息。尝试了好久，并没有找到好的方法。这里附上一个推荐的教程，对于hexo博客的创建有详细的步骤~ 不说了，我也去加一个打赏的功能~]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何上传文章]]></title>
    <url>%2F2017%2F06%2F27%2F%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[文章怎么上传了？&nbsp;&nbsp;&nbsp;&nbsp;有了博客网页，首先第一步得熟悉如何上传文章，熟悉hexo的基本操作。一般分为三个步骤： （1）第一步新建文章文件，在Git Bash执行命令：$ hexo new &quot;my new post&quot;，然后电脑对应 \bolg\source\_post 中打开my-new-post.md，打开方式可以使用记事本或notepad++。使用Markdown语法进行编辑文章。【当然也可以直接在目录下面新建一个my-new-post.md文件】 （2）Git Bash执行命令：$ hexo g生成静态文件。 （3）Git Bash执行命令：$ hexo d部署到github。稍后就可以在自己的网站上看到自己的文章【第2.3步可以直接执行命令 $ hexo d -g即可完成生成文件并部署到github】 另外可以在Git Bash执行命令：$ hexo s可以本地localhost:4000查看预览效果！ 清除缓存文件db.json和已生成的静态文件public。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令$ hexo clean。]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇文章]]></title>
    <url>%2F2017%2F06%2F27%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[GitHub+hexo搭建我的博客&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先了，先讲讲为什么搭建这个博客，去年暑假的时候，因为邹萌学姐的一个个人网站，让我有了做一个属于自己的网站，可以贴一贴自己的博客，自己学习的心得，还是蛮有趣的一件事情！ &nbsp;&nbsp;&nbsp;&nbsp;因为自己原来实验室学过一点点java和javaweb的知识，但是觉得自己真的并没有学到一些什么实在的东西。缺乏自己实践的能力，寒假有想过做一个网页，看了一些jsp的后台开发技术，也可以连接数据库，做个用户登录与注册的界面，后来来到学校之后，突然发现自己的时间也并不多，就一直留了下来。后来退了原来的实验室，来到了现在的107，学长学姐们都还是特别好，很热心，就像一家人一样，经常也会参加一些活动,丰富我们在实验室学习的经历~~&nbsp;&nbsp;&nbsp;&nbsp;前几天，因为看了实验室刘昊东的个人网页，觉得挺炫的，虽然实质上是一个静态的网页，不过也是挺好的学习机会。自己尝试着百度，自己搭建环境，第一天晚上，用github建了一个网站，以为就是这样的了… 后来总觉得自己界面未免也太丑了，人家的咋那么炫了，然后才有了hexo，又花了一个下午的时间自己去尝试用hexo在github上搭建自己的博客，最后在本地localhost:4000上看到了效果，始终没能部署到github上。昨天下午问了问刘昊东，两个人误打误撞，最后部署到了github上。也就是现在的这个样子~]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04LTS安装及配置Hadoop]]></title>
    <url>%2F2017%2F04%2F27%2FUbuntu16-04%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AEHadoop%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前言 这学期有一门云计算的课程，有接触到Hadoop，后来需要完成Hadoop的安装及配置，折腾了好久，决定以此记录下来。以供学习！课本附录简单介绍了在Windows上的安装及配置过程，但是推荐在Linux系统下完成，正好对Linux系统及一些命令比较感兴趣，趁着这个机会正好学习一波。以此记录之！ Hadoop简介此处引用百度百科： Hadoop是一个由Apache基金会所开发的分布式系统基础架构。用户可以在不了解分布式底层细节的情况下，开发分布式程序。充分利用集群的威力进行高速运算和存储。 Hadoop实现了一个分布式文件系统（Hadoop Distributed File System），简称HDFS。HDFS有高容错性的特点，并且设计用来部署在低廉的（low-cost）硬件上；而且它提供高吞吐量（high throughput）来访问应用程序的数据，适合那些有着超大数据集（large data set）的应用程序。HDFS放宽了（relax）POSIX的要求，可以以流的形式访问（streaming access）文件系统中的数据。 Hadoop的框架最核心的设计就是：HDFS和MapReduce。HDFS为海量的数据提供了存储，则MapReduce为海量的数据提供了计算。 Hadoop在Ubuntu上的安装与配置安装环境及版本说明Ubuntu 16.04LTS 64位操作系统 Hadoop版本：2.7.3 [下载地址](https://archive.apache.org/dist/hadoop/core/hadoop-2.7.3/) Jdk版本：1.8.0 MyEclipse版本：MyEclipse2017 CI 10 安装路径信息hadoop安装路径：/usr/local/hadoop/hadoop-2.7.3 jdk路径：/usr/lib/jvm/java-8-oracle MyEclipse路径：/opt/MyEclipse 2017 一、Java 环境安装此处引用我朋友的CSDN上一篇关于java web环境配置的博客 添加ppa 12sudo add-apt-repository ppa:webupd8team/javasudo apt-get update 安装oracle-java-installerJDK8：sudo apt-get install oracle-java8-installerJDK7：sudo apt-get install oracle-java7-installer 安装时会提示你同意Oracle的服务条款，选择ok，然后选择yes这种方式安装后jdk路径为/usr/lib/jvm/java-8-oracle。 二、安装ssh server 实现免密码登录Hadoop需要使用ssh进行通信，首先我们需要在我们的操作系统上安装ssh。在安装之前，我们需要查看系统是否已经安装并且启动了ssh。 12345#查看ssh安装包情况dpkg -l | grep ssh #查看是否启动ssh服务ps -e | grep ssh 如果系统中没有ssh服务，需要先安装：sudo apt-get install openssh-server我安装时出现了connect to host localhost port 22: Connection refused问题，在CSDN博客上找到解决方法： 先用：sudo apt-get install -f 解决依赖问题 然后：sudo apt-get install openssh-server 就可以了 安装完成之后，启动服务：sudo /etc/init.d/ssh start 三、安装Hadoop及配置根据上述地址下载hadoop-2.7.3.tar.gz文件 解压缩下载的文件到指定文件夹tar -zxvf hadoop-2.7.3 -C /usr/local/hadoop/ 配置/usr/local/hadoop/hadoop-2.7.3/etc/hadoop/目录下三个文件 core-site.xml配置如下：12345678910&lt;configuration&gt; &lt;property&gt; &lt;name&gt;fs.default.name&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/home/mindyu/tmp&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; hdfs-site.xml配置如下： 12345678910&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.permissions&lt;/name&gt; &lt;value&gt;false&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; hadoop-env.sh中进行对应的配置： 1234# The java implementation to use.export JAVA_HOME=/usr/lib/jvm/java-8-oracleexport HADOOP_HOME=/usr/local/hadoop/hadoop-2.7.3export PATH=$PATH:/usr/local/hadoop/hadoop-2.7.3/bin 在系统环境变量中写入hadoop路径：vim /etc/environment然后在文件尾追加:/usr/local/hadoop/hadoop-2.7.3/bin:/usr/local/hadoop/hadoop-2.7.3/sbin 重启系统 验证Hadoop单机模式安装完成hadoop version 启动hdfs 使用伪分布模式，首先完成格式化hadoop namenode -format 启动hdfssbin/start-all.sh 显示进程jps若显示以上内容即说明hdfs已经成功 Hadoop资源管理GUI：Hadoop节点管理GUI： 停止hdfssbin/stop-all.sh Ubuntu16.04 上运行 Hadoop2.7.3 自带wordCount摸索记录 启动hadoop: 运行命令：ps -ef|grep hadoop查询是否有hadoop进程： 在hdfs下创建input文件夹。准备两个文件，比如abc.txt和def.txt 里面各写上一句话(用于统计)。然后导入到hdfs文件系统中的input文件夹下。hadoop fs -put *.txt /input 执行：bin/hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.3.jar wordcount /input /output下次执行时需要将当前的output目录删除或者更换目录hadoop fs -rmr /output 查看hdfs下output中的文件： 查看结果：hadoop fs -cat /output/part-r-00000 myeclipse下搭建hadoop2.7.3开发环境 下载对应版本的myeclipse-hadoo-plugins插件 把解压后的插件（jar文件）放到myeclipse安装目录下的plugins文件夹下 重启MyEclipse window-&gt;preferences中会出现Hadoop Map/Reduce选项，选中并设置hadoop 的安装路径 在show view中把map/reduce显示到工具栏 打开 Hadoop Location配置窗口： 配置Map/Reduce Master和DFS Mastrer，Host和Port配置成与core-site.xml的一致 配置完成之后。（如果出现错误，检查hadoop集群是否启动成功，看日志是否有错误，先把错误调完，正确启动集群后再干别的） 新建测试项目File—&gt;Project，选择Map/Reduce Project，输入项目名称等。 将Hadoop源码(源码可在上文hadoop下载链接中下载)中的WordCount类拷贝到项目中 设置Run Configration的arguments参数： 执行WordCount类，查看结果。结果如下：]]></content>
      <categories>
        <category>Ubuntu学习</category>
      </categories>
      <tags>
        <tag>Ubuntu16.04</tag>
        <tag>Hadoop</tag>
        <tag>MyEclipse</tag>
      </tags>
  </entry>
</search>